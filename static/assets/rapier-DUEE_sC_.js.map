{"version":3,"file":"rapier-DUEE_sC_.js","sources":["../../node_modules/@dimforge/rapier3d/rapier_wasm3d_bg.js","../../node_modules/@dimforge/rapier3d/math.js","../../node_modules/@dimforge/rapier3d/dynamics/rigid_body.js","../../node_modules/@dimforge/rapier3d/dynamics/impulse_joint.js","../../node_modules/@dimforge/rapier3d/dynamics/coefficient_combine_rule.js","../../node_modules/@dimforge/rapier3d/geometry/feature.js","../../node_modules/@dimforge/rapier3d/geometry/shape.js","../../node_modules/@dimforge/rapier3d/pipeline/query_pipeline.js","../../node_modules/@dimforge/rapier3d/pipeline/event_queue.js","../../node_modules/@dimforge/rapier3d/pipeline/physics_hooks.js","../../node_modules/@dimforge/rapier3d/geometry/collider.js","../../node_modules/@dimforge/rapier3d/coarena.js","../../node_modules/@dimforge/rapier3d/dynamics/rigid_body_set.js","../../node_modules/@dimforge/rapier3d/dynamics/integration_parameters.js","../../node_modules/@dimforge/rapier3d/dynamics/impulse_joint_set.js","../../node_modules/@dimforge/rapier3d/dynamics/multibody_joint.js","../../node_modules/@dimforge/rapier3d/dynamics/multibody_joint_set.js","../../node_modules/@dimforge/rapier3d/dynamics/ccd_solver.js","../../node_modules/@dimforge/rapier3d/dynamics/island_manager.js","../../node_modules/@dimforge/rapier3d/geometry/broad_phase.js","../../node_modules/@dimforge/rapier3d/geometry/narrow_phase.js","../../node_modules/@dimforge/rapier3d/geometry/contact.js","../../node_modules/@dimforge/rapier3d/geometry/point.js","../../node_modules/@dimforge/rapier3d/geometry/ray.js","../../node_modules/@dimforge/rapier3d/geometry/toi.js","../../node_modules/@dimforge/rapier3d/pipeline/physics_pipeline.js","../../node_modules/@dimforge/rapier3d/pipeline/serialization_pipeline.js","../../node_modules/@dimforge/rapier3d/pipeline/debug_render_pipeline.js","../../node_modules/@dimforge/rapier3d/control/character_controller.js","../../node_modules/@dimforge/rapier3d/control/ray_cast_vehicle_controller.js","../../node_modules/@dimforge/rapier3d/pipeline/world.js","../../node_modules/@dimforge/rapier3d/geometry/collider_set.js","../../node_modules/@dimforge/rapier3d/exports.js"],"sourcesContent":["let wasm;\nexport function __wbg_set_wasm(val) {\n    wasm = val;\n}\n\n\nconst heap = new Array(128).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nlet heap_next = heap.length;\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nfunction getObject(idx) { return heap[idx]; }\n\nfunction dropObject(idx) {\n    if (idx < 132) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction isLikeNone(x) {\n    return x === undefined || x === null;\n}\n\nlet cachedFloat64Memory0 = null;\n\nfunction getFloat64Memory0() {\n    if (cachedFloat64Memory0 === null || cachedFloat64Memory0.byteLength === 0) {\n        cachedFloat64Memory0 = new Float64Array(wasm.memory.buffer);\n    }\n    return cachedFloat64Memory0;\n}\n\nlet cachedInt32Memory0 = null;\n\nfunction getInt32Memory0() {\n    if (cachedInt32Memory0 === null || cachedInt32Memory0.byteLength === 0) {\n        cachedInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachedInt32Memory0;\n}\n\nconst lTextDecoder = typeof TextDecoder === 'undefined' ? (0, module.require)('util').TextDecoder : TextDecoder;\n\nlet cachedTextDecoder = new lTextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachedUint8Memory0 = null;\n\nfunction getUint8Memory0() {\n    if (cachedUint8Memory0 === null || cachedUint8Memory0.byteLength === 0) {\n        cachedUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachedUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n/**\n* @returns {string}\n*/\nexport function version() {\n    let deferred1_0;\n    let deferred1_1;\n    try {\n        const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n        wasm.version(retptr);\n        var r0 = getInt32Memory0()[retptr / 4 + 0];\n        var r1 = getInt32Memory0()[retptr / 4 + 1];\n        deferred1_0 = r0;\n        deferred1_1 = r1;\n        return getStringFromWasm0(r0, r1);\n    } finally {\n        wasm.__wbindgen_add_to_stack_pointer(16);\n        wasm.__wbindgen_free(deferred1_0, deferred1_1, 1);\n    }\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\n\nlet cachedFloat32Memory0 = null;\n\nfunction getFloat32Memory0() {\n    if (cachedFloat32Memory0 === null || cachedFloat32Memory0.byteLength === 0) {\n        cachedFloat32Memory0 = new Float32Array(wasm.memory.buffer);\n    }\n    return cachedFloat32Memory0;\n}\n\nlet stack_pointer = 128;\n\nfunction addBorrowedObject(obj) {\n    if (stack_pointer == 1) throw new Error('out of js stack');\n    heap[--stack_pointer] = obj;\n    return stack_pointer;\n}\n\nfunction getArrayF32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getFloat32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet cachedUint32Memory0 = null;\n\nfunction getUint32Memory0() {\n    if (cachedUint32Memory0 === null || cachedUint32Memory0.byteLength === 0) {\n        cachedUint32Memory0 = new Uint32Array(wasm.memory.buffer);\n    }\n    return cachedUint32Memory0;\n}\n\nfunction getArrayU32FromWasm0(ptr, len) {\n    ptr = ptr >>> 0;\n    return getUint32Memory0().subarray(ptr / 4, ptr / 4 + len);\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nfunction passArrayF32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getFloat32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction passArray32ToWasm0(arg, malloc) {\n    const ptr = malloc(arg.length * 4, 4) >>> 0;\n    getUint32Memory0().set(arg, ptr / 4);\n    WASM_VECTOR_LEN = arg.length;\n    return ptr;\n}\n\nfunction handleError(f, args) {\n    try {\n        return f.apply(this, args);\n    } catch (e) {\n        wasm.__wbindgen_exn_store(addHeapObject(e));\n    }\n}\n/**\n*/\nexport const RawJointType = Object.freeze({ Revolute:0,\"0\":\"Revolute\",Fixed:1,\"1\":\"Fixed\",Prismatic:2,\"2\":\"Prismatic\",Rope:3,\"3\":\"Rope\",Spring:4,\"4\":\"Spring\",Spherical:5,\"5\":\"Spherical\",Generic:6,\"6\":\"Generic\", });\n/**\n*/\nexport const RawFeatureType = Object.freeze({ Vertex:0,\"0\":\"Vertex\",Edge:1,\"1\":\"Edge\",Face:2,\"2\":\"Face\",Unknown:3,\"3\":\"Unknown\", });\n/**\n*/\nexport const RawMotorModel = Object.freeze({ AccelerationBased:0,\"0\":\"AccelerationBased\",ForceBased:1,\"1\":\"ForceBased\", });\n/**\n*/\nexport const RawRigidBodyType = Object.freeze({ Dynamic:0,\"0\":\"Dynamic\",Fixed:1,\"1\":\"Fixed\",KinematicPositionBased:2,\"2\":\"KinematicPositionBased\",KinematicVelocityBased:3,\"3\":\"KinematicVelocityBased\", });\n/**\n*/\nexport const RawShapeType = Object.freeze({ Ball:0,\"0\":\"Ball\",Cuboid:1,\"1\":\"Cuboid\",Capsule:2,\"2\":\"Capsule\",Segment:3,\"3\":\"Segment\",Polyline:4,\"4\":\"Polyline\",Triangle:5,\"5\":\"Triangle\",TriMesh:6,\"6\":\"TriMesh\",HeightField:7,\"7\":\"HeightField\",Compound:8,\"8\":\"Compound\",ConvexPolyhedron:9,\"9\":\"ConvexPolyhedron\",Cylinder:10,\"10\":\"Cylinder\",Cone:11,\"11\":\"Cone\",RoundCuboid:12,\"12\":\"RoundCuboid\",RoundTriangle:13,\"13\":\"RoundTriangle\",RoundCylinder:14,\"14\":\"RoundCylinder\",RoundCone:15,\"15\":\"RoundCone\",RoundConvexPolyhedron:16,\"16\":\"RoundConvexPolyhedron\",HalfSpace:17,\"17\":\"HalfSpace\", });\n/**\n*/\nexport const RawJointAxis = Object.freeze({ X:0,\"0\":\"X\",Y:1,\"1\":\"Y\",Z:2,\"2\":\"Z\",AngX:3,\"3\":\"AngX\",AngY:4,\"4\":\"AngY\",AngZ:5,\"5\":\"AngZ\", });\n/**\n*/\nexport class RawBroadPhase {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawBroadPhase.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawbroadphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawbroadphase_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n}\n/**\n*/\nexport class RawCCDSolver {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawccdsolver_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawccdsolver_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n}\n/**\n*/\nexport class RawCharacterCollision {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcharactercollision_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawcharactercollision_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {number}\n    */\n    handle() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    translationDeltaApplied() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    translationDeltaRemaining() {\n        const ret = wasm.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawcharactercollision_toi(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldWitness1() {\n        const ret = wasm.rawcharactercollision_worldWitness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldWitness2() {\n        const ret = wasm.rawcharactercollision_worldWitness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldNormal1() {\n        const ret = wasm.rawcharactercollision_worldNormal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    worldNormal2() {\n        const ret = wasm.rawcharactercollision_worldNormal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawColliderSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawColliderSet.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcolliderset_free(ptr);\n    }\n    /**\n    * The world-space translation of this collider.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    coTranslation(handle) {\n        const ret = wasm.rawcolliderset_coTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this collider.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    coRotation(handle) {\n        const ret = wasm.rawcolliderset_coRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this collider.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the collider along the `x` axis.\n    * - `y`: the world-space position of the collider along the `y` axis.\n    * - `z`: the world-space position of the collider along the `z` axis.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    coSetTranslation(handle, x, y, z) {\n        wasm.rawcolliderset_coSetTranslation(this.__wbg_ptr, handle, x, y, z);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    coSetTranslationWrtParent(handle, x, y, z) {\n        wasm.rawcolliderset_coSetTranslationWrtParent(this.__wbg_ptr, handle, x, y, z);\n    }\n    /**\n    * Sets the rotation quaternion of this collider.\n    *\n    * This does nothing if a zero quaternion is provided.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * - `wakeUp`: forces the collider to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    coSetRotation(handle, x, y, z, w) {\n        wasm.rawcolliderset_coSetRotation(this.__wbg_ptr, handle, x, y, z, w);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    coSetRotationWrtParent(handle, x, y, z, w) {\n        wasm.rawcolliderset_coSetRotationWrtParent(this.__wbg_ptr, handle, x, y, z, w);\n    }\n    /**\n    * Is this collider a sensor?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    coIsSensor(handle) {\n        const ret = wasm.rawcolliderset_coIsSensor(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The type of the shape of this collider.\n    * @param {number} handle\n    * @returns {RawShapeType}\n    */\n    coShapeType(handle) {\n        const ret = wasm.rawcolliderset_coShapeType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHalfspaceNormal(handle) {\n        const ret = wasm.rawcolliderset_coHalfspaceNormal(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The half-extents of this collider if it is has a cuboid shape.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHalfExtents(handle) {\n        const ret = wasm.rawcolliderset_coHalfExtents(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * Set the half-extents of this collider if it has a cuboid shape.\n    * @param {number} handle\n    * @param {RawVector} newHalfExtents\n    */\n    coSetHalfExtents(handle, newHalfExtents) {\n        _assertClass(newHalfExtents, RawVector);\n        wasm.rawcolliderset_coSetHalfExtents(this.__wbg_ptr, handle, newHalfExtents.__wbg_ptr);\n    }\n    /**\n    * The radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRadius(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the radius of this collider if it is a ball, capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @param {number} newRadius\n    */\n    coSetRadius(handle, newRadius) {\n        wasm.rawcolliderset_coSetRadius(this.__wbg_ptr, handle, newRadius);\n    }\n    /**\n    * The half height of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHalfHeight(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHalfHeight(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the half height of this collider if it is a capsule, cylinder, or cone shape.\n    * @param {number} handle\n    * @param {number} newHalfheight\n    */\n    coSetHalfHeight(handle, newHalfheight) {\n        wasm.rawcolliderset_coSetHalfHeight(this.__wbg_ptr, handle, newHalfheight);\n    }\n    /**\n    * The radius of the round edges of this collider.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coRoundRadius(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coRoundRadius(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Set the radius of the round edges of this collider.\n    * @param {number} handle\n    * @param {number} newBorderRadius\n    */\n    coSetRoundRadius(handle, newBorderRadius) {\n        wasm.rawcolliderset_coSetRoundRadius(this.__wbg_ptr, handle, newBorderRadius);\n    }\n    /**\n    * The vertices of this triangle mesh, polyline, convex polyhedron, segment, triangle or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coVertices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coVertices(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The indices of this triangle mesh, polyline, or convex polyhedron, if it is one.\n    * @param {number} handle\n    * @returns {Uint32Array | undefined}\n    */\n    coIndices(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coIndices(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayU32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The height of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {Float32Array | undefined}\n    */\n    coHeightfieldHeights(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldHeights(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            let v1;\n            if (r0 !== 0) {\n                v1 = getArrayF32FromWasm0(r0, r1).slice();\n                wasm.__wbindgen_free(r0, r1 * 4, 4);\n            }\n            return v1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The scaling factor applied of this heightfield if it is one.\n    * @param {number} handle\n    * @returns {RawVector | undefined}\n    */\n    coHeightfieldScale(handle) {\n        const ret = wasm.rawcolliderset_coHeightfieldScale(this.__wbg_ptr, handle);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * The number of rows on this heightfield's height matrix, if it is one.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHeightfieldNRows(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldNRows(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The number of columns on this heightfield's height matrix, if it is one.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coHeightfieldNCols(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coHeightfieldNCols(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * The unique integer identifier of the collider this collider is attached to.\n    * @param {number} handle\n    * @returns {number | undefined}\n    */\n    coParent(handle) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawcolliderset_coParent(retptr, this.__wbg_ptr, handle);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    coSetEnabled(handle, enabled) {\n        wasm.rawcolliderset_coSetEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    coIsEnabled(handle) {\n        const ret = wasm.rawcolliderset_coIsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The friction coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFriction(handle) {\n        const ret = wasm.rawcolliderset_coFriction(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The restitution coefficient of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitution(handle) {\n        const ret = wasm.rawcolliderset_coRestitution(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The density of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coDensity(handle) {\n        const ret = wasm.rawcolliderset_coDensity(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The mass of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coMass(handle) {\n        const ret = wasm.rawcolliderset_coMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The volume of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coVolume(handle) {\n        const ret = wasm.rawcolliderset_coVolume(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The collision groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coCollisionGroups(handle) {\n        const ret = wasm.rawcolliderset_coCollisionGroups(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The solver groups of this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coSolverGroups(handle) {\n        const ret = wasm.rawcolliderset_coSolverGroups(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The physics hooks enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveHooks(handle) {\n        const ret = wasm.rawcolliderset_coActiveHooks(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The collision types enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveCollisionTypes(handle) {\n        const ret = wasm.rawcolliderset_coActiveCollisionTypes(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The events enabled for this collider.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coActiveEvents(handle) {\n        const ret = wasm.rawcolliderset_coActiveEvents(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * The total force magnitude beyond which a contact force event can be emitted.\n    * @param {number} handle\n    * @returns {number}\n    */\n    coContactForceEventThreshold(handle) {\n        const ret = wasm.rawcolliderset_coContactForceEventThreshold(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n    coContainsPoint(handle, point) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coContainsPoint(this.__wbg_ptr, handle, point.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} colliderVel\n    * @param {RawShape} shape2\n    * @param {RawVector} shape2Pos\n    * @param {RawRotation} shape2Rot\n    * @param {RawVector} shape2Vel\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeTOI | undefined}\n    */\n    coCastShape(handle, colliderVel, shape2, shape2Pos, shape2Rot, shape2Vel, maxToi, stop_at_penetration) {\n        _assertClass(colliderVel, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shape2Pos, RawVector);\n        _assertClass(shape2Rot, RawRotation);\n        _assertClass(shape2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastShape(this.__wbg_ptr, handle, colliderVel.__wbg_ptr, shape2.__wbg_ptr, shape2Pos.__wbg_ptr, shape2Rot.__wbg_ptr, shape2Vel.__wbg_ptr, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeTOI.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} collider1Vel\n    * @param {number} collider2handle\n    * @param {RawVector} collider2Vel\n    * @param {number} max_toi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeColliderTOI | undefined}\n    */\n    coCastCollider(handle, collider1Vel, collider2handle, collider2Vel, max_toi, stop_at_penetration) {\n        _assertClass(collider1Vel, RawVector);\n        _assertClass(collider2Vel, RawVector);\n        const ret = wasm.rawcolliderset_coCastCollider(this.__wbg_ptr, handle, collider1Vel.__wbg_ptr, collider2handle, collider2Vel.__wbg_ptr, max_toi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeColliderTOI.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n    coIntersectsShape(handle, shape2, shapePos2, shapeRot2) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coIntersectsShape(this.__wbg_ptr, handle, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    coContactShape(handle, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawcolliderset_coContactShape(this.__wbg_ptr, handle, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} collider2handle\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    coContactCollider(handle, collider2handle, prediction) {\n        const ret = wasm.rawcolliderset_coContactCollider(this.__wbg_ptr, handle, collider2handle, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n    coProjectPoint(handle, point, solid) {\n        _assertClass(point, RawVector);\n        const ret = wasm.rawcolliderset_coProjectPoint(this.__wbg_ptr, handle, point.__wbg_ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n    coIntersectsRay(handle, rayOrig, rayDir, maxToi) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coIntersectsRay(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n    coCastRay(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRay(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n    coCastRayAndGetNormal(handle, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawcolliderset_coCastRayAndGetNormal(this.__wbg_ptr, handle, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} is_sensor\n    */\n    coSetSensor(handle, is_sensor) {\n        wasm.rawcolliderset_coSetSensor(this.__wbg_ptr, handle, is_sensor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} restitution\n    */\n    coSetRestitution(handle, restitution) {\n        wasm.rawcolliderset_coSetRestitution(this.__wbg_ptr, handle, restitution);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} friction\n    */\n    coSetFriction(handle, friction) {\n        wasm.rawcolliderset_coSetFriction(this.__wbg_ptr, handle, friction);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coFrictionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coFrictionCombineRule(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetFrictionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetFrictionCombineRule(this.__wbg_ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    coRestitutionCombineRule(handle) {\n        const ret = wasm.rawcolliderset_coRestitutionCombineRule(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} rule\n    */\n    coSetRestitutionCombineRule(handle, rule) {\n        wasm.rawcolliderset_coSetRestitutionCombineRule(this.__wbg_ptr, handle, rule);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetCollisionGroups(handle, groups) {\n        wasm.rawcolliderset_coSetCollisionGroups(this.__wbg_ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} groups\n    */\n    coSetSolverGroups(handle, groups) {\n        wasm.rawcolliderset_coSetSolverGroups(this.__wbg_ptr, handle, groups);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} hooks\n    */\n    coSetActiveHooks(handle, hooks) {\n        wasm.rawcolliderset_coSetActiveHooks(this.__wbg_ptr, handle, hooks);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} events\n    */\n    coSetActiveEvents(handle, events) {\n        wasm.rawcolliderset_coSetActiveEvents(this.__wbg_ptr, handle, events);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} types\n    */\n    coSetActiveCollisionTypes(handle, types) {\n        wasm.rawcolliderset_coSetActiveCollisionTypes(this.__wbg_ptr, handle, types);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawShape} shape\n    */\n    coSetShape(handle, shape) {\n        _assertClass(shape, RawShape);\n        wasm.rawcolliderset_coSetShape(this.__wbg_ptr, handle, shape.__wbg_ptr);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} threshold\n    */\n    coSetContactForceEventThreshold(handle, threshold) {\n        wasm.rawcolliderset_coSetContactForceEventThreshold(this.__wbg_ptr, handle, threshold);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} density\n    */\n    coSetDensity(handle, density) {\n        wasm.rawcolliderset_coSetDensity(this.__wbg_ptr, handle, density);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    */\n    coSetMass(handle, mass) {\n        wasm.rawcolliderset_coSetMass(this.__wbg_ptr, handle, mass);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    */\n    coSetMassProperties(handle, mass, centerOfMass, principalAngularInertia, angularInertiaFrame) {\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        wasm.rawcolliderset_coSetMassProperties(this.__wbg_ptr, handle, mass, centerOfMass.__wbg_ptr, principalAngularInertia.__wbg_ptr, angularInertiaFrame.__wbg_ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawcolliderset_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawcolliderset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {boolean} enabled\n    * @param {RawShape} shape\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} massPropsMode\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {number} density\n    * @param {number} friction\n    * @param {number} restitution\n    * @param {number} frictionCombineRule\n    * @param {number} restitutionCombineRule\n    * @param {boolean} isSensor\n    * @param {number} collisionGroups\n    * @param {number} solverGroups\n    * @param {number} activeCollisionTypes\n    * @param {number} activeHooks\n    * @param {number} activeEvents\n    * @param {number} contactForceEventThreshold\n    * @param {boolean} hasParent\n    * @param {number} parent\n    * @param {RawRigidBodySet} bodies\n    * @returns {number | undefined}\n    */\n    createCollider(enabled, shape, translation, rotation, massPropsMode, mass, centerOfMass, principalAngularInertia, angularInertiaFrame, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, hasParent, parent, bodies) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(shape, RawShape);\n            _assertClass(translation, RawVector);\n            _assertClass(rotation, RawRotation);\n            _assertClass(centerOfMass, RawVector);\n            _assertClass(principalAngularInertia, RawVector);\n            _assertClass(angularInertiaFrame, RawRotation);\n            _assertClass(bodies, RawRigidBodySet);\n            wasm.rawcolliderset_createCollider(retptr, this.__wbg_ptr, enabled, shape.__wbg_ptr, translation.__wbg_ptr, rotation.__wbg_ptr, massPropsMode, mass, centerOfMass.__wbg_ptr, principalAngularInertia.__wbg_ptr, angularInertiaFrame.__wbg_ptr, density, friction, restitution, frictionCombineRule, restitutionCombineRule, isSensor, collisionGroups, solverGroups, activeCollisionTypes, activeHooks, activeEvents, contactForceEventThreshold, hasParent, parent, bodies.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * Removes a collider from this set and wake-up the rigid-body it is attached to.\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawRigidBodySet} bodies\n    * @param {boolean} wakeUp\n    */\n    remove(handle, islands, bodies, wakeUp) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(bodies, RawRigidBodySet);\n        wasm.rawcolliderset_remove(this.__wbg_ptr, handle, islands.__wbg_ptr, bodies.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Checks if a collider with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    isHandleValid(handle) {\n        const ret = wasm.rawcolliderset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each collider managed by this collider set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each collider managed by this collider set. Called as `f(handle)`.\n    * @param {Function} f\n    */\n    forEachColliderHandle(f) {\n        try {\n            wasm.rawcolliderset_forEachColliderHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawContactForceEvent {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactForceEvent.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactforceevent_free(ptr);\n    }\n    /**\n    * The first collider involved in the contact.\n    * @returns {number}\n    */\n    collider1() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The second collider involved in the contact.\n    * @returns {number}\n    */\n    collider2() {\n        const ret = wasm.rawcontactforceevent_collider2(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The sum of all the forces between the two colliders.\n    * @returns {RawVector}\n    */\n    total_force() {\n        const ret = wasm.rawcontactforceevent_total_force(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The sum of the magnitudes of each force between the two colliders.\n    *\n    * Note that this is **not** the same as the magnitude of `self.total_force`.\n    * Here we are summing the magnitude of all the forces, instead of taking\n    * the magnitude of their sum.\n    * @returns {number}\n    */\n    total_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The world-space (unit) direction of the force with strongest magnitude.\n    * @returns {RawVector}\n    */\n    max_force_direction() {\n        const ret = wasm.rawcontactforceevent_max_force_direction(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The magnitude of the largest force at a contact point of this contact pair.\n    * @returns {number}\n    */\n    max_force_magnitude() {\n        const ret = wasm.rawcontactforceevent_max_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawContactManifold {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactManifold.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactmanifold_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawcontactmanifold_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n1() {\n        const ret = wasm.rawcontactmanifold_local_n1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    local_n2() {\n        const ret = wasm.rawcontactmanifold_local_n2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    subshape1() {\n        const ret = wasm.rawcontactmanifold_subshape1(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    subshape2() {\n        const ret = wasm.rawcontactmanifold_subshape2(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    num_contacts() {\n        const ret = wasm.rawcontactmanifold_num_contacts(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p1(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p1(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    contact_local_p2(i) {\n        const ret = wasm.rawcontactmanifold_contact_local_p2(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_contact_dist(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid1(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid1(this.__wbg_ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_fid2(i) {\n        const ret = wasm.rawcontactmanifold_contact_fid2(this.__wbg_ptr, i);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_impulse(i) {\n        const ret = wasm.rawcontactmanifold_contact_impulse(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_tangent_impulse_x(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse_x(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    contact_tangent_impulse_y(i) {\n        const ret = wasm.rawcontactmanifold_contact_tangent_impulse_y(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    num_solver_contacts() {\n        const ret = wasm.rawcontactmanifold_num_solver_contacts(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    solver_contact_point(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_point(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_dist(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_dist(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_friction(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_friction(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {number}\n    */\n    solver_contact_restitution(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_restitution(this.__wbg_ptr, i);\n        return ret;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector}\n    */\n    solver_contact_tangent_velocity(i) {\n        const ret = wasm.rawcontactmanifold_solver_contact_tangent_velocity(this.__wbg_ptr, i);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawContactPair {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawContactPair.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawcontactpair_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    collider1() {\n        const ret = wasm.rawcontactpair_collider1(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    collider2() {\n        const ret = wasm.rawcontactpair_collider2(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    numContactManifolds() {\n        const ret = wasm.rawcontactpair_numContactManifolds(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {RawContactManifold | undefined}\n    */\n    contactManifold(i) {\n        const ret = wasm.rawcontactpair_contactManifold(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawContactManifold.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawDebugRenderPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdebugrenderpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawdebugrenderpipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    vertices() {\n        const ret = wasm.rawdebugrenderpipeline_vertices(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {Float32Array}\n    */\n    colors() {\n        const ret = wasm.rawdebugrenderpipeline_colors(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @param {RawNarrowPhase} narrow_phase\n    */\n    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        _assertClass(narrow_phase, RawNarrowPhase);\n        wasm.rawdebugrenderpipeline_render(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, impulse_joints.__wbg_ptr, multibody_joints.__wbg_ptr, narrow_phase.__wbg_ptr);\n    }\n}\n/**\n*/\nexport class RawDeserializedWorld {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawDeserializedWorld.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdeserializedworld_free(ptr);\n    }\n    /**\n    * @returns {RawVector | undefined}\n    */\n    takeGravity() {\n        const ret = wasm.rawdeserializedworld_takeGravity(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawIntegrationParameters | undefined}\n    */\n    takeIntegrationParameters() {\n        const ret = wasm.rawdeserializedworld_takeIntegrationParameters(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawIntegrationParameters.__wrap(ret);\n    }\n    /**\n    * @returns {RawIslandManager | undefined}\n    */\n    takeIslandManager() {\n        const ret = wasm.rawdeserializedworld_takeIslandManager(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawIslandManager.__wrap(ret);\n    }\n    /**\n    * @returns {RawBroadPhase | undefined}\n    */\n    takeBroadPhase() {\n        const ret = wasm.rawdeserializedworld_takeBroadPhase(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawBroadPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawNarrowPhase | undefined}\n    */\n    takeNarrowPhase() {\n        const ret = wasm.rawdeserializedworld_takeNarrowPhase(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawNarrowPhase.__wrap(ret);\n    }\n    /**\n    * @returns {RawRigidBodySet | undefined}\n    */\n    takeBodies() {\n        const ret = wasm.rawdeserializedworld_takeBodies(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawRigidBodySet.__wrap(ret);\n    }\n    /**\n    * @returns {RawColliderSet | undefined}\n    */\n    takeColliders() {\n        const ret = wasm.rawdeserializedworld_takeColliders(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawColliderSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawImpulseJointSet | undefined}\n    */\n    takeImpulseJoints() {\n        const ret = wasm.rawdeserializedworld_takeImpulseJoints(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawImpulseJointSet.__wrap(ret);\n    }\n    /**\n    * @returns {RawMultibodyJointSet | undefined}\n    */\n    takeMultibodyJoints() {\n        const ret = wasm.rawdeserializedworld_takeMultibodyJoints(this.__wbg_ptr);\n        return ret === 0 ? undefined : RawMultibodyJointSet.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawDynamicRayCastVehicleController {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawdynamicraycastvehiclecontroller_free(ptr);\n    }\n    /**\n    * @param {number} chassis\n    */\n    constructor(chassis) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_new(chassis);\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {number}\n    */\n    current_vehicle_speed() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_current_vehicle_speed(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    chassis() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_chassis(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    index_up_axis() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_index_up_axis(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} axis\n    */\n    set_index_up_axis(axis) {\n        wasm.rawdynamicraycastvehiclecontroller_set_index_up_axis(this.__wbg_ptr, axis);\n    }\n    /**\n    * @returns {number}\n    */\n    index_forward_axis() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_index_forward_axis(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} axis\n    */\n    set_index_forward_axis(axis) {\n        wasm.rawdynamicraycastvehiclecontroller_set_index_forward_axis(this.__wbg_ptr, axis);\n    }\n    /**\n    * @param {RawVector} chassis_connection_cs\n    * @param {RawVector} direction_cs\n    * @param {RawVector} axle_cs\n    * @param {number} suspension_rest_length\n    * @param {number} radius\n    */\n    add_wheel(chassis_connection_cs, direction_cs, axle_cs, suspension_rest_length, radius) {\n        _assertClass(chassis_connection_cs, RawVector);\n        _assertClass(direction_cs, RawVector);\n        _assertClass(axle_cs, RawVector);\n        wasm.rawdynamicraycastvehiclecontroller_add_wheel(this.__wbg_ptr, chassis_connection_cs.__wbg_ptr, direction_cs.__wbg_ptr, axle_cs.__wbg_ptr, suspension_rest_length, radius);\n    }\n    /**\n    * @returns {number}\n    */\n    num_wheels() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_num_wheels(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} dt\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawQueryPipeline} queries\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {Function} filter_predicate\n    */\n    update_vehicle(dt, bodies, colliders, queries, filter_flags, filter_groups, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(queries, RawQueryPipeline);\n            wasm.rawdynamicraycastvehiclecontroller_update_vehicle(this.__wbg_ptr, dt, bodies.__wbg_ptr, colliders.__wbg_ptr, queries.__wbg_ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    wheel_chassis_connection_point_cs(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_chassis_connection_point_cs(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @param {RawVector} value\n    */\n    set_wheel_chassis_connection_point_cs(i, value) {\n        _assertClass(value, RawVector);\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_chassis_connection_point_cs(this.__wbg_ptr, i, value.__wbg_ptr);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_suspension_rest_length(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_rest_length(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_suspension_rest_length(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_suspension_rest_length(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_max_suspension_travel(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_max_suspension_travel(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_max_suspension_travel(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_travel(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_radius(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_radius(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_radius(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_radius(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_suspension_stiffness(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_stiffness(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_suspension_stiffness(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_suspension_stiffness(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_suspension_compression(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_compression(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_suspension_compression(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_suspension_compression(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_suspension_relaxation(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_relaxation(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_suspension_relaxation(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_suspension_relaxation(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_max_suspension_force(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_max_suspension_force(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_max_suspension_force(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_force(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_brake(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_brake(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_brake(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_brake(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_steering(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_steering(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_steering(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_steering(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_engine_force(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_engine_force(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_engine_force(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_engine_force(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    wheel_direction_cs(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_direction_cs(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @param {RawVector} value\n    */\n    set_wheel_direction_cs(i, value) {\n        _assertClass(value, RawVector);\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_direction_cs(this.__wbg_ptr, i, value.__wbg_ptr);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    wheel_axle_cs(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_axle_cs(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @param {RawVector} value\n    */\n    set_wheel_axle_cs(i, value) {\n        _assertClass(value, RawVector);\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_axle_cs(this.__wbg_ptr, i, value.__wbg_ptr);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_friction_slip(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_friction_slip(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} value\n    */\n    set_wheel_friction_slip(i, value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_friction_slip(this.__wbg_ptr, i, value);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_side_friction_stiffness(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_side_friction_stiffness(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @param {number} stiffness\n    */\n    set_wheel_side_friction_stiffness(i, stiffness) {\n        wasm.rawdynamicraycastvehiclecontroller_set_wheel_side_friction_stiffness(this.__wbg_ptr, i, stiffness);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_rotation(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_rotation(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_forward_impulse(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_forward_impulse(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_side_impulse(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_side_impulse(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_suspension_force(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_force(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    wheel_contact_normal_ws(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_contact_normal_ws(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    wheel_contact_point_ws(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_contact_point_ws(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_suspension_length(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_suspension_length(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} i\n    * @returns {RawVector | undefined}\n    */\n    wheel_hard_point_ws(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_hard_point_ws(this.__wbg_ptr, i);\n        return ret === 0 ? undefined : RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} i\n    * @returns {boolean}\n    */\n    wheel_is_in_contact(i) {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_wheel_is_in_contact(this.__wbg_ptr, i);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} i\n    * @returns {number | undefined}\n    */\n    wheel_ground_object(i) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawdynamicraycastvehiclecontroller_wheel_ground_object(retptr, this.__wbg_ptr, i);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n* A structure responsible for collecting events generated\n* by the physics engine.\n*/\nexport class RawEventQueue {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_raweventqueue_free(ptr);\n    }\n    /**\n    * Creates a new event collector.\n    *\n    * # Parameters\n    * - `autoDrain`: setting this to `true` is strongly recommended. If true, the collector will\n    * be automatically drained before each `world.step(collector)`. If false, the collector will\n    * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n    * RAM if no drain is performed.\n    * @param {boolean} autoDrain\n    */\n    constructor(autoDrain) {\n        const ret = wasm.raweventqueue_new(autoDrain);\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * Applies the given javascript closure on each collision event of this collector, then clear\n    * the internal collision event buffer.\n    *\n    * # Parameters\n    * - `f(handle1, handle2, started)`:  JavaScript closure applied to each collision event. The\n    * closure should take three arguments: two integers representing the handles of the colliders\n    * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n    * (false).\n    * @param {Function} f\n    */\n    drainCollisionEvents(f) {\n        try {\n            wasm.raweventqueue_drainCollisionEvents(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {Function} f\n    */\n    drainContactForceEvents(f) {\n        try {\n            wasm.raweventqueue_drainContactForceEvents(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Removes all events contained by this collector.\n    */\n    clear() {\n        wasm.raweventqueue_clear(this.__wbg_ptr);\n    }\n}\n/**\n*/\nexport class RawGenericJoint {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawGenericJoint.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawgenericjoint_free(ptr);\n    }\n    /**\n    * Creates a new joint descriptor that builds generic joints.\n    *\n    * Generic joints allow arbitrary axes of freedom to be selected\n    * for the joint from the available 6 degrees of freedom.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @param {number} lockedAxes\n    * @returns {RawGenericJoint | undefined}\n    */\n    static generic(anchor1, anchor2, axis, lockedAxes) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_generic(anchor1.__wbg_ptr, anchor2.__wbg_ptr, axis.__wbg_ptr, lockedAxes);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * @param {number} rest_length\n    * @param {number} stiffness\n    * @param {number} damping\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint}\n    */\n    static spring(rest_length, stiffness, damping, anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_spring(rest_length, stiffness, damping, anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * @param {number} length\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint}\n    */\n    static rope(length, anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_rope(length, anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Create a new joint descriptor that builds spherical joints.\n    *\n    * A spherical joints allows three relative rotational degrees of freedom\n    * by preventing any relative translation between the anchors of the\n    * two attached rigid-bodies.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @returns {RawGenericJoint}\n    */\n    static spherical(anchor1, anchor2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        const ret = wasm.rawgenericjoint_spherical(anchor1.__wbg_ptr, anchor2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Prismatic joint.\n    *\n    * A prismatic joint removes all the degrees of freedom between the\n    * affected bodies, except for the translation along one axis.\n    *\n    * Returns `None` if any of the provided axes cannot be normalized.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @param {boolean} limitsEnabled\n    * @param {number} limitsMin\n    * @param {number} limitsMax\n    * @returns {RawGenericJoint | undefined}\n    */\n    static prismatic(anchor1, anchor2, axis, limitsEnabled, limitsMin, limitsMax) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_prismatic(anchor1.__wbg_ptr, anchor2.__wbg_ptr, axis.__wbg_ptr, limitsEnabled, limitsMin, limitsMax);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Creates a new joint descriptor that builds a Fixed joint.\n    *\n    * A fixed joint removes all the degrees of freedom between the affected bodies.\n    * @param {RawVector} anchor1\n    * @param {RawRotation} axes1\n    * @param {RawVector} anchor2\n    * @param {RawRotation} axes2\n    * @returns {RawGenericJoint}\n    */\n    static fixed(anchor1, axes1, anchor2, axes2) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(axes1, RawRotation);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axes2, RawRotation);\n        const ret = wasm.rawgenericjoint_fixed(anchor1.__wbg_ptr, axes1.__wbg_ptr, anchor2.__wbg_ptr, axes2.__wbg_ptr);\n        return RawGenericJoint.__wrap(ret);\n    }\n    /**\n    * Create a new joint descriptor that builds Revolute joints.\n    *\n    * A revolute joint removes all degrees of freedom between the affected\n    * bodies except for the rotation along one axis.\n    * @param {RawVector} anchor1\n    * @param {RawVector} anchor2\n    * @param {RawVector} axis\n    * @returns {RawGenericJoint | undefined}\n    */\n    static revolute(anchor1, anchor2, axis) {\n        _assertClass(anchor1, RawVector);\n        _assertClass(anchor2, RawVector);\n        _assertClass(axis, RawVector);\n        const ret = wasm.rawgenericjoint_revolute(anchor1.__wbg_ptr, anchor2.__wbg_ptr, axis.__wbg_ptr);\n        return ret === 0 ? undefined : RawGenericJoint.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawImpulseJointSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawImpulseJointSet.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawimpulsejointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {RawJointType}\n    */\n    jointType(handle) {\n        const ret = wasm.rawimpulsejointset_jointType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The unique integer identifier of the first rigid-body this joint it attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle1(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle1(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The unique integer identifier of the second rigid-body this joint is attached to.\n    * @param {number} handle\n    * @returns {number}\n    */\n    jointBodyHandle2(handle) {\n        const ret = wasm.rawimpulsejointset_jointBodyHandle2(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular part of the joints local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX1(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joints local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        const ret = wasm.rawimpulsejointset_jointFrameX2(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor1(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        const ret = wasm.rawimpulsejointset_jointAnchor2(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Sets the position of the first local anchor\n    * @param {number} handle\n    * @param {RawVector} newPos\n    */\n    jointSetAnchor1(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor1(this.__wbg_ptr, handle, newPos.__wbg_ptr);\n    }\n    /**\n    * Sets the position of the second local anchor\n    * @param {number} handle\n    * @param {RawVector} newPos\n    */\n    jointSetAnchor2(handle, newPos) {\n        _assertClass(newPos, RawVector);\n        wasm.rawimpulsejointset_jointSetAnchor2(this.__wbg_ptr, handle, newPos.__wbg_ptr);\n    }\n    /**\n    * Are contacts between the rigid-bodies attached by this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawimpulsejointset_jointContactsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawimpulsejointset_jointSetContactsEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsEnabled(this.__wbg_ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMin(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawimpulsejointset_jointLimitsMax(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * Enables and sets the joint limits\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} min\n    * @param {number} max\n    */\n    jointSetLimits(handle, axis, min, max) {\n        wasm.rawimpulsejointset_jointSetLimits(this.__wbg_ptr, handle, axis, min, max);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {RawMotorModel} model\n    */\n    jointConfigureMotorModel(handle, axis, model) {\n        wasm.rawimpulsejointset_jointConfigureMotorModel(this.__wbg_ptr, handle, axis, model);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} targetVel\n    * @param {number} factor\n    */\n    jointConfigureMotorVelocity(handle, axis, targetVel, factor) {\n        wasm.rawimpulsejointset_jointConfigureMotorVelocity(this.__wbg_ptr, handle, axis, targetVel, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} targetPos\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureMotorPosition(handle, axis, targetPos, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotorPosition(this.__wbg_ptr, handle, axis, targetPos, stiffness, damping);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @param {number} targetPos\n    * @param {number} targetVel\n    * @param {number} stiffness\n    * @param {number} damping\n    */\n    jointConfigureMotor(handle, axis, targetPos, targetVel, stiffness, damping) {\n        wasm.rawimpulsejointset_jointConfigureMotor(this.__wbg_ptr, handle, axis, targetPos, targetVel, stiffness, damping);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawimpulsejointset_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawGenericJoint} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @param {boolean} wake_up\n    * @returns {number}\n    */\n    createJoint(params, parent1, parent2, wake_up) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawimpulsejointset_createJoint(this.__wbg_ptr, params.__wbg_ptr, parent1, parent2, wake_up);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    remove(handle, wakeUp) {\n        wasm.rawimpulsejointset_remove(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawimpulsejointset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawimpulsejointset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawimpulsejointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawIntegrationParameters {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawIntegrationParameters.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawintegrationparameters_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawintegrationparameters_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {number}\n    */\n    get dt() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get erp() {\n        const ret = wasm.rawintegrationparameters_erp(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get allowedLinearError() {\n        const ret = wasm.rawcontactforceevent_total_force_magnitude(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get predictionDistance() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_current_vehicle_speed(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    get numSolverIterations() {\n        const ret = wasm.rawintegrationparameters_numSolverIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get numAdditionalFrictionIterations() {\n        const ret = wasm.rawintegrationparameters_numAdditionalFrictionIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get numInternalPgsIterations() {\n        const ret = wasm.rawintegrationparameters_numInternalPgsIterations(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get minIslandSize() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_index_up_axis(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    get maxCcdSubsteps() {\n        const ret = wasm.rawdynamicraycastvehiclecontroller_index_forward_axis(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} value\n    */\n    set dt(value) {\n        wasm.rawintegrationparameters_set_dt(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set erp(value) {\n        wasm.rawintegrationparameters_set_erp(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set allowedLinearError(value) {\n        wasm.rawintegrationparameters_set_allowedLinearError(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set predictionDistance(value) {\n        wasm.rawintegrationparameters_set_predictionDistance(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set numSolverIterations(value) {\n        wasm.rawintegrationparameters_set_numSolverIterations(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set numAdditionalFrictionIterations(value) {\n        wasm.rawintegrationparameters_set_numAdditionalFrictionIterations(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set numInternalPgsIterations(value) {\n        wasm.rawintegrationparameters_set_numInternalPgsIterations(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set minIslandSize(value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_index_up_axis(this.__wbg_ptr, value);\n    }\n    /**\n    * @param {number} value\n    */\n    set maxCcdSubsteps(value) {\n        wasm.rawdynamicraycastvehiclecontroller_set_index_forward_axis(this.__wbg_ptr, value);\n    }\n    /**\n    */\n    switchToStandardPgsSolver() {\n        wasm.rawintegrationparameters_switchToStandardPgsSolver(this.__wbg_ptr);\n    }\n    /**\n    */\n    switchToSmallStepsPgsSolver() {\n        wasm.rawintegrationparameters_switchToSmallStepsPgsSolver(this.__wbg_ptr);\n    }\n}\n/**\n*/\nexport class RawIslandManager {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawIslandManager.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawislandmanager_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawislandmanager_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each active rigid-body\n    * managed by this island manager.\n    *\n    * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n    * the physics engine in order to save computational power. A sleeping rigid-body never moves\n    * unless it is moved manually by the user.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each active rigid-body managed by this\n    *   set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachActiveRigidBodyHandle(f) {\n        try {\n            wasm.rawislandmanager_forEachActiveRigidBodyHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawKinematicCharacterController {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawkinematiccharactercontroller_free(ptr);\n    }\n    /**\n    * @param {number} offset\n    */\n    constructor(offset) {\n        const ret = wasm.rawkinematiccharactercontroller_new(offset);\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    up() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} vector\n    */\n    setUp(vector) {\n        _assertClass(vector, RawVector);\n        wasm.rawkinematiccharactercontroller_setUp(this.__wbg_ptr, vector.__wbg_ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    offset() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} value\n    */\n    setOffset(value) {\n        wasm.rawkinematiccharactercontroller_setOffset(this.__wbg_ptr, value);\n    }\n    /**\n    * @returns {boolean}\n    */\n    slideEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_slideEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {boolean} enabled\n    */\n    setSlideEnabled(enabled) {\n        wasm.rawkinematiccharactercontroller_setSlideEnabled(this.__wbg_ptr, enabled);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    autostepMaxHeight() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_autostepMaxHeight(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    autostepMinWidth() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_autostepMinWidth(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @returns {boolean | undefined}\n    */\n    autostepIncludesDynamicBodies() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepIncludesDynamicBodies(this.__wbg_ptr);\n        return ret === 0xFFFFFF ? undefined : ret !== 0;\n    }\n    /**\n    * @returns {boolean}\n    */\n    autostepEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_autostepEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} maxHeight\n    * @param {number} minWidth\n    * @param {boolean} includeDynamicBodies\n    */\n    enableAutostep(maxHeight, minWidth, includeDynamicBodies) {\n        wasm.rawkinematiccharactercontroller_enableAutostep(this.__wbg_ptr, maxHeight, minWidth, includeDynamicBodies);\n    }\n    /**\n    */\n    disableAutostep() {\n        wasm.rawkinematiccharactercontroller_disableAutostep(this.__wbg_ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    maxSlopeClimbAngle() {\n        const ret = wasm.rawkinematiccharactercontroller_maxSlopeClimbAngle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} angle\n    */\n    setMaxSlopeClimbAngle(angle) {\n        wasm.rawkinematiccharactercontroller_setMaxSlopeClimbAngle(this.__wbg_ptr, angle);\n    }\n    /**\n    * @returns {number}\n    */\n    minSlopeSlideAngle() {\n        const ret = wasm.rawkinematiccharactercontroller_minSlopeSlideAngle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @param {number} angle\n    */\n    setMinSlopeSlideAngle(angle) {\n        wasm.rawkinematiccharactercontroller_setMinSlopeSlideAngle(this.__wbg_ptr, angle);\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    snapToGroundDistance() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawkinematiccharactercontroller_snapToGroundDistance(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getFloat32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n    /**\n    * @param {number} distance\n    */\n    enableSnapToGround(distance) {\n        wasm.rawkinematiccharactercontroller_enableSnapToGround(this.__wbg_ptr, distance);\n    }\n    /**\n    */\n    disableSnapToGround() {\n        wasm.rawkinematiccharactercontroller_disableSnapToGround(this.__wbg_ptr);\n    }\n    /**\n    * @returns {boolean}\n    */\n    snapToGroundEnabled() {\n        const ret = wasm.rawkinematiccharactercontroller_snapToGroundEnabled(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} dt\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawQueryPipeline} queries\n    * @param {number} collider_handle\n    * @param {RawVector} desired_translation_delta\n    * @param {boolean} apply_impulses_to_dynamic_bodies\n    * @param {number | undefined} character_mass\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {Function} filter_predicate\n    */\n    computeColliderMovement(dt, bodies, colliders, queries, collider_handle, desired_translation_delta, apply_impulses_to_dynamic_bodies, character_mass, filter_flags, filter_groups, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(queries, RawQueryPipeline);\n            _assertClass(desired_translation_delta, RawVector);\n            wasm.rawkinematiccharactercontroller_computeColliderMovement(this.__wbg_ptr, dt, bodies.__wbg_ptr, colliders.__wbg_ptr, queries.__wbg_ptr, collider_handle, desired_translation_delta.__wbg_ptr, apply_impulses_to_dynamic_bodies, !isLikeNone(character_mass), isLikeNone(character_mass) ? 0 : character_mass, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @returns {RawVector}\n    */\n    computedMovement() {\n        const ret = wasm.rawkinematiccharactercontroller_computedMovement(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    computedGrounded() {\n        const ret = wasm.rawkinematiccharactercontroller_computedGrounded(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {number}\n    */\n    numComputedCollisions() {\n        const ret = wasm.rawkinematiccharactercontroller_numComputedCollisions(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} i\n    * @param {RawCharacterCollision} collision\n    * @returns {boolean}\n    */\n    computedCollision(i, collision) {\n        _assertClass(collision, RawCharacterCollision);\n        const ret = wasm.rawkinematiccharactercontroller_computedCollision(this.__wbg_ptr, i, collision.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawMultibodyJointSet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawMultibodyJointSet.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawmultibodyjointset_free(ptr);\n    }\n    /**\n    * The type of this joint.\n    * @param {number} handle\n    * @returns {RawJointType}\n    */\n    jointType(handle) {\n        const ret = wasm.rawmultibodyjointset_jointType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular part of the joints local frame relative to the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX1(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular part of the joints local frame relative to the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    jointFrameX2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointFrameX2(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The position of the first anchor of this joint.\n    *\n    * The first anchor gives the position of the points application point on the\n    * local frame of the first rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor1(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor1(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The position of the second anchor of this joint.\n    *\n    * The second anchor gives the position of the points application point on the\n    * local frame of the second rigid-body it is attached to.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    jointAnchor2(handle) {\n        const ret = wasm.rawmultibodyjointset_jointAnchor2(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Are contacts between the rigid-bodies attached by this joint enabled?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    jointContactsEnabled(handle) {\n        const ret = wasm.rawmultibodyjointset_jointContactsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Sets whether contacts are enabled between the rigid-bodies attached by this joint.\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    jointSetContactsEnabled(handle, enabled) {\n        wasm.rawmultibodyjointset_jointSetContactsEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * Are the limits for this joint enabled?\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {boolean}\n    */\n    jointLimitsEnabled(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsEnabled(this.__wbg_ptr, handle, axis);\n        return ret !== 0;\n    }\n    /**\n    * Return the lower limit along the given joint axis.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n    jointLimitsMin(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMin(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    * If this is a prismatic joint, returns its upper limit.\n    * @param {number} handle\n    * @param {RawJointAxis} axis\n    * @returns {number}\n    */\n    jointLimitsMax(handle, axis) {\n        const ret = wasm.rawmultibodyjointset_jointLimitsMax(this.__wbg_ptr, handle, axis);\n        return ret;\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawmultibodyjointset_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawGenericJoint} params\n    * @param {number} parent1\n    * @param {number} parent2\n    * @param {boolean} wakeUp\n    * @returns {number}\n    */\n    createJoint(params, parent1, parent2, wakeUp) {\n        _assertClass(params, RawGenericJoint);\n        const ret = wasm.rawmultibodyjointset_createJoint(this.__wbg_ptr, params.__wbg_ptr, parent1, parent2, wakeUp);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    remove(handle, wakeUp) {\n        wasm.rawmultibodyjointset_remove(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawmultibodyjointset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint managed by this physics world.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachJointHandle(f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each joint attached to the given rigid-body.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each joint attached to the rigid-body. Called as `f(collider)`.\n    * @param {number} body\n    * @param {Function} f\n    */\n    forEachJointAttachedToRigidBody(body, f) {\n        try {\n            wasm.rawmultibodyjointset_forEachJointAttachedToRigidBody(this.__wbg_ptr, body, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawNarrowPhase {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawNarrowPhase.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawnarrowphase_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawnarrowphase_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    contact_pairs_with(handle1, f) {\n        wasm.rawnarrowphase_contact_pairs_with(this.__wbg_ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {RawContactPair | undefined}\n    */\n    contact_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_contact_pair(this.__wbg_ptr, handle1, handle2);\n        return ret === 0 ? undefined : RawContactPair.__wrap(ret);\n    }\n    /**\n    * @param {number} handle1\n    * @param {Function} f\n    */\n    intersection_pairs_with(handle1, f) {\n        wasm.rawnarrowphase_intersection_pairs_with(this.__wbg_ptr, handle1, addHeapObject(f));\n    }\n    /**\n    * @param {number} handle1\n    * @param {number} handle2\n    * @returns {boolean}\n    */\n    intersection_pair(handle1, handle2) {\n        const ret = wasm.rawnarrowphase_intersection_pair(this.__wbg_ptr, handle1, handle2);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawPhysicsPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawphysicspipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawphysicspipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    */\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        wasm.rawphysicspipeline_step(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr, ccd_solver.__wbg_ptr);\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    * @param {RawCCDSolver} ccd_solver\n    * @param {RawEventQueue} eventQueue\n    * @param {object} hookObject\n    * @param {Function} hookFilterContactPair\n    * @param {Function} hookFilterIntersectionPair\n    */\n    stepWithEvents(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, joints, articulations, ccd_solver, eventQueue, hookObject, hookFilterContactPair, hookFilterIntersectionPair) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        _assertClass(ccd_solver, RawCCDSolver);\n        _assertClass(eventQueue, RawEventQueue);\n        wasm.rawphysicspipeline_stepWithEvents(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr, ccd_solver.__wbg_ptr, eventQueue.__wbg_ptr, addHeapObject(hookObject), addHeapObject(hookFilterContactPair), addHeapObject(hookFilterIntersectionPair));\n    }\n}\n/**\n*/\nexport class RawPointColliderProjection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawPointColliderProjection.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointcolliderprojection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        const ret = wasm.rawpointcolliderprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        const ret = wasm.rawpointcolliderprojection_isInside(this.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @returns {RawFeatureType}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawPointProjection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawPointProjection.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawpointprojection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point() {\n        const ret = wasm.rawpointprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    isInside() {\n        const ret = wasm.rawpointprojection_isInside(this.__wbg_ptr);\n        return ret !== 0;\n    }\n}\n/**\n*/\nexport class RawQueryPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawquerypipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawquerypipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    */\n    update(bodies, colliders) {\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawquerypipeline_update(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr);\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawRayColliderToi | undefined}\n    */\n    castRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRay(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderToi.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawRayColliderIntersection | undefined}\n    */\n    castRayAndGetNormal(bodies, colliders, rayOrig, rayDir, maxToi, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            const ret = wasm.rawquerypipeline_castRayAndGetNormal(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawRayColliderIntersection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithRay(bodies, colliders, rayOrig, rayDir, maxToi, solid, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(rayOrig, RawVector);\n            _assertClass(rayDir, RawVector);\n            wasm.rawquerypipeline_intersectionsWithRay(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {number | undefined}\n    */\n    intersectionWithShape(bodies, colliders, shapePos, shapeRot, shape, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionWithShape(retptr, this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shape.__wbg_ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r2 = getFloat64Memory0()[retptr / 8 + 1];\n            return r0 === 0 ? undefined : r2;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPoint(bodies, colliders, point, solid, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPoint(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, solid, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawPointColliderProjection | undefined}\n    */\n    projectPointAndGetFeature(bodies, colliders, point, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            const ret = wasm.rawquerypipeline_projectPointAndGetFeature(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawPointColliderProjection.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} point\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithPoint(bodies, colliders, point, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(point, RawVector);\n            wasm.rawquerypipeline_intersectionsWithPoint(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, point.__wbg_ptr, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} shapeVel\n    * @param {RawShape} shape\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    * @returns {RawShapeColliderTOI | undefined}\n    */\n    castShape(bodies, colliders, shapePos, shapeRot, shapeVel, shape, maxToi, stop_at_penetration, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shapeVel, RawVector);\n            _assertClass(shape, RawShape);\n            const ret = wasm.rawquerypipeline_castShape(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shapeVel.__wbg_ptr, shape.__wbg_ptr, maxToi, stop_at_penetration, filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n            return ret === 0 ? undefined : RawShapeColliderTOI.__wrap(ret);\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawShape} shape\n    * @param {Function} callback\n    * @param {number} filter_flags\n    * @param {number | undefined} filter_groups\n    * @param {number | undefined} filter_exclude_collider\n    * @param {number | undefined} filter_exclude_rigid_body\n    * @param {Function} filter_predicate\n    */\n    intersectionsWithShape(bodies, colliders, shapePos, shapeRot, shape, callback, filter_flags, filter_groups, filter_exclude_collider, filter_exclude_rigid_body, filter_predicate) {\n        try {\n            _assertClass(bodies, RawRigidBodySet);\n            _assertClass(colliders, RawColliderSet);\n            _assertClass(shapePos, RawVector);\n            _assertClass(shapeRot, RawRotation);\n            _assertClass(shape, RawShape);\n            wasm.rawquerypipeline_intersectionsWithShape(this.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, shape.__wbg_ptr, addBorrowedObject(callback), filter_flags, !isLikeNone(filter_groups), isLikeNone(filter_groups) ? 0 : filter_groups, !isLikeNone(filter_exclude_collider), isLikeNone(filter_exclude_collider) ? 0 : filter_exclude_collider, !isLikeNone(filter_exclude_rigid_body), isLikeNone(filter_exclude_rigid_body) ? 0 : filter_exclude_rigid_body, addBorrowedObject(filter_predicate));\n        } finally {\n            heap[stack_pointer++] = undefined;\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawVector} aabbCenter\n    * @param {RawVector} aabbHalfExtents\n    * @param {Function} callback\n    */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        try {\n            _assertClass(aabbCenter, RawVector);\n            _assertClass(aabbHalfExtents, RawVector);\n            wasm.rawquerypipeline_collidersWithAabbIntersectingAabb(this.__wbg_ptr, aabbCenter.__wbg_ptr, aabbHalfExtents.__wbg_ptr, addBorrowedObject(callback));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n}\n/**\n*/\nexport class RawRayColliderIntersection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayColliderIntersection.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycolliderintersection_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawpointcolliderprojection_colliderHandle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawraycolliderintersection_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawraycolliderintersection_toi(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawFeatureType}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawRayColliderToi {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayColliderToi.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawraycollidertoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawraycolliderintersection_toi(this.__wbg_ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawRayIntersection {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRayIntersection.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrayintersection_free(ptr);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal() {\n        const ret = wasm.rawraycolliderintersection_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawraycolliderintersection_toi(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawFeatureType}\n    */\n    featureType() {\n        const ret = wasm.rawpointcolliderprojection_featureType(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number | undefined}\n    */\n    featureId() {\n        try {\n            const retptr = wasm.__wbindgen_add_to_stack_pointer(-16);\n            wasm.rawpointcolliderprojection_featureId(retptr, this.__wbg_ptr);\n            var r0 = getInt32Memory0()[retptr / 4 + 0];\n            var r1 = getInt32Memory0()[retptr / 4 + 1];\n            return r0 === 0 ? undefined : r1 >>> 0;\n        } finally {\n            wasm.__wbindgen_add_to_stack_pointer(16);\n        }\n    }\n}\n/**\n*/\nexport class RawRigidBodySet {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRigidBodySet.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrigidbodyset_free(ptr);\n    }\n    /**\n    * The world-space translation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space orientation of this rigid-body.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Put the given rigid-body to sleep.\n    * @param {number} handle\n    */\n    rbSleep(handle) {\n        wasm.rawrigidbodyset_rbSleep(this.__wbg_ptr, handle);\n    }\n    /**\n    * Is this rigid-body sleeping?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsSleeping(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsSleeping(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is the velocity of this rigid-body not zero?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsMoving(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsMoving(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The world-space predicted translation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbNextTranslation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextTranslation(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space predicted orientation of this rigid-body.\n    *\n    * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n    * method and is used for estimating the kinematic body velocity at the next timestep.\n    * For non-kinematic bodies, this value is currently unspecified.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbNextRotation(handle) {\n        const ret = wasm.rawrigidbodyset_rbNextRotation(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * Sets the translation of this rigid-body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * - `z`: the world-space position of the rigid-body along the `z` axis.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {boolean} wakeUp\n    */\n    rbSetTranslation(handle, x, y, z, wakeUp) {\n        wasm.rawrigidbodyset_rbSetTranslation(this.__wbg_ptr, handle, x, y, z, wakeUp);\n    }\n    /**\n    * Sets the rotation quaternion of this rigid-body.\n    *\n    * This does nothing if a zero quaternion is provided.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * - `wakeUp`: forces the rigid-body to wake-up so it is properly affected by forces if it\n    * wasn't moving before modifying its position.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    * @param {boolean} wakeUp\n    */\n    rbSetRotation(handle, x, y, z, w, wakeUp) {\n        wasm.rawrigidbodyset_rbSetRotation(this.__wbg_ptr, handle, x, y, z, w, wakeUp);\n    }\n    /**\n    * Sets the linear velocity of this rigid-body.\n    * @param {number} handle\n    * @param {RawVector} linvel\n    * @param {boolean} wakeUp\n    */\n    rbSetLinvel(handle, linvel, wakeUp) {\n        _assertClass(linvel, RawVector);\n        wasm.rawrigidbodyset_rbSetLinvel(this.__wbg_ptr, handle, linvel.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Sets the angular velocity of this rigid-body.\n    * @param {number} handle\n    * @param {RawVector} angvel\n    * @param {boolean} wakeUp\n    */\n    rbSetAngvel(handle, angvel, wakeUp) {\n        _assertClass(angvel, RawVector);\n        wasm.rawrigidbodyset_rbSetAngvel(this.__wbg_ptr, handle, angvel.__wbg_ptr, wakeUp);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `x`: the world-space position of the rigid-body along the `x` axis.\n    * - `y`: the world-space position of the rigid-body along the `y` axis.\n    * - `z`: the world-space position of the rigid-body along the `z` axis.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    rbSetNextKinematicTranslation(handle, x, y, z) {\n        wasm.rawrigidbodyset_rbSetNextKinematicTranslation(this.__wbg_ptr, handle, x, y, z);\n    }\n    /**\n    * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n    *\n    * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n    * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n    * an artificial velocity for this rigid-body from its current position and its next kinematic\n    * position. This velocity will be used to compute forces on dynamic bodies interacting with\n    * this body.\n    *\n    * # Parameters\n    * - `x`: the first vector component of the quaternion.\n    * - `y`: the second vector component of the quaternion.\n    * - `z`: the third vector component of the quaternion.\n    * - `w`: the scalar component of the quaternion.\n    * @param {number} handle\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    rbSetNextKinematicRotation(handle, x, y, z, w) {\n        wasm.rawrigidbodyset_rbSetNextKinematicRotation(this.__wbg_ptr, handle, x, y, z, w);\n    }\n    /**\n    * @param {number} handle\n    * @param {RawColliderSet} colliders\n    */\n    rbRecomputeMassPropertiesFromColliders(handle, colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_rbRecomputeMassPropertiesFromColliders(this.__wbg_ptr, handle, colliders.__wbg_ptr);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {boolean} wake_up\n    */\n    rbSetAdditionalMass(handle, mass, wake_up) {\n        wasm.rawrigidbodyset_rbSetAdditionalMass(this.__wbg_ptr, handle, mass, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} mass\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {boolean} wake_up\n    */\n    rbSetAdditionalMassProperties(handle, mass, centerOfMass, principalAngularInertia, angularInertiaFrame, wake_up) {\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        wasm.rawrigidbodyset_rbSetAdditionalMassProperties(this.__wbg_ptr, handle, mass, centerOfMass.__wbg_ptr, principalAngularInertia.__wbg_ptr, angularInertiaFrame.__wbg_ptr, wake_up);\n    }\n    /**\n    * The linear velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbLinvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinvel(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The angular velocity of this rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbAngvel(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngvel(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockTranslations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockTranslations(this.__wbg_ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} allow_x\n    * @param {boolean} allow_y\n    * @param {boolean} allow_z\n    * @param {boolean} wake_up\n    */\n    rbSetEnabledTranslations(handle, allow_x, allow_y, allow_z, wake_up) {\n        wasm.rawrigidbodyset_rbSetEnabledTranslations(this.__wbg_ptr, handle, allow_x, allow_y, allow_z, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} locked\n    * @param {boolean} wake_up\n    */\n    rbLockRotations(handle, locked, wake_up) {\n        wasm.rawrigidbodyset_rbLockRotations(this.__wbg_ptr, handle, locked, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} allow_x\n    * @param {boolean} allow_y\n    * @param {boolean} allow_z\n    * @param {boolean} wake_up\n    */\n    rbSetEnabledRotations(handle, allow_x, allow_y, allow_z, wake_up) {\n        wasm.rawrigidbodyset_rbSetEnabledRotations(this.__wbg_ptr, handle, allow_x, allow_y, allow_z, wake_up);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbDominanceGroup(handle) {\n        const ret = wasm.rawrigidbodyset_rbDominanceGroup(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} group\n    */\n    rbSetDominanceGroup(handle, group) {\n        wasm.rawrigidbodyset_rbSetDominanceGroup(this.__wbg_ptr, handle, group);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    rbEnableCcd(handle, enabled) {\n        wasm.rawrigidbodyset_rbEnableCcd(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * The mass of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The inverse of the mass of a rigid-body.\n    *\n    * If this is zero, the rigid-body is assumed to have infinite mass.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvMass(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The inverse mass taking into account translation locking.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbEffectiveInvMass(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveInvMass(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The center of mass of a rigid-body expressed in its local-space.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbLocalCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbLocalCom(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The world-space center of mass of the rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbWorldCom(handle) {\n        const ret = wasm.rawrigidbodyset_rbWorldCom(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The inverse of the principal angular inertia of the rigid-body.\n    *\n    * Components set to zero are assumed to be infinite along the corresponding principal axis.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbInvPrincipalInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbInvPrincipalInertiaSqrt(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The principal vectors of the local angular inertia tensor of the rigid-body.\n    * @param {number} handle\n    * @returns {RawRotation}\n    */\n    rbPrincipalInertiaLocalFrame(handle) {\n        const ret = wasm.rawrigidbodyset_rbPrincipalInertiaLocalFrame(this.__wbg_ptr, handle);\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The angular inertia along the principal inertia axes of the rigid-body.\n    * @param {number} handle\n    * @returns {RawVector}\n    */\n    rbPrincipalInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbPrincipalInertia(this.__wbg_ptr, handle);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n    * taking into account rotation locking.\n    * @param {number} handle\n    * @returns {RawSdpMatrix3}\n    */\n    rbEffectiveWorldInvInertiaSqrt(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt(this.__wbg_ptr, handle);\n        return RawSdpMatrix3.__wrap(ret);\n    }\n    /**\n    * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n    * this rigid-body.\n    * @param {number} handle\n    * @returns {RawSdpMatrix3}\n    */\n    rbEffectiveAngularInertia(handle) {\n        const ret = wasm.rawrigidbodyset_rbEffectiveAngularInertia(this.__wbg_ptr, handle);\n        return RawSdpMatrix3.__wrap(ret);\n    }\n    /**\n    * Wakes this rigid-body up.\n    *\n    * A dynamic rigid-body that does not move during several consecutive frames will\n    * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n    * to avoid useless computations.\n    * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n    * the position of a dynamic body so that it is properly simulated afterwards.\n    * @param {number} handle\n    */\n    rbWakeUp(handle) {\n        wasm.rawrigidbodyset_rbWakeUp(this.__wbg_ptr, handle);\n    }\n    /**\n    * Is Continuous Collision Detection enabled for this rigid-body?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsCcdEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsCcdEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The number of colliders attached to this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbNumColliders(handle) {\n        const ret = wasm.rawrigidbodyset_rbNumColliders(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Retrieves the `i-th` collider attached to this rigid-body.\n    *\n    * # Parameters\n    * - `at`: The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n    *         This index is **not** the same as the unique identifier of the collider.\n    * @param {number} handle\n    * @param {number} at\n    * @returns {number}\n    */\n    rbCollider(handle, at) {\n        const ret = wasm.rawrigidbodyset_rbCollider(this.__wbg_ptr, handle, at);\n        return ret;\n    }\n    /**\n    * The status of this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @returns {RawRigidBodyType}\n    */\n    rbBodyType(handle) {\n        const ret = wasm.rawrigidbodyset_rbBodyType(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * Set a new status for this rigid-body: fixed, dynamic, or kinematic.\n    * @param {number} handle\n    * @param {RawRigidBodyType} status\n    * @param {boolean} wake_up\n    */\n    rbSetBodyType(handle, status, wake_up) {\n        wasm.rawrigidbodyset_rbSetBodyType(this.__wbg_ptr, handle, status, wake_up);\n    }\n    /**\n    * Is this rigid-body fixed?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsFixed(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsFixed(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body kinematic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsKinematic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsKinematic(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Is this rigid-body dynamic?\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsDynamic(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsDynamic(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * The linear damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbLinearDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbLinearDamping(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * The angular damping coefficient of this rigid-body.\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbAngularDamping(handle) {\n        const ret = wasm.rawrigidbodyset_rbAngularDamping(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetLinearDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetLinearDamping(this.__wbg_ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    */\n    rbSetAngularDamping(handle, factor) {\n        wasm.rawrigidbodyset_rbSetAngularDamping(this.__wbg_ptr, handle, factor);\n    }\n    /**\n    * @param {number} handle\n    * @param {boolean} enabled\n    */\n    rbSetEnabled(handle, enabled) {\n        wasm.rawrigidbodyset_rbSetEnabled(this.__wbg_ptr, handle, enabled);\n    }\n    /**\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    rbIsEnabled(handle) {\n        const ret = wasm.rawrigidbodyset_rbIsEnabled(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbGravityScale(handle) {\n        const ret = wasm.rawrigidbodyset_rbGravityScale(this.__wbg_ptr, handle);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} factor\n    * @param {boolean} wakeUp\n    */\n    rbSetGravityScale(handle, factor, wakeUp) {\n        wasm.rawrigidbodyset_rbSetGravityScale(this.__wbg_ptr, handle, factor, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added forces added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    rbResetForces(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetForces(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * Resets to zero all user-added torques added to this rigid-body.\n    * @param {number} handle\n    * @param {boolean} wakeUp\n    */\n    rbResetTorques(handle, wakeUp) {\n        wasm.rawrigidbodyset_rbResetTorques(this.__wbg_ptr, handle, wakeUp);\n    }\n    /**\n    * Adds a force at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {boolean} wakeUp\n    */\n    rbAddForce(handle, force, wakeUp) {\n        _assertClass(force, RawVector);\n        wasm.rawrigidbodyset_rbAddForce(this.__wbg_ptr, handle, force.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulse(handle, impulse, wakeUp) {\n        _assertClass(impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulse(this.__wbg_ptr, handle, impulse.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Adds a torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque`: the world-space torque to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} torque\n    * @param {boolean} wakeUp\n    */\n    rbAddTorque(handle, torque, wakeUp) {\n        _assertClass(torque, RawVector);\n        wasm.rawrigidbodyset_rbAddTorque(this.__wbg_ptr, handle, torque.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Applies an impulsive torque at the center-of-mass of this rigid-body.\n    *\n    * # Parameters\n    * - `torque impulse`: the world-space torque impulse to apply on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} torque_impulse\n    * @param {boolean} wakeUp\n    */\n    rbApplyTorqueImpulse(handle, torque_impulse, wakeUp) {\n        _assertClass(torque_impulse, RawVector);\n        wasm.rawrigidbodyset_rbApplyTorqueImpulse(this.__wbg_ptr, handle, torque_impulse.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Adds a force at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `force`: the world-space force to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} force\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbAddForceAtPoint(handle, force, point, wakeUp) {\n        _assertClass(force, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbAddForceAtPoint(this.__wbg_ptr, handle, force.__wbg_ptr, point.__wbg_ptr, wakeUp);\n    }\n    /**\n    * Applies an impulse at the given world-space point of this rigid-body.\n    *\n    * # Parameters\n    * - `impulse`: the world-space impulse to apply on the rigid-body.\n    * - `point`: the world-space point where the impulse is to be applied on the rigid-body.\n    * - `wakeUp`: should the rigid-body be automatically woken-up?\n    * @param {number} handle\n    * @param {RawVector} impulse\n    * @param {RawVector} point\n    * @param {boolean} wakeUp\n    */\n    rbApplyImpulseAtPoint(handle, impulse, point, wakeUp) {\n        _assertClass(impulse, RawVector);\n        _assertClass(point, RawVector);\n        wasm.rawrigidbodyset_rbApplyImpulseAtPoint(this.__wbg_ptr, handle, impulse.__wbg_ptr, point.__wbg_ptr, wakeUp);\n    }\n    /**\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbAdditionalSolverIterations(handle) {\n        const ret = wasm.rawrigidbodyset_rbAdditionalSolverIterations(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * @param {number} handle\n    * @param {number} iters\n    */\n    rbSetAdditionalSolverIterations(handle, iters) {\n        wasm.rawrigidbodyset_rbSetAdditionalSolverIterations(this.__wbg_ptr, handle, iters);\n    }\n    /**\n    * An arbitrary user-defined 32-bit integer\n    * @param {number} handle\n    * @returns {number}\n    */\n    rbUserData(handle) {\n        const ret = wasm.rawrigidbodyset_rbUserData(this.__wbg_ptr, handle);\n        return ret >>> 0;\n    }\n    /**\n    * Sets the user-defined 32-bit integer of this rigid-body.\n    *\n    * # Parameters\n    * - `data`: an arbitrary user-defined 32-bit integer.\n    * @param {number} handle\n    * @param {number} data\n    */\n    rbSetUserData(handle, data) {\n        wasm.rawrigidbodyset_rbSetUserData(this.__wbg_ptr, handle, data);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawrigidbodyset_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {boolean} enabled\n    * @param {RawVector} translation\n    * @param {RawRotation} rotation\n    * @param {number} gravityScale\n    * @param {number} mass\n    * @param {boolean} massOnly\n    * @param {RawVector} centerOfMass\n    * @param {RawVector} linvel\n    * @param {RawVector} angvel\n    * @param {RawVector} principalAngularInertia\n    * @param {RawRotation} angularInertiaFrame\n    * @param {boolean} translationEnabledX\n    * @param {boolean} translationEnabledY\n    * @param {boolean} translationEnabledZ\n    * @param {boolean} rotationEnabledX\n    * @param {boolean} rotationEnabledY\n    * @param {boolean} rotationEnabledZ\n    * @param {number} linearDamping\n    * @param {number} angularDamping\n    * @param {RawRigidBodyType} rb_type\n    * @param {boolean} canSleep\n    * @param {boolean} sleeping\n    * @param {boolean} ccdEnabled\n    * @param {number} dominanceGroup\n    * @param {number} additional_solver_iterations\n    * @returns {number}\n    */\n    createRigidBody(enabled, translation, rotation, gravityScale, mass, massOnly, centerOfMass, linvel, angvel, principalAngularInertia, angularInertiaFrame, translationEnabledX, translationEnabledY, translationEnabledZ, rotationEnabledX, rotationEnabledY, rotationEnabledZ, linearDamping, angularDamping, rb_type, canSleep, sleeping, ccdEnabled, dominanceGroup, additional_solver_iterations) {\n        _assertClass(translation, RawVector);\n        _assertClass(rotation, RawRotation);\n        _assertClass(centerOfMass, RawVector);\n        _assertClass(linvel, RawVector);\n        _assertClass(angvel, RawVector);\n        _assertClass(principalAngularInertia, RawVector);\n        _assertClass(angularInertiaFrame, RawRotation);\n        const ret = wasm.rawrigidbodyset_createRigidBody(this.__wbg_ptr, enabled, translation.__wbg_ptr, rotation.__wbg_ptr, gravityScale, mass, massOnly, centerOfMass.__wbg_ptr, linvel.__wbg_ptr, angvel.__wbg_ptr, principalAngularInertia.__wbg_ptr, angularInertiaFrame.__wbg_ptr, translationEnabledX, translationEnabledY, translationEnabledZ, rotationEnabledX, rotationEnabledY, rotationEnabledZ, linearDamping, angularDamping, rb_type, canSleep, sleeping, ccdEnabled, dominanceGroup, additional_solver_iterations);\n        return ret;\n    }\n    /**\n    * @param {number} handle\n    * @param {RawIslandManager} islands\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} joints\n    * @param {RawMultibodyJointSet} articulations\n    */\n    remove(handle, islands, colliders, joints, articulations) {\n        _assertClass(islands, RawIslandManager);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(joints, RawImpulseJointSet);\n        _assertClass(articulations, RawMultibodyJointSet);\n        wasm.rawrigidbodyset_remove(this.__wbg_ptr, handle, islands.__wbg_ptr, colliders.__wbg_ptr, joints.__wbg_ptr, articulations.__wbg_ptr);\n    }\n    /**\n    * The number of rigid-bodies on this set.\n    * @returns {number}\n    */\n    len() {\n        const ret = wasm.rawcolliderset_len(this.__wbg_ptr);\n        return ret >>> 0;\n    }\n    /**\n    * Checks if a rigid-body with the given integer handle exists.\n    * @param {number} handle\n    * @returns {boolean}\n    */\n    contains(handle) {\n        const ret = wasm.rawrigidbodyset_contains(this.__wbg_ptr, handle);\n        return ret !== 0;\n    }\n    /**\n    * Applies the given JavaScript function to the integer handle of each rigid-body managed by this set.\n    *\n    * # Parameters\n    * - `f(handle)`: the function to apply to the integer handle of each rigid-body managed by this set. Called as `f(collider)`.\n    * @param {Function} f\n    */\n    forEachRigidBodyHandle(f) {\n        try {\n            wasm.rawrigidbodyset_forEachRigidBodyHandle(this.__wbg_ptr, addBorrowedObject(f));\n        } finally {\n            heap[stack_pointer++] = undefined;\n        }\n    }\n    /**\n    * @param {RawColliderSet} colliders\n    */\n    propagateModifiedBodyPositionsToColliders(colliders) {\n        _assertClass(colliders, RawColliderSet);\n        wasm.rawrigidbodyset_propagateModifiedBodyPositionsToColliders(this.__wbg_ptr, colliders.__wbg_ptr);\n    }\n}\n/**\n* A rotation quaternion.\n*/\nexport class RawRotation {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawRotation.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawrotation_free(ptr);\n    }\n    /**\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    * @param {number} w\n    */\n    constructor(x, y, z, w) {\n        const ret = wasm.rawrotation_new(x, y, z, w);\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * The identity quaternion.\n    * @returns {RawRotation}\n    */\n    static identity() {\n        const ret = wasm.rawrotation_identity();\n        return RawRotation.__wrap(ret);\n    }\n    /**\n    * The `x` component of this quaternion.\n    * @returns {number}\n    */\n    get x() {\n        const ret = wasm.rawrotation_x(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The `y` component of this quaternion.\n    * @returns {number}\n    */\n    get y() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The `z` component of this quaternion.\n    * @returns {number}\n    */\n    get z() {\n        const ret = wasm.rawraycolliderintersection_toi(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * The `w` component of this quaternion.\n    * @returns {number}\n    */\n    get w() {\n        const ret = wasm.rawintegrationparameters_erp(this.__wbg_ptr);\n        return ret;\n    }\n}\n/**\n*/\nexport class RawSdpMatrix3 {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawSdpMatrix3.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawsdpmatrix3_free(ptr);\n    }\n    /**\n    * Row major list of the upper-triangular part of the symmetric matrix.\n    * @returns {Float32Array}\n    */\n    elements() {\n        const ret = wasm.rawsdpmatrix3_elements(this.__wbg_ptr);\n        return takeObject(ret);\n    }\n}\n/**\n*/\nexport class RawSerializationPipeline {\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawserializationpipeline_free(ptr);\n    }\n    /**\n    */\n    constructor() {\n        const ret = wasm.rawserializationpipeline_new();\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * @param {RawVector} gravity\n    * @param {RawIntegrationParameters} integrationParameters\n    * @param {RawIslandManager} islands\n    * @param {RawBroadPhase} broadPhase\n    * @param {RawNarrowPhase} narrowPhase\n    * @param {RawRigidBodySet} bodies\n    * @param {RawColliderSet} colliders\n    * @param {RawImpulseJointSet} impulse_joints\n    * @param {RawMultibodyJointSet} multibody_joints\n    * @returns {Uint8Array | undefined}\n    */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulse_joints, multibody_joints) {\n        _assertClass(gravity, RawVector);\n        _assertClass(integrationParameters, RawIntegrationParameters);\n        _assertClass(islands, RawIslandManager);\n        _assertClass(broadPhase, RawBroadPhase);\n        _assertClass(narrowPhase, RawNarrowPhase);\n        _assertClass(bodies, RawRigidBodySet);\n        _assertClass(colliders, RawColliderSet);\n        _assertClass(impulse_joints, RawImpulseJointSet);\n        _assertClass(multibody_joints, RawMultibodyJointSet);\n        const ret = wasm.rawserializationpipeline_serializeAll(this.__wbg_ptr, gravity.__wbg_ptr, integrationParameters.__wbg_ptr, islands.__wbg_ptr, broadPhase.__wbg_ptr, narrowPhase.__wbg_ptr, bodies.__wbg_ptr, colliders.__wbg_ptr, impulse_joints.__wbg_ptr, multibody_joints.__wbg_ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @param {Uint8Array} data\n    * @returns {RawDeserializedWorld | undefined}\n    */\n    deserializeAll(data) {\n        const ret = wasm.rawserializationpipeline_deserializeAll(this.__wbg_ptr, addHeapObject(data));\n        return ret === 0 ? undefined : RawDeserializedWorld.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShape {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShape.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshape_free(ptr);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @param {number} hz\n    * @returns {RawShape}\n    */\n    static cuboid(hx, hy, hz) {\n        const ret = wasm.rawshape_cuboid(hx, hy, hz);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} hx\n    * @param {number} hy\n    * @param {number} hz\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCuboid(hx, hy, hz, borderRadius) {\n        const ret = wasm.rawshape_roundCuboid(hx, hy, hz, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static ball(radius) {\n        const ret = wasm.rawshape_ball(radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} normal\n    * @returns {RawShape}\n    */\n    static halfspace(normal) {\n        _assertClass(normal, RawVector);\n        const ret = wasm.rawshape_halfspace(normal.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static capsule(halfHeight, radius) {\n        const ret = wasm.rawshape_capsule(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static cylinder(halfHeight, radius) {\n        const ret = wasm.rawshape_cylinder(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCylinder(halfHeight, radius, borderRadius) {\n        const ret = wasm.rawshape_roundCylinder(halfHeight, radius, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @returns {RawShape}\n    */\n    static cone(halfHeight, radius) {\n        const ret = wasm.rawshape_cone(halfHeight, radius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} halfHeight\n    * @param {number} radius\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundCone(halfHeight, radius, borderRadius) {\n        const ret = wasm.rawshape_roundCone(halfHeight, radius, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n    static polyline(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_polyline(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape}\n    */\n    static trimesh(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_trimesh(ptr0, len0, ptr1, len1);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {number} nrows\n    * @param {number} ncols\n    * @param {Float32Array} heights\n    * @param {RawVector} scale\n    * @returns {RawShape}\n    */\n    static heightfield(nrows, ncols, heights, scale) {\n        const ptr0 = passArrayF32ToWasm0(heights, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        _assertClass(scale, RawVector);\n        const ret = wasm.rawshape_heightfield(nrows, ncols, ptr0, len0, scale.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @returns {RawShape}\n    */\n    static segment(p1, p2) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        const ret = wasm.rawshape_segment(p1.__wbg_ptr, p2.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @returns {RawShape}\n    */\n    static triangle(p1, p2, p3) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_triangle(p1.__wbg_ptr, p2.__wbg_ptr, p3.__wbg_ptr);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} p1\n    * @param {RawVector} p2\n    * @param {RawVector} p3\n    * @param {number} borderRadius\n    * @returns {RawShape}\n    */\n    static roundTriangle(p1, p2, p3, borderRadius) {\n        _assertClass(p1, RawVector);\n        _assertClass(p2, RawVector);\n        _assertClass(p3, RawVector);\n        const ret = wasm.rawshape_roundTriangle(p1.__wbg_ptr, p2.__wbg_ptr, p3.__wbg_ptr, borderRadius);\n        return RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @returns {RawShape | undefined}\n    */\n    static convexHull(points) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexHull(ptr0, len0);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} points\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexHull(points, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(points, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexHull(ptr0, len0, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @returns {RawShape | undefined}\n    */\n    static convexMesh(vertices, indices) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_convexMesh(ptr0, len0, ptr1, len1);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {Float32Array} vertices\n    * @param {Uint32Array} indices\n    * @param {number} borderRadius\n    * @returns {RawShape | undefined}\n    */\n    static roundConvexMesh(vertices, indices, borderRadius) {\n        const ptr0 = passArrayF32ToWasm0(vertices, wasm.__wbindgen_malloc);\n        const len0 = WASM_VECTOR_LEN;\n        const ptr1 = passArray32ToWasm0(indices, wasm.__wbindgen_malloc);\n        const len1 = WASM_VECTOR_LEN;\n        const ret = wasm.rawshape_roundConvexMesh(ptr0, len0, ptr1, len1, borderRadius);\n        return ret === 0 ? undefined : RawShape.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawVector} shapeVel1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {RawVector} shapeVel2\n    * @param {number} maxToi\n    * @param {boolean} stop_at_penetration\n    * @returns {RawShapeTOI | undefined}\n    */\n    castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, maxToi, stop_at_penetration) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shapeVel1, RawVector);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        _assertClass(shapeVel2, RawVector);\n        const ret = wasm.rawshape_castShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shapeVel1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, shapeVel2.__wbg_ptr, maxToi, stop_at_penetration);\n        return ret === 0 ? undefined : RawShapeTOI.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @returns {boolean}\n    */\n    intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_intersectsShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos1\n    * @param {RawRotation} shapeRot1\n    * @param {RawShape} shape2\n    * @param {RawVector} shapePos2\n    * @param {RawRotation} shapeRot2\n    * @param {number} prediction\n    * @returns {RawShapeContact | undefined}\n    */\n    contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n        _assertClass(shapePos1, RawVector);\n        _assertClass(shapeRot1, RawRotation);\n        _assertClass(shape2, RawShape);\n        _assertClass(shapePos2, RawVector);\n        _assertClass(shapeRot2, RawRotation);\n        const ret = wasm.rawshape_contactShape(this.__wbg_ptr, shapePos1.__wbg_ptr, shapeRot1.__wbg_ptr, shape2.__wbg_ptr, shapePos2.__wbg_ptr, shapeRot2.__wbg_ptr, prediction);\n        return ret === 0 ? undefined : RawShapeContact.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @returns {boolean}\n    */\n    containsPoint(shapePos, shapeRot, point) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_containsPoint(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, point.__wbg_ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} point\n    * @param {boolean} solid\n    * @returns {RawPointProjection}\n    */\n    projectPoint(shapePos, shapeRot, point, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(point, RawVector);\n        const ret = wasm.rawshape_projectPoint(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, point.__wbg_ptr, solid);\n        return RawPointProjection.__wrap(ret);\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @returns {boolean}\n    */\n    intersectsRay(shapePos, shapeRot, rayOrig, rayDir, maxToi) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_intersectsRay(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi);\n        return ret !== 0;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {number}\n    */\n    castRay(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRay(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret;\n    }\n    /**\n    * @param {RawVector} shapePos\n    * @param {RawRotation} shapeRot\n    * @param {RawVector} rayOrig\n    * @param {RawVector} rayDir\n    * @param {number} maxToi\n    * @param {boolean} solid\n    * @returns {RawRayIntersection | undefined}\n    */\n    castRayAndGetNormal(shapePos, shapeRot, rayOrig, rayDir, maxToi, solid) {\n        _assertClass(shapePos, RawVector);\n        _assertClass(shapeRot, RawRotation);\n        _assertClass(rayOrig, RawVector);\n        _assertClass(rayDir, RawVector);\n        const ret = wasm.rawshape_castRayAndGetNormal(this.__wbg_ptr, shapePos.__wbg_ptr, shapeRot.__wbg_ptr, rayOrig.__wbg_ptr, rayDir.__wbg_ptr, maxToi, solid);\n        return ret === 0 ? undefined : RawRayIntersection.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeColliderTOI {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeColliderTOI.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecollidertoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    colliderHandle() {\n        const ret = wasm.rawcharactercollision_handle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawraycolliderintersection_toi(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        const ret = wasm.rawraycolliderintersection_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        const ret = wasm.rawshapecollidertoi_witness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawcharactercollision_translationDeltaRemaining(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeContact {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeContact.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapecontact_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    distance() {\n        const ret = wasm.rawkinematiccharactercontroller_maxSlopeClimbAngle(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point1() {\n        const ret = wasm.rawpointprojection_point(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    point2() {\n        const ret = wasm.rawraycolliderintersection_normal(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawshapecollidertoi_witness2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawcharactercollision_translationDeltaApplied(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n*/\nexport class RawShapeTOI {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawShapeTOI.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawshapetoi_free(ptr);\n    }\n    /**\n    * @returns {number}\n    */\n    toi() {\n        const ret = wasm.rawrotation_x(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness1() {\n        const ret = wasm.rawshapetoi_witness1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    witness2() {\n        const ret = wasm.rawcontactforceevent_total_force(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal1() {\n        const ret = wasm.rawshapetoi_normal1(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * @returns {RawVector}\n    */\n    normal2() {\n        const ret = wasm.rawshapetoi_normal2(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n/**\n* A vector.\n*/\nexport class RawVector {\n\n    static __wrap(ptr) {\n        ptr = ptr >>> 0;\n        const obj = Object.create(RawVector.prototype);\n        obj.__wbg_ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.__wbg_ptr;\n        this.__wbg_ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_rawvector_free(ptr);\n    }\n    /**\n    * Creates a new vector filled with zeros.\n    * @returns {RawVector}\n    */\n    static zero() {\n        const ret = wasm.rawvector_zero();\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Creates a new 3D vector from its two components.\n    *\n    * # Parameters\n    * - `x`: the `x` component of this 3D vector.\n    * - `y`: the `y` component of this 3D vector.\n    * - `z`: the `z` component of this 3D vector.\n    * @param {number} x\n    * @param {number} y\n    * @param {number} z\n    */\n    constructor(x, y, z) {\n        const ret = wasm.rawvector_new(x, y, z);\n        this.__wbg_ptr = ret >>> 0;\n        return this;\n    }\n    /**\n    * The `x` component of this vector.\n    * @returns {number}\n    */\n    get x() {\n        const ret = wasm.rawrotation_x(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Sets the `x` component of this vector.\n    * @param {number} x\n    */\n    set x(x) {\n        wasm.rawvector_set_x(this.__wbg_ptr, x);\n    }\n    /**\n    * The `y` component of this vector.\n    * @returns {number}\n    */\n    get y() {\n        const ret = wasm.rawintegrationparameters_dt(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Sets the `y` component of this vector.\n    * @param {number} y\n    */\n    set y(y) {\n        wasm.rawintegrationparameters_set_dt(this.__wbg_ptr, y);\n    }\n    /**\n    * The `z` component of this vector.\n    * @returns {number}\n    */\n    get z() {\n        const ret = wasm.rawraycolliderintersection_toi(this.__wbg_ptr);\n        return ret;\n    }\n    /**\n    * Sets the `z` component of this vector.\n    * @param {number} z\n    */\n    set z(z) {\n        wasm.rawvector_set_z(this.__wbg_ptr, z);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{x, y, z}`.\n    *\n    * This will effectively return a copy of `this`. This method exist for completeness with the\n    * other swizzling functions.\n    * @returns {RawVector}\n    */\n    xyz() {\n        const ret = wasm.rawvector_xyz(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{y, x, z}`.\n    * @returns {RawVector}\n    */\n    yxz() {\n        const ret = wasm.rawvector_yxz(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{z, x, y}`.\n    * @returns {RawVector}\n    */\n    zxy() {\n        const ret = wasm.rawvector_zxy(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{x, z, y}`.\n    * @returns {RawVector}\n    */\n    xzy() {\n        const ret = wasm.rawvector_xzy(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{y, z, x}`.\n    * @returns {RawVector}\n    */\n    yzx() {\n        const ret = wasm.rawvector_yzx(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n    /**\n    * Create a new 3D vector from this vector with its components rearranged as `{z, y, x}`.\n    * @returns {RawVector}\n    */\n    zyx() {\n        const ret = wasm.rawvector_zyx(this.__wbg_ptr);\n        return RawVector.__wrap(ret);\n    }\n}\n\nexport function __wbindgen_number_new(arg0) {\n    const ret = arg0;\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_boolean_get(arg0) {\n    const v = getObject(arg0);\n    const ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n    return ret;\n};\n\nexport function __wbindgen_object_drop_ref(arg0) {\n    takeObject(arg0);\n};\n\nexport function __wbindgen_number_get(arg0, arg1) {\n    const obj = getObject(arg1);\n    const ret = typeof(obj) === 'number' ? obj : undefined;\n    getFloat64Memory0()[arg0 / 8 + 1] = isLikeNone(ret) ? 0 : ret;\n    getInt32Memory0()[arg0 / 4 + 0] = !isLikeNone(ret);\n};\n\nexport function __wbindgen_is_function(arg0) {\n    const ret = typeof(getObject(arg0)) === 'function';\n    return ret;\n};\n\nexport function __wbg_rawraycolliderintersection_new(arg0) {\n    const ret = RawRayColliderIntersection.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_rawcontactforceevent_new(arg0) {\n    const ret = RawContactForceEvent.__wrap(arg0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_call_01734de55d61e11d() { return handleError(function (arg0, arg1, arg2) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_4c92f6aec1e1d6e6() { return handleError(function (arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_call_776890ca77946e2f() { return handleError(function (arg0, arg1, arg2, arg3, arg4) {\n    const ret = getObject(arg0).call(getObject(arg1), getObject(arg2), getObject(arg3), getObject(arg4));\n    return addHeapObject(ret);\n}, arguments) };\n\nexport function __wbg_bind_60a9a80cada2f33c(arg0, arg1, arg2, arg3) {\n    const ret = getObject(arg0).bind(getObject(arg1), getObject(arg2), getObject(arg3));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_buffer_085ec1f694018c4f(arg0) {\n    const ret = getObject(arg0).buffer;\n    return addHeapObject(ret);\n};\n\nexport function __wbg_newwithbyteoffsetandlength_6da8e527659b86aa(arg0, arg1, arg2) {\n    const ret = new Uint8Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_new_8125e318e6245eed(arg0) {\n    const ret = new Uint8Array(getObject(arg0));\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_5cf90238115182c3(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_72e2208bbc0efc61(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithbyteoffsetandlength_69193e31c844b792(arg0, arg1, arg2) {\n    const ret = new Float32Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbg_set_6146c51d49a2c0df(arg0, arg1, arg2) {\n    getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n};\n\nexport function __wbg_length_d7327c75a759af37(arg0) {\n    const ret = getObject(arg0).length;\n    return ret;\n};\n\nexport function __wbg_newwithlength_68d29ab115d0099c(arg0) {\n    const ret = new Float32Array(arg0 >>> 0);\n    return addHeapObject(ret);\n};\n\nexport function __wbindgen_throw(arg0, arg1) {\n    throw new Error(getStringFromWasm0(arg0, arg1));\n};\n\nexport function __wbindgen_memory() {\n    const ret = wasm.memory;\n    return addHeapObject(ret);\n};\n\n","import { RawVector, RawRotation } from \"./raw\";\n/**\n * A 3D vector.\n */\nexport class Vector3 {\n    constructor(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n}\nexport class VectorOps {\n    static new(x, y, z) {\n        return new Vector3(x, y, z);\n    }\n    static intoRaw(v) {\n        return new RawVector(v.x, v.y, v.z);\n    }\n    static zeros() {\n        return VectorOps.new(0.0, 0.0, 0.0);\n    }\n    // FIXME: type ram: RawVector?\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        let res = VectorOps.new(raw.x, raw.y, raw.z);\n        raw.free();\n        return res;\n    }\n    static copy(out, input) {\n        out.x = input.x;\n        out.y = input.y;\n        out.z = input.z;\n    }\n}\n/**\n * A quaternion.\n */\nexport class Quaternion {\n    constructor(x, y, z, w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n}\nexport class RotationOps {\n    static identity() {\n        return new Quaternion(0.0, 0.0, 0.0, 1.0);\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        let res = new Quaternion(raw.x, raw.y, raw.z, raw.w);\n        raw.free();\n        return res;\n    }\n    static intoRaw(rot) {\n        return new RawRotation(rot.x, rot.y, rot.z, rot.w);\n    }\n    static copy(out, input) {\n        out.x = input.x;\n        out.y = input.y;\n        out.z = input.z;\n        out.w = input.w;\n    }\n}\n/**\n * A 3D symmetric-positive-definite matrix.\n */\nexport class SdpMatrix3 {\n    constructor(elements) {\n        this.elements = elements;\n    }\n    /**\n     * Matrix element at row 1, column 1.\n     */\n    get m11() {\n        return this.elements[0];\n    }\n    /**\n     * Matrix element at row 1, column 2.\n     */\n    get m12() {\n        return this.elements[1];\n    }\n    /**\n     * Matrix element at row 2, column 1.\n     */\n    get m21() {\n        return this.m12;\n    }\n    /**\n     * Matrix element at row 1, column 3.\n     */\n    get m13() {\n        return this.elements[2];\n    }\n    /**\n     * Matrix element at row 3, column 1.\n     */\n    get m31() {\n        return this.m13;\n    }\n    /**\n     * Matrix element at row 2, column 2.\n     */\n    get m22() {\n        return this.elements[3];\n    }\n    /**\n     * Matrix element at row 2, column 3.\n     */\n    get m23() {\n        return this.elements[4];\n    }\n    /**\n     * Matrix element at row 3, column 2.\n     */\n    get m32() {\n        return this.m23;\n    }\n    /**\n     * Matrix element at row 3, column 3.\n     */\n    get m33() {\n        return this.elements[5];\n    }\n}\nexport class SdpMatrix3Ops {\n    static fromRaw(raw) {\n        const sdpMatrix3 = new SdpMatrix3(raw.elements());\n        raw.free();\n        return sdpMatrix3;\n    }\n}\n// #endif\n//# sourceMappingURL=math.js.map","import { RotationOps, VectorOps } from \"../math\";\n// #if DIM3\nimport { SdpMatrix3Ops } from \"../math\";\n/**\n * The simulation status of a rigid-body.\n */\n// TODO: rename this to RigidBodyType\nexport var RigidBodyType;\n(function (RigidBodyType) {\n    /**\n     * A `RigidBodyType::Dynamic` body can be affected by all external forces.\n     */\n    RigidBodyType[RigidBodyType[\"Dynamic\"] = 0] = \"Dynamic\";\n    /**\n     * A `RigidBodyType::Fixed` body cannot be affected by external forces.\n     */\n    RigidBodyType[RigidBodyType[\"Fixed\"] = 1] = \"Fixed\";\n    /**\n     * A `RigidBodyType::KinematicPositionBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the position level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    RigidBodyType[RigidBodyType[\"KinematicPositionBased\"] = 2] = \"KinematicPositionBased\";\n    /**\n     * A `RigidBodyType::KinematicVelocityBased` body cannot be affected by any external forces but can be controlled\n     * by the user at the velocity level while keeping realistic one-way interaction with dynamic bodies.\n     *\n     * One-way interaction means that a kinematic body can push a dynamic body, but a kinematic body\n     * cannot be pushed by anything. In other words, the trajectory of a kinematic body can only be\n     * modified by the user and is independent from any contact or joint it is involved in.\n     */\n    RigidBodyType[RigidBodyType[\"KinematicVelocityBased\"] = 3] = \"KinematicVelocityBased\";\n})(RigidBodyType || (RigidBodyType = {}));\n/**\n * A rigid-body.\n */\nexport class RigidBody {\n    constructor(rawSet, colliderSet, handle) {\n        this.rawSet = rawSet;\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n    }\n    /** @internal */\n    finalizeDeserialization(colliderSet) {\n        this.colliderSet = colliderSet;\n    }\n    /**\n     * Checks if this rigid-body is still valid (i.e. that it has\n     * not been deleted from the rigid-body set yet.\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer translate due to forces and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    lockTranslations(locked, wakeUp) {\n        return this.rawSet.rbLockTranslations(this.handle, locked, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate.\n     *\n     * @param locked - If `true`, this rigid-body will no longer rotate due to torques and impulses.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    lockRotations(locked, wakeUp) {\n        return this.rawSet.rbLockRotations(this.handle, locked, wakeUp);\n    }\n    // #if DIM3\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer translate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    setEnabledTranslations(enableX, enableY, enableZ, wakeUp) {\n        return this.rawSet.rbSetEnabledTranslations(this.handle, enableX, enableY, enableZ, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to translate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer translate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer translate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     * @deprecated use `this.setEnabledTranslations` with the same arguments instead.\n     */\n    restrictTranslations(enableX, enableY, enableZ, wakeUp) {\n        this.setEnabledTranslations(enableX, enableY, enableZ, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     */\n    setEnabledRotations(enableX, enableY, enableZ, wakeUp) {\n        return this.rawSet.rbSetEnabledRotations(this.handle, enableX, enableY, enableZ, wakeUp);\n    }\n    /**\n     * Locks or unlocks the ability of this rigid-body to rotate along individual coordinate axes.\n     *\n     * @param enableX - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the X coordinate axis.\n     * @param enableY - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Y coordinate axis.\n     * @param enableZ - If `false`, this rigid-body will no longer rotate due to torques and impulses, along the Z coordinate axis.\n     * @param wakeUp - If `true`, this rigid-body will be automatically awaken if it is currently asleep.\n     * @deprecated use `this.setEnabledRotations` with the same arguments instead.\n     */\n    restrictRotations(enableX, enableY, enableZ, wakeUp) {\n        this.setEnabledRotations(enableX, enableY, enableZ, wakeUp);\n    }\n    // #endif\n    /**\n     * The dominance group, in [-127, +127] this rigid-body is part of.\n     */\n    dominanceGroup() {\n        return this.rawSet.rbDominanceGroup(this.handle);\n    }\n    /**\n     * Sets the dominance group of this rigid-body.\n     *\n     * @param group - The dominance group of this rigid-body. Must be a signed integer in the range [-127, +127].\n     */\n    setDominanceGroup(group) {\n        this.rawSet.rbSetDominanceGroup(this.handle, group);\n    }\n    /**\n     * The number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     */\n    additionalSolverIterations() {\n        return this.rawSet.rbAdditionalSolverIterations(this.handle);\n    }\n    /**\n     * Sets the number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     *\n     * Compared to increasing the global `World.numSolverIteration`, setting this\n     * value lets you increase accuracy on only a subset of the scene, resulting in reduced\n     * performance loss.\n     *\n     * @param iters - The new number of additional solver iterations (default: 0).\n     */\n    setAdditionalSolverIterations(iters) {\n        this.rawSet.rbSetAdditionalSolverIterations(this.handle, iters);\n    }\n    /**\n     * Enable or disable CCD (Continuous Collision Detection) for this rigid-body.\n     *\n     * @param enabled - If `true`, CCD will be enabled for this rigid-body.\n     */\n    enableCcd(enabled) {\n        this.rawSet.rbEnableCcd(this.handle, enabled);\n    }\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    translation() {\n        let res = this.rawSet.rbTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    rotation() {\n        let res = this.rawSet.rbRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n    /**\n     * The world-space next translation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicTranslation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    nextTranslation() {\n        let res = this.rawSet.rbNextTranslation(this.handle);\n        return VectorOps.fromRaw(res);\n    }\n    /**\n     * The world-space next orientation of this rigid-body.\n     *\n     * If this rigid-body is kinematic this value is set by the `setNextKinematicRotation`\n     * method and is used for estimating the kinematic body velocity at the next timestep.\n     * For non-kinematic bodies, this value is currently unspecified.\n     */\n    nextRotation() {\n        let res = this.rawSet.rbNextRotation(this.handle);\n        return RotationOps.fromRaw(res);\n    }\n    /**\n     * Sets the translation of this rigid-body.\n     *\n     * @param tra - The world-space position of the rigid-body.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     *                 wasn't moving before modifying its position.\n     */\n    setTranslation(tra, wakeUp) {\n        // #if DIM3\n        this.rawSet.rbSetTranslation(this.handle, tra.x, tra.y, tra.z, wakeUp);\n        // #endif\n    }\n    /**\n     * Sets the linear velocity of this rigid-body.\n     *\n     * @param vel - The linear velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setLinvel(vel, wakeUp) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetLinvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n    /**\n     * The scale factor applied to the gravity affecting\n     * this rigid-body.\n     */\n    gravityScale() {\n        return this.rawSet.rbGravityScale(this.handle);\n    }\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * this rigid-body.\n     *\n     * @param factor - The scale factor to set. A value of 0.0 means\n     *   that this rigid-body will on longer be affected by gravity.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setGravityScale(factor, wakeUp) {\n        this.rawSet.rbSetGravityScale(this.handle, factor, wakeUp);\n    }\n    // #if DIM3\n    /**\n     * Sets the rotation quaternion of this rigid-body.\n     *\n     * This does nothing if a zero quaternion is provided.\n     *\n     * @param rotation - The rotation to set.\n     * @param wakeUp - Forces the rigid-body to wake-up so it is properly affected by forces if it\n     * wasn't moving before modifying its position.\n     */\n    setRotation(rot, wakeUp) {\n        this.rawSet.rbSetRotation(this.handle, rot.x, rot.y, rot.z, rot.w, wakeUp);\n    }\n    /**\n     * Sets the angular velocity fo this rigid-body.\n     *\n     * @param vel - The angular velocity to set.\n     * @param wakeUp - Forces the rigid-body to wake-up if it was asleep.\n     */\n    setAngvel(vel, wakeUp) {\n        let rawVel = VectorOps.intoRaw(vel);\n        this.rawSet.rbSetAngvel(this.handle, rawVel, wakeUp);\n        rawVel.free();\n    }\n    // #endif\n    /**\n     * If this rigid body is kinematic, sets its future translation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setTranslation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param t - The kinematic translation to set.\n     */\n    setNextKinematicTranslation(t) {\n        // #if DIM3\n        this.rawSet.rbSetNextKinematicTranslation(this.handle, t.x, t.y, t.z);\n        // #endif\n    }\n    // #if DIM3\n    /**\n     * If this rigid body is kinematic, sets its future rotation after the next timestep integration.\n     *\n     * This should be used instead of `rigidBody.setRotation` to make the dynamic object\n     * interacting with this kinematic body behave as expected. Internally, Rapier will compute\n     * an artificial velocity for this rigid-body from its current position and its next kinematic\n     * position. This velocity will be used to compute forces on dynamic bodies interacting with\n     * this body.\n     *\n     * @param rot - The kinematic rotation to set.\n     */\n    setNextKinematicRotation(rot) {\n        this.rawSet.rbSetNextKinematicRotation(this.handle, rot.x, rot.y, rot.z, rot.w);\n    }\n    // #endif\n    /**\n     * The linear velocity of this rigid-body.\n     */\n    linvel() {\n        return VectorOps.fromRaw(this.rawSet.rbLinvel(this.handle));\n    }\n    // #if DIM3\n    /**\n     * The angular velocity of this rigid-body.\n     */\n    angvel() {\n        return VectorOps.fromRaw(this.rawSet.rbAngvel(this.handle));\n    }\n    // #endif\n    /**\n     * The mass of this rigid-body.\n     */\n    mass() {\n        return this.rawSet.rbMass(this.handle);\n    }\n    /**\n     * The inverse mass taking into account translation locking.\n     */\n    effectiveInvMass() {\n        return VectorOps.fromRaw(this.rawSet.rbEffectiveInvMass(this.handle));\n    }\n    /**\n     * The inverse of the mass of a rigid-body.\n     *\n     * If this is zero, the rigid-body is assumed to have infinite mass.\n     */\n    invMass() {\n        return this.rawSet.rbInvMass(this.handle);\n    }\n    /**\n     * The center of mass of a rigid-body expressed in its local-space.\n     */\n    localCom() {\n        return VectorOps.fromRaw(this.rawSet.rbLocalCom(this.handle));\n    }\n    /**\n     * The world-space center of mass of the rigid-body.\n     */\n    worldCom() {\n        return VectorOps.fromRaw(this.rawSet.rbWorldCom(this.handle));\n    }\n    // #if DIM3\n    /**\n     * The inverse of the principal angular inertia of the rigid-body.\n     *\n     * Components set to zero are assumed to be infinite along the corresponding principal axis.\n     */\n    invPrincipalInertiaSqrt() {\n        return VectorOps.fromRaw(this.rawSet.rbInvPrincipalInertiaSqrt(this.handle));\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * The angular inertia along the principal inertia axes of the rigid-body.\n     */\n    principalInertia() {\n        return VectorOps.fromRaw(this.rawSet.rbPrincipalInertia(this.handle));\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * The principal vectors of the local angular inertia tensor of the rigid-body.\n     */\n    principalInertiaLocalFrame() {\n        return RotationOps.fromRaw(this.rawSet.rbPrincipalInertiaLocalFrame(this.handle));\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * The square-root of the world-space inverse angular inertia tensor of the rigid-body,\n     * taking into account rotation locking.\n     */\n    effectiveWorldInvInertiaSqrt() {\n        return SdpMatrix3Ops.fromRaw(this.rawSet.rbEffectiveWorldInvInertiaSqrt(this.handle));\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * The effective world-space angular inertia (that takes the potential rotation locking into account) of\n     * this rigid-body.\n     */\n    effectiveAngularInertia() {\n        return SdpMatrix3Ops.fromRaw(this.rawSet.rbEffectiveAngularInertia(this.handle));\n    }\n    // #endif\n    /**\n     * Put this rigid body to sleep.\n     *\n     * A sleeping body no longer moves and is no longer simulated by the physics engine unless\n     * it is waken up. It can be woken manually with `this.wakeUp()` or automatically due to\n     * external forces like contacts.\n     */\n    sleep() {\n        this.rawSet.rbSleep(this.handle);\n    }\n    /**\n     * Wakes this rigid-body up.\n     *\n     * A dynamic rigid-body that does not move during several consecutive frames will\n     * be put to sleep by the physics engine, i.e., it will stop being simulated in order\n     * to avoid useless computations.\n     * This methods forces a sleeping rigid-body to wake-up. This is useful, e.g., before modifying\n     * the position of a dynamic body so that it is properly simulated afterwards.\n     */\n    wakeUp() {\n        this.rawSet.rbWakeUp(this.handle);\n    }\n    /**\n     * Is CCD enabled for this rigid-body?\n     */\n    isCcdEnabled() {\n        return this.rawSet.rbIsCcdEnabled(this.handle);\n    }\n    /**\n     * The number of colliders attached to this rigid-body.\n     */\n    numColliders() {\n        return this.rawSet.rbNumColliders(this.handle);\n    }\n    /**\n     * Retrieves the `i-th` collider attached to this rigid-body.\n     *\n     * @param i - The index of the collider to retrieve. Must be a number in `[0, this.numColliders()[`.\n     *         This index is **not** the same as the unique identifier of the collider.\n     */\n    collider(i) {\n        return this.colliderSet.get(this.rawSet.rbCollider(this.handle, i));\n    }\n    /**\n     * Sets whether this rigid-body is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this rigid-body and all its attached colliders.\n     */\n    setEnabled(enabled) {\n        this.rawSet.rbSetEnabled(this.handle, enabled);\n    }\n    /**\n     * Is this rigid-body enabled?\n     */\n    isEnabled() {\n        return this.rawSet.rbIsEnabled(this.handle);\n    }\n    /**\n     * The status of this rigid-body: static, dynamic, or kinematic.\n     */\n    bodyType() {\n        return this.rawSet.rbBodyType(this.handle);\n    }\n    /**\n     * Set a new status for this rigid-body: static, dynamic, or kinematic.\n     */\n    setBodyType(type, wakeUp) {\n        return this.rawSet.rbSetBodyType(this.handle, type, wakeUp);\n    }\n    /**\n     * Is this rigid-body sleeping?\n     */\n    isSleeping() {\n        return this.rawSet.rbIsSleeping(this.handle);\n    }\n    /**\n     * Is the velocity of this rigid-body not zero?\n     */\n    isMoving() {\n        return this.rawSet.rbIsMoving(this.handle);\n    }\n    /**\n     * Is this rigid-body static?\n     */\n    isFixed() {\n        return this.rawSet.rbIsFixed(this.handle);\n    }\n    /**\n     * Is this rigid-body kinematic?\n     */\n    isKinematic() {\n        return this.rawSet.rbIsKinematic(this.handle);\n    }\n    /**\n     * Is this rigid-body dynamic?\n     */\n    isDynamic() {\n        return this.rawSet.rbIsDynamic(this.handle);\n    }\n    /**\n     * The linear damping coefficient of this rigid-body.\n     */\n    linearDamping() {\n        return this.rawSet.rbLinearDamping(this.handle);\n    }\n    /**\n     * The angular damping coefficient of this rigid-body.\n     */\n    angularDamping() {\n        return this.rawSet.rbAngularDamping(this.handle);\n    }\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    setLinearDamping(factor) {\n        this.rawSet.rbSetLinearDamping(this.handle, factor);\n    }\n    /**\n     * Recompute the mass-properties of this rigid-bodies based on its currently attached colliders.\n     */\n    recomputeMassPropertiesFromColliders() {\n        this.rawSet.rbRecomputeMassPropertiesFromColliders(this.handle, this.colliderSet.raw);\n    }\n    /**\n     * Sets the rigid-body's additional mass.\n     *\n     * The total angular inertia of the rigid-body will be scaled automatically based on this additional mass. If this\n     * scaling effect isnt desired, use Self::additional_mass_properties instead of this method.\n     *\n     * This is only the \"additional\" mass because the total mass of the rigid-body is equal to the sum of this\n     * additional mass and the mass computed from the colliders (with non-zero densities) attached to this rigid-body.\n     *\n     * That total mass (which includes the attached colliders contributions) will be updated at the name physics step,\n     * or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous additional mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc::setAdditionalMass`, or\n     * `RigidBodyDesc.setAdditionalMassfProperties` for this rigid-body.\n     *\n     * @param mass - The additional mass to set.\n     * @param wakeUp - If `true` then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    setAdditionalMass(mass, wakeUp) {\n        this.rawSet.rbSetAdditionalMass(this.handle, mass, wakeUp);\n    }\n    // #if DIM3\n    /**\n     * Sets the rigid-body's additional mass-properties.\n     *\n     * This is only the \"additional\" mass-properties because the total mass-properties of the rigid-body is equal to the\n     * sum of this additional mass-properties and the mass computed from the colliders (with non-zero densities) attached\n     * to this rigid-body.\n     *\n     * That total mass-properties (which include the attached colliders contributions) will be updated at the name\n     * physics step, or can be updated manually with `this.recomputeMassPropertiesFromColliders`.\n     *\n     * This will override any previous mass-properties set by `this.setAdditionalMass`,\n     * `this.setAdditionalMassProperties`, `RigidBodyDesc.setAdditionalMass`, or `RigidBodyDesc.setAdditionalMassProperties`\n     * for this rigid-body.\n     *\n     * If `wake_up` is true then the rigid-body will be woken up if it was put to sleep because it did not move for a while.\n     */\n    setAdditionalMassProperties(mass, centerOfMass, principalAngularInertia, angularInertiaLocalFrame, wakeUp) {\n        let rawCom = VectorOps.intoRaw(centerOfMass);\n        let rawPrincipalInertia = VectorOps.intoRaw(principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(angularInertiaLocalFrame);\n        this.rawSet.rbSetAdditionalMassProperties(this.handle, mass, rawCom, rawPrincipalInertia, rawInertiaFrame, wakeUp);\n        rawCom.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n    }\n    // #endif\n    /**\n     * Sets the linear damping factor applied to this rigid-body.\n     *\n     * @param factor - The damping factor to set.\n     */\n    setAngularDamping(factor) {\n        this.rawSet.rbSetAngularDamping(this.handle, factor);\n    }\n    /**\n     * Resets to zero the user forces (but not torques) applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    resetForces(wakeUp) {\n        this.rawSet.rbResetForces(this.handle, wakeUp);\n    }\n    /**\n     * Resets to zero the user torques applied to this rigid-body.\n     *\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    resetTorques(wakeUp) {\n        this.rawSet.rbResetTorques(this.handle, wakeUp);\n    }\n    /**\n     * Adds a force at the center-of-mass of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addForce(force, wakeUp) {\n        const rawForce = VectorOps.intoRaw(force);\n        this.rawSet.rbAddForce(this.handle, rawForce, wakeUp);\n        rawForce.free();\n    }\n    /**\n     * Applies an impulse at the center-of-mass of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyImpulse(impulse, wakeUp) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        this.rawSet.rbApplyImpulse(this.handle, rawImpulse, wakeUp);\n        rawImpulse.free();\n    }\n    // #if DIM3\n    /**\n     * Adds a torque at the center-of-mass of this rigid-body.\n     *\n     * @param torque - the world-space torque to add to the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addTorque(torque, wakeUp) {\n        const rawTorque = VectorOps.intoRaw(torque);\n        this.rawSet.rbAddTorque(this.handle, rawTorque, wakeUp);\n        rawTorque.free();\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * Applies an impulsive torque at the center-of-mass of this rigid-body.\n     *\n     * @param torqueImpulse - the world-space torque impulse to apply on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyTorqueImpulse(torqueImpulse, wakeUp) {\n        const rawTorqueImpulse = VectorOps.intoRaw(torqueImpulse);\n        this.rawSet.rbApplyTorqueImpulse(this.handle, rawTorqueImpulse, wakeUp);\n        rawTorqueImpulse.free();\n    }\n    // #endif\n    /**\n     * Adds a force at the given world-space point of this rigid-body.\n     *\n     * @param force - the world-space force to add to the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    addForceAtPoint(force, point, wakeUp) {\n        const rawForce = VectorOps.intoRaw(force);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbAddForceAtPoint(this.handle, rawForce, rawPoint, wakeUp);\n        rawForce.free();\n        rawPoint.free();\n    }\n    /**\n     * Applies an impulse at the given world-space point of this rigid-body.\n     *\n     * @param impulse - the world-space impulse to apply on the rigid-body.\n     * @param point - the world-space point where the impulse is to be applied on the rigid-body.\n     * @param wakeUp - should the rigid-body be automatically woken-up?\n     */\n    applyImpulseAtPoint(impulse, point, wakeUp) {\n        const rawImpulse = VectorOps.intoRaw(impulse);\n        const rawPoint = VectorOps.intoRaw(point);\n        this.rawSet.rbApplyImpulseAtPoint(this.handle, rawImpulse, rawPoint, wakeUp);\n        rawImpulse.free();\n        rawPoint.free();\n    }\n}\nexport class RigidBodyDesc {\n    constructor(status) {\n        this.enabled = true;\n        this.status = status;\n        this.translation = VectorOps.zeros();\n        this.rotation = RotationOps.identity();\n        this.gravityScale = 1.0;\n        this.linvel = VectorOps.zeros();\n        this.mass = 0.0;\n        this.massOnly = false;\n        this.centerOfMass = VectorOps.zeros();\n        this.translationsEnabledX = true;\n        this.translationsEnabledY = true;\n        // #if DIM3\n        this.angvel = VectorOps.zeros();\n        this.principalAngularInertia = VectorOps.zeros();\n        this.angularInertiaLocalFrame = RotationOps.identity();\n        this.translationsEnabledZ = true;\n        this.rotationsEnabledX = true;\n        this.rotationsEnabledY = true;\n        this.rotationsEnabledZ = true;\n        // #endif\n        this.linearDamping = 0.0;\n        this.angularDamping = 0.0;\n        this.canSleep = true;\n        this.sleeping = false;\n        this.ccdEnabled = false;\n        this.dominanceGroup = 0;\n        this.additionalSolverIterations = 0;\n    }\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     */\n    static dynamic() {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     */\n    static kinematicPositionBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     */\n    static kinematicVelocityBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     */\n    static fixed() {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n    /**\n     * A rigid-body descriptor used to build a dynamic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.dynamic()`.\n     */\n    static newDynamic() {\n        return new RigidBodyDesc(RigidBodyType.Dynamic);\n    }\n    /**\n     * A rigid-body descriptor used to build a position-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicPositionBased()`.\n     */\n    static newKinematicPositionBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicPositionBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a velocity-based kinematic rigid-body.\n     *\n     * @deprecated The method has been renamed to `.kinematicVelocityBased()`.\n     */\n    static newKinematicVelocityBased() {\n        return new RigidBodyDesc(RigidBodyType.KinematicVelocityBased);\n    }\n    /**\n     * A rigid-body descriptor used to build a fixed rigid-body.\n     *\n     * @deprecated The method has been renamed to `.fixed()`.\n     */\n    static newStatic() {\n        return new RigidBodyDesc(RigidBodyType.Fixed);\n    }\n    setDominanceGroup(group) {\n        this.dominanceGroup = group;\n        return this;\n    }\n    /**\n     * Sets the number of additional solver iterations that will be run for this\n     * rigid-body and everything that interacts with it directly or indirectly\n     * through contacts or joints.\n     *\n     * Compared to increasing the global `World.numSolverIteration`, setting this\n     * value lets you increase accuracy on only a subset of the scene, resulting in reduced\n     * performance loss.\n     *\n     * @param iters - The new number of additional solver iterations (default: 0).\n     */\n    setAdditionalSolverIterations(iters) {\n        this.additionalSolverIterations = iters;\n        return this;\n    }\n    /**\n     * Sets whether the created rigid-body will be enabled or disabled.\n     * @param enabled  If set to `false` the rigid-body will be disabled at creation.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n        return this;\n    }\n    // #if DIM3\n    /**\n     * Sets the initial translation of the rigid-body to create.\n     *\n     * @param tra - The translation to set.\n     */\n    setTranslation(x, y, z) {\n        if (typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\")\n            throw TypeError(\"The translation components must be numbers.\");\n        this.translation = { x: x, y: y, z: z };\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the initial rotation of the rigid-body to create.\n     *\n     * @param rot - The rotation to set.\n     */\n    setRotation(rot) {\n        // #if DIM3\n        RotationOps.copy(this.rotation, rot);\n        // #endif\n        return this;\n    }\n    /**\n     * Sets the scale factor applied to the gravity affecting\n     * the rigid-body being built.\n     *\n     * @param scale - The scale factor. Set this to `0.0` if the rigid-body\n     *   needs to ignore gravity.\n     */\n    setGravityScale(scale) {\n        this.gravityScale = scale;\n        return this;\n    }\n    /**\n     * Sets the initial mass of the rigid-body being built, before adding colliders' contributions.\n     *\n     * @param mass  The initial mass of the rigid-body to create.\n     */\n    setAdditionalMass(mass) {\n        this.mass = mass;\n        this.massOnly = true;\n        return this;\n    }\n    // #if DIM3\n    /**\n     * Sets the initial linear velocity of the rigid-body to create.\n     *\n     * @param x - The linear velocity to set along the `x` axis.\n     * @param y - The linear velocity to set along the `y` axis.\n     * @param z - The linear velocity to set along the `z` axis.\n     */\n    setLinvel(x, y, z) {\n        if (typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\")\n            throw TypeError(\"The linvel components must be numbers.\");\n        this.linvel = { x: x, y: y, z: z };\n        return this;\n    }\n    /**\n     * Sets the initial angular velocity of the rigid-body to create.\n     *\n     * @param vel - The angular velocity to set.\n     */\n    setAngvel(vel) {\n        VectorOps.copy(this.angvel, vel);\n        return this;\n    }\n    /**\n     * Sets the mass properties of the rigid-body being built.\n     *\n     * Note that the final mass properties of the rigid-bodies depends\n     * on the initial mass-properties of the rigid-body (set by this method)\n     * to which is added the contributions of all the colliders with non-zero density\n     * attached to this rigid-body.\n     *\n     * Therefore, if you want your provided mass properties to be the final\n     * mass properties of your rigid-body, don't attach colliders to it, or\n     * only attach colliders with densities equal to zero.\n     *\n     * @param mass  The initial mass of the rigid-body to create.\n     * @param centerOfMass  The initial center-of-mass of the rigid-body to create.\n     * @param principalAngularInertia  The initial principal angular inertia of the rigid-body to create.\n     *                                  These are the eigenvalues of the angular inertia matrix.\n     * @param angularInertiaLocalFrame  The initial local angular inertia frame of the rigid-body to create.\n     *                                   These are the eigenvectors of the angular inertia matrix.\n     */\n    setAdditionalMassProperties(mass, centerOfMass, principalAngularInertia, angularInertiaLocalFrame) {\n        this.mass = mass;\n        VectorOps.copy(this.centerOfMass, centerOfMass);\n        VectorOps.copy(this.principalAngularInertia, principalAngularInertia);\n        RotationOps.copy(this.angularInertiaLocalFrame, angularInertiaLocalFrame);\n        this.massOnly = false;\n        return this;\n    }\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @param translationsEnabledZ - Are translations along the Z axis enabled?\n     */\n    enabledTranslations(translationsEnabledX, translationsEnabledY, translationsEnabledZ) {\n        this.translationsEnabledX = translationsEnabledX;\n        this.translationsEnabledY = translationsEnabledY;\n        this.translationsEnabledZ = translationsEnabledZ;\n        return this;\n    }\n    /**\n     * Allow translation of this rigid-body only along specific axes.\n     * @param translationsEnabledX - Are translations along the X axis enabled?\n     * @param translationsEnabledY - Are translations along the y axis enabled?\n     * @param translationsEnabledZ - Are translations along the Z axis enabled?\n     * @deprecated use `this.enabledTranslations` with the same arguments instead.\n     */\n    restrictTranslations(translationsEnabledX, translationsEnabledY, translationsEnabledZ) {\n        return this.enabledTranslations(translationsEnabledX, translationsEnabledY, translationsEnabledZ);\n    }\n    /**\n     * Locks all translations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    lockTranslations() {\n        return this.enabledTranslations(false, false, false);\n    }\n    /**\n     * Allow rotation of this rigid-body only along specific axes.\n     * @param rotationsEnabledX - Are rotations along the X axis enabled?\n     * @param rotationsEnabledY - Are rotations along the y axis enabled?\n     * @param rotationsEnabledZ - Are rotations along the Z axis enabled?\n     */\n    enabledRotations(rotationsEnabledX, rotationsEnabledY, rotationsEnabledZ) {\n        this.rotationsEnabledX = rotationsEnabledX;\n        this.rotationsEnabledY = rotationsEnabledY;\n        this.rotationsEnabledZ = rotationsEnabledZ;\n        return this;\n    }\n    /**\n     * Allow rotation of this rigid-body only along specific axes.\n     * @param rotationsEnabledX - Are rotations along the X axis enabled?\n     * @param rotationsEnabledY - Are rotations along the y axis enabled?\n     * @param rotationsEnabledZ - Are rotations along the Z axis enabled?\n     * @deprecated use `this.enabledRotations` with the same arguments instead.\n     */\n    restrictRotations(rotationsEnabledX, rotationsEnabledY, rotationsEnabledZ) {\n        return this.enabledRotations(rotationsEnabledX, rotationsEnabledY, rotationsEnabledZ);\n    }\n    /**\n     * Locks all rotations that would have resulted from forces on\n     * the created rigid-body.\n     */\n    lockRotations() {\n        return this.restrictRotations(false, false, false);\n    }\n    // #endif\n    /**\n     * Sets the linear damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the translational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the translational slowdown will be.\n     */\n    setLinearDamping(damping) {\n        this.linearDamping = damping;\n        return this;\n    }\n    /**\n     * Sets the angular damping of the rigid-body to create.\n     *\n     * This will progressively slowdown the rotational movement of the rigid-body.\n     *\n     * @param damping - The angular damping coefficient. Should be >= 0. The higher this\n     *                  value is, the stronger the rotational slowdown will be.\n     */\n    setAngularDamping(damping) {\n        this.angularDamping = damping;\n        return this;\n    }\n    /**\n     * Sets whether or not the rigid-body to create can sleep.\n     *\n     * @param can - true if the rigid-body can sleep, false if it can't.\n     */\n    setCanSleep(can) {\n        this.canSleep = can;\n        return this;\n    }\n    /**\n     * Sets whether or not the rigid-body is to be created asleep.\n     *\n     * @param can - true if the rigid-body should be in sleep, default false.\n     */\n    setSleeping(sleeping) {\n        this.sleeping = sleeping;\n        return this;\n    }\n    /**\n     * Sets whether Continuous Collision Detection (CCD) is enabled for this rigid-body.\n     *\n     * @param enabled - true if the rigid-body has CCD enabled.\n     */\n    setCcdEnabled(enabled) {\n        this.ccdEnabled = enabled;\n        return this;\n    }\n    /**\n     * Sets the user-defined object of this rigid-body.\n     *\n     * @param userData - The user-defined object to set.\n     */\n    setUserData(data) {\n        this.userData = data;\n        return this;\n    }\n}\n//# sourceMappingURL=rigid_body.js.map","import { VectorOps, RotationOps } from \"../math\";\nimport { RawGenericJoint, RawJointAxis, RawJointType, } from \"../raw\";\n/**\n * An enum grouping all possible types of joints:\n *\n * - `Revolute`: A revolute joint that removes all degrees of freedom between the affected\n *               bodies except for the rotation along one axis.\n * - `Fixed`: A fixed joint that removes all relative degrees of freedom between the affected bodies.\n * - `Prismatic`: A prismatic joint that removes all degrees of freedom between the affected\n *                bodies except for the translation along one axis.\n * - `Spherical`: (3D only) A spherical joint that removes all relative linear degrees of freedom between the affected bodies.\n * - `Generic`: (3D only) A joint with customizable degrees of freedom, allowing any of the 6 axes to be locked.\n */\nexport var JointType;\n(function (JointType) {\n    JointType[JointType[\"Revolute\"] = 0] = \"Revolute\";\n    JointType[JointType[\"Fixed\"] = 1] = \"Fixed\";\n    JointType[JointType[\"Prismatic\"] = 2] = \"Prismatic\";\n    JointType[JointType[\"Rope\"] = 3] = \"Rope\";\n    JointType[JointType[\"Spring\"] = 4] = \"Spring\";\n    // #if DIM3\n    JointType[JointType[\"Spherical\"] = 5] = \"Spherical\";\n    JointType[JointType[\"Generic\"] = 6] = \"Generic\";\n    // #endif\n})(JointType || (JointType = {}));\nexport var MotorModel;\n(function (MotorModel) {\n    MotorModel[MotorModel[\"AccelerationBased\"] = 0] = \"AccelerationBased\";\n    MotorModel[MotorModel[\"ForceBased\"] = 1] = \"ForceBased\";\n})(MotorModel || (MotorModel = {}));\n/**\n * An enum representing the possible joint axes of a generic joint.\n * They can be ORed together, like:\n * JointAxesMask.X || JointAxesMask.Y\n * to get a joint that is only free in the X and Y translational (positional) axes.\n *\n * Possible free axes are:\n *\n * - `X`: X translation axis\n * - `Y`: Y translation axis\n * - `Z`: Z translation axis\n * - `AngX`: X angular rotation axis\n * - `AngY`: Y angular rotations axis\n * - `AngZ`: Z angular rotation axis\n */\nexport var JointAxesMask;\n(function (JointAxesMask) {\n    JointAxesMask[JointAxesMask[\"X\"] = 1] = \"X\";\n    JointAxesMask[JointAxesMask[\"Y\"] = 2] = \"Y\";\n    JointAxesMask[JointAxesMask[\"Z\"] = 4] = \"Z\";\n    JointAxesMask[JointAxesMask[\"AngX\"] = 8] = \"AngX\";\n    JointAxesMask[JointAxesMask[\"AngY\"] = 16] = \"AngY\";\n    JointAxesMask[JointAxesMask[\"AngZ\"] = 32] = \"AngZ\";\n})(JointAxesMask || (JointAxesMask = {}));\nexport class ImpulseJoint {\n    constructor(rawSet, bodySet, handle) {\n        this.rawSet = rawSet;\n        this.bodySet = bodySet;\n        this.handle = handle;\n    }\n    static newTyped(rawSet, bodySet, handle) {\n        switch (rawSet.jointType(handle)) {\n            case RawJointType.Revolute:\n                return new RevoluteImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Prismatic:\n                return new PrismaticImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Fixed:\n                return new FixedImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Spring:\n                return new SpringImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Rope:\n                return new RopeImpulseJoint(rawSet, bodySet, handle);\n            // #if DIM3\n            case RawJointType.Spherical:\n                return new SphericalImpulseJoint(rawSet, bodySet, handle);\n            case RawJointType.Generic:\n                return new GenericImpulseJoint(rawSet, bodySet, handle);\n            // #endif\n            default:\n                return new ImpulseJoint(rawSet, bodySet, handle);\n        }\n    }\n    /** @internal */\n    finalizeDeserialization(bodySet) {\n        this.bodySet = bodySet;\n    }\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n    /**\n     * The first rigid-body this joint it attached to.\n     */\n    body1() {\n        return this.bodySet.get(this.rawSet.jointBodyHandle1(this.handle));\n    }\n    /**\n     * The second rigid-body this joint is attached to.\n     */\n    body2() {\n        return this.bodySet.get(this.rawSet.jointBodyHandle2(this.handle));\n    }\n    /**\n     * The type of this joint given as a string.\n     */\n    type() {\n        return this.rawSet.jointType(this.handle);\n    }\n    // #if DIM3\n    /**\n     * The rotation quaternion that aligns this joint's first local axis to the `x` axis.\n     */\n    frameX1() {\n        return RotationOps.fromRaw(this.rawSet.jointFrameX1(this.handle));\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * The rotation matrix that aligns this joint's second local axis to the `x` axis.\n     */\n    frameX2() {\n        return RotationOps.fromRaw(this.rawSet.jointFrameX2(this.handle));\n    }\n    // #endif\n    /**\n     * The position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    anchor1() {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    }\n    /**\n     * The position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    anchor2() {\n        return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    }\n    /**\n     * Sets the position of the first anchor of this joint.\n     *\n     * The first anchor gives the position of the application point on the\n     * local frame of the first rigid-body it is attached to.\n     */\n    setAnchor1(newPos) {\n        const rawPoint = VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor1(this.handle, rawPoint);\n        rawPoint.free();\n    }\n    /**\n     * Sets the position of the second anchor of this joint.\n     *\n     * The second anchor gives the position of the application point on the\n     * local frame of the second rigid-body it is attached to.\n     */\n    setAnchor2(newPos) {\n        const rawPoint = VectorOps.intoRaw(newPos);\n        this.rawSet.jointSetAnchor2(this.handle, rawPoint);\n        rawPoint.free();\n    }\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    setContactsEnabled(enabled) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    contactsEnabled() {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\nexport class UnitImpulseJoint extends ImpulseJoint {\n    /**\n     * Are the limits enabled for this joint?\n     */\n    limitsEnabled() {\n        return this.rawSet.jointLimitsEnabled(this.handle, this.rawAxis());\n    }\n    /**\n     * The min limit of this joint.\n     */\n    limitsMin() {\n        return this.rawSet.jointLimitsMin(this.handle, this.rawAxis());\n    }\n    /**\n     * The max limit of this joint.\n     */\n    limitsMax() {\n        return this.rawSet.jointLimitsMax(this.handle, this.rawAxis());\n    }\n    /**\n     * Sets the limits of this joint.\n     *\n     * @param min - The minimum bound of this joints free coordinate.\n     * @param max - The maximum bound of this joints free coordinate.\n     */\n    setLimits(min, max) {\n        this.rawSet.jointSetLimits(this.handle, this.rawAxis(), min, max);\n    }\n    configureMotorModel(model) {\n        this.rawSet.jointConfigureMotorModel(this.handle, this.rawAxis(), model);\n    }\n    configureMotorVelocity(targetVel, factor) {\n        this.rawSet.jointConfigureMotorVelocity(this.handle, this.rawAxis(), targetVel, factor);\n    }\n    configureMotorPosition(targetPos, stiffness, damping) {\n        this.rawSet.jointConfigureMotorPosition(this.handle, this.rawAxis(), targetPos, stiffness, damping);\n    }\n    configureMotor(targetPos, targetVel, stiffness, damping) {\n        this.rawSet.jointConfigureMotor(this.handle, this.rawAxis(), targetPos, targetVel, stiffness, damping);\n    }\n}\nexport class FixedImpulseJoint extends ImpulseJoint {\n}\nexport class RopeImpulseJoint extends ImpulseJoint {\n}\nexport class SpringImpulseJoint extends ImpulseJoint {\n}\nexport class PrismaticImpulseJoint extends UnitImpulseJoint {\n    rawAxis() {\n        return RawJointAxis.X;\n    }\n}\nexport class RevoluteImpulseJoint extends UnitImpulseJoint {\n    rawAxis() {\n        return RawJointAxis.AngX;\n    }\n}\n// #if DIM3\nexport class GenericImpulseJoint extends ImpulseJoint {\n}\nexport class SphericalImpulseJoint extends ImpulseJoint {\n}\n// #endif\nexport class JointData {\n    constructor() { }\n    /**\n     * Creates a new joint descriptor that builds a Fixed joint.\n     *\n     * A fixed joint removes all the degrees of freedom between the affected bodies, ensuring their\n     * anchor and local frames coincide in world-space.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame1 - The reference orientation of the joint wrt. the first rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param frame2 - The reference orientation of the joint wrt. the second rigid-body.\n     */\n    static fixed(anchor1, frame1, anchor2, frame2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.frame1 = frame1;\n        res.frame2 = frame2;\n        res.jointType = JointType.Fixed;\n        return res;\n    }\n    static spring(rest_length, stiffness, damping, anchor1, anchor2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.length = rest_length;\n        res.stiffness = stiffness;\n        res.damping = damping;\n        res.jointType = JointType.Spring;\n        return res;\n    }\n    static rope(length, anchor1, anchor2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.length = length;\n        res.jointType = JointType.Rope;\n        return res;\n    }\n    // #if DIM3\n    /**\n     * Create a new joint descriptor that builds generic joints.\n     *\n     * A generic joint allows customizing its degrees of freedom\n     * by supplying a mask of the joint axes that should remain locked.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - The X axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     * @param axesMask - Mask representing the locked axes of the joint. You can use logical OR to select these from\n     *                   the JointAxesMask enum. For example, passing (JointAxesMask.AngX || JointAxesMask.AngY) will\n     *                   create a joint locked in the X and Y rotational axes.\n     */\n    static generic(anchor1, anchor2, axis, axesMask) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.axesMask = axesMask;\n        res.jointType = JointType.Generic;\n        return res;\n    }\n    /**\n     * Create a new joint descriptor that builds spherical joints.\n     *\n     * A spherical joint allows three relative rotational degrees of freedom\n     * by preventing any relative translation between the anchors of the\n     * two attached rigid-bodies.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     */\n    static spherical(anchor1, anchor2) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.jointType = JointType.Spherical;\n        return res;\n    }\n    /**\n     * Creates a new joint descriptor that builds a Prismatic joint.\n     *\n     * A prismatic joint removes all the degrees of freedom between the\n     * affected bodies, except for the translation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    static prismatic(anchor1, anchor2, axis) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Prismatic;\n        return res;\n    }\n    /**\n     * Create a new joint descriptor that builds Revolute joints.\n     *\n     * A revolute joint removes all degrees of freedom between the affected\n     * bodies except for the rotation along one axis.\n     *\n     * @param anchor1 - Point where the joint is attached on the first rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param anchor2 - Point where the joint is attached on the second rigid-body affected by this joint. Expressed in the\n     *                  local-space of the rigid-body.\n     * @param axis - Axis of the joint, expressed in the local-space of the rigid-bodies it is attached to.\n     */\n    static revolute(anchor1, anchor2, axis) {\n        let res = new JointData();\n        res.anchor1 = anchor1;\n        res.anchor2 = anchor2;\n        res.axis = axis;\n        res.jointType = JointType.Revolute;\n        return res;\n    }\n    // #endif\n    intoRaw() {\n        let rawA1 = VectorOps.intoRaw(this.anchor1);\n        let rawA2 = VectorOps.intoRaw(this.anchor2);\n        let rawAx;\n        let result;\n        let limitsEnabled = false;\n        let limitsMin = 0.0;\n        let limitsMax = 0.0;\n        switch (this.jointType) {\n            case JointType.Fixed:\n                let rawFra1 = RotationOps.intoRaw(this.frame1);\n                let rawFra2 = RotationOps.intoRaw(this.frame2);\n                result = RawGenericJoint.fixed(rawA1, rawFra1, rawA2, rawFra2);\n                rawFra1.free();\n                rawFra2.free();\n                break;\n            case JointType.Spring:\n                result = RawGenericJoint.spring(this.length, this.stiffness, this.damping, rawA1, rawA2);\n                break;\n            case JointType.Rope:\n                result = RawGenericJoint.rope(this.length, rawA1, rawA2);\n                break;\n            case JointType.Prismatic:\n                rawAx = VectorOps.intoRaw(this.axis);\n                if (!!this.limitsEnabled) {\n                    limitsEnabled = true;\n                    limitsMin = this.limits[0];\n                    limitsMax = this.limits[1];\n                }\n                // #if DIM3\n                result = RawGenericJoint.prismatic(rawA1, rawA2, rawAx, limitsEnabled, limitsMin, limitsMax);\n                // #endif\n                rawAx.free();\n                break;\n            // #if DIM3\n            case JointType.Generic:\n                rawAx = VectorOps.intoRaw(this.axis);\n                // implicit type cast: axesMask is a JointAxesMask bitflag enum,\n                // we're treating it as a u8 on the Rust side\n                let rawAxesMask = this.axesMask;\n                result = RawGenericJoint.generic(rawA1, rawA2, rawAx, rawAxesMask);\n                break;\n            case JointType.Spherical:\n                result = RawGenericJoint.spherical(rawA1, rawA2);\n                break;\n            case JointType.Revolute:\n                rawAx = VectorOps.intoRaw(this.axis);\n                result = RawGenericJoint.revolute(rawA1, rawA2, rawAx);\n                rawAx.free();\n                break;\n            // #endif\n        }\n        rawA1.free();\n        rawA2.free();\n        return result;\n    }\n}\n//# sourceMappingURL=impulse_joint.js.map","/**\n * A rule applied to combine coefficients.\n *\n * Use this when configuring the `ColliderDesc` to specify\n * how friction and restitution coefficient should be combined\n * in a contact.\n */\nexport var CoefficientCombineRule;\n(function (CoefficientCombineRule) {\n    CoefficientCombineRule[CoefficientCombineRule[\"Average\"] = 0] = \"Average\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Min\"] = 1] = \"Min\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Multiply\"] = 2] = \"Multiply\";\n    CoefficientCombineRule[CoefficientCombineRule[\"Max\"] = 3] = \"Max\";\n})(CoefficientCombineRule || (CoefficientCombineRule = {}));\n//# sourceMappingURL=coefficient_combine_rule.js.map","// #if DIM3\nexport var FeatureType;\n(function (FeatureType) {\n    FeatureType[FeatureType[\"Vertex\"] = 0] = \"Vertex\";\n    FeatureType[FeatureType[\"Edge\"] = 1] = \"Edge\";\n    FeatureType[FeatureType[\"Face\"] = 2] = \"Face\";\n    FeatureType[FeatureType[\"Unknown\"] = 3] = \"Unknown\";\n})(FeatureType || (FeatureType = {}));\n// #endif\n//# sourceMappingURL=feature.js.map","import { VectorOps, RotationOps } from \"../math\";\nimport { RawShape, RawShapeType } from \"../raw\";\nimport { ShapeContact } from \"./contact\";\nimport { PointProjection } from \"./point\";\nimport { RayIntersection } from \"./ray\";\nimport { ShapeTOI } from \"./toi\";\nexport class Shape {\n    /**\n     * instant mode without cache\n     */\n    static fromRaw(rawSet, handle) {\n        const rawType = rawSet.coShapeType(handle);\n        let extents;\n        let borderRadius;\n        let vs;\n        let indices;\n        let halfHeight;\n        let radius;\n        let normal;\n        switch (rawType) {\n            case RawShapeType.Ball:\n                return new Ball(rawSet.coRadius(handle));\n            case RawShapeType.Cuboid:\n                extents = rawSet.coHalfExtents(handle);\n                // #if DIM3\n                return new Cuboid(extents.x, extents.y, extents.z);\n            // #endif\n            case RawShapeType.RoundCuboid:\n                extents = rawSet.coHalfExtents(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                // #if DIM3\n                return new RoundCuboid(extents.x, extents.y, extents.z, borderRadius);\n            // #endif\n            case RawShapeType.Capsule:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Capsule(halfHeight, radius);\n            case RawShapeType.Segment:\n                vs = rawSet.coVertices(handle);\n                // #if DIM3\n                return new Segment(VectorOps.new(vs[0], vs[1], vs[2]), VectorOps.new(vs[3], vs[4], vs[5]));\n            // #endif\n            case RawShapeType.Polyline:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new Polyline(vs, indices);\n            case RawShapeType.Triangle:\n                vs = rawSet.coVertices(handle);\n                // #if DIM3\n                return new Triangle(VectorOps.new(vs[0], vs[1], vs[2]), VectorOps.new(vs[3], vs[4], vs[5]), VectorOps.new(vs[6], vs[7], vs[8]));\n            // #endif\n            case RawShapeType.RoundTriangle:\n                vs = rawSet.coVertices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                // #if DIM3\n                return new RoundTriangle(VectorOps.new(vs[0], vs[1], vs[2]), VectorOps.new(vs[3], vs[4], vs[5]), VectorOps.new(vs[6], vs[7], vs[8]), borderRadius);\n            // #endif\n            case RawShapeType.HalfSpace:\n                normal = VectorOps.fromRaw(rawSet.coHalfspaceNormal(handle));\n                return new HalfSpace(normal);\n            case RawShapeType.TriMesh:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new TriMesh(vs, indices);\n            case RawShapeType.HeightField:\n                const scale = rawSet.coHeightfieldScale(handle);\n                const heights = rawSet.coHeightfieldHeights(handle);\n                // #if DIM3\n                const nrows = rawSet.coHeightfieldNRows(handle);\n                const ncols = rawSet.coHeightfieldNCols(handle);\n                return new Heightfield(nrows, ncols, heights, scale);\n            // #endif\n            // #if DIM3\n            case RawShapeType.ConvexPolyhedron:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                return new ConvexPolyhedron(vs, indices);\n            case RawShapeType.RoundConvexPolyhedron:\n                vs = rawSet.coVertices(handle);\n                indices = rawSet.coIndices(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundConvexPolyhedron(vs, indices, borderRadius);\n            case RawShapeType.Cylinder:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Cylinder(halfHeight, radius);\n            case RawShapeType.RoundCylinder:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundCylinder(halfHeight, radius, borderRadius);\n            case RawShapeType.Cone:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                return new Cone(halfHeight, radius);\n            case RawShapeType.RoundCone:\n                halfHeight = rawSet.coHalfHeight(handle);\n                radius = rawSet.coRadius(handle);\n                borderRadius = rawSet.coRoundRadius(handle);\n                return new RoundCone(halfHeight, radius, borderRadius);\n            // #endif\n            default:\n                throw new Error(\"unknown shape type: \" + rawType);\n        }\n    }\n    /**\n     * Computes the time of impact between two moving shapes.\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shapeVel1 - The velocity of this shape.\n     * @param shape2 - The second moving shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param shapeVel2 - The velocity of the second shape.\n     * @param maxToi - The maximum time when the impact can happen.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     * @returns If the two moving shapes collider at some point along their trajectories, this returns the\n     *  time at which the two shape collider as well as the contact information during the impact. Returns\n     *  `null`if the two shapes never collide along their paths.\n     */\n    castShape(shapePos1, shapeRot1, shapeVel1, shape2, shapePos2, shapeRot2, shapeVel2, maxToi, stopAtPenetration) {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawVel1 = VectorOps.intoRaw(shapeVel1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawVel2 = VectorOps.intoRaw(shapeVel2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = ShapeTOI.fromRaw(null, rawShape1.castShape(rawPos1, rawRot1, rawVel1, rawShape2, rawPos2, rawRot2, rawVel2, maxToi, stopAtPenetration));\n        rawPos1.free();\n        rawRot1.free();\n        rawVel1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawVel2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Tests if this shape intersects another shape.\n     *\n     * @param shapePos1 - The position of this shape.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2  - The second shape to test.\n     * @param shapePos2 - The position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @returns `true` if the two shapes intersect, `false` if they dont.\n     */\n    intersectsShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2) {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = rawShape1.intersectsShape(rawPos1, rawRot1, rawShape2, rawPos2, rawRot2);\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between two shapes.\n     *\n     * @param shapePos1 - The initial position of this sahpe.\n     * @param shapeRot1 - The rotation of this shape.\n     * @param shape2 - The second shape.\n     * @param shapePos2 - The initial position of the second shape.\n     * @param shapeRot2 - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(shapePos1, shapeRot1, shape2, shapePos2, shapeRot2, prediction) {\n        let rawPos1 = VectorOps.intoRaw(shapePos1);\n        let rawRot1 = RotationOps.intoRaw(shapeRot1);\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape1 = this.intoRaw();\n        let rawShape2 = shape2.intoRaw();\n        let result = ShapeContact.fromRaw(rawShape1.contactShape(rawPos1, rawRot1, rawShape2, rawPos2, rawRot2, prediction));\n        rawPos1.free();\n        rawRot1.free();\n        rawPos2.free();\n        rawRot2.free();\n        rawShape1.free();\n        rawShape2.free();\n        return result;\n    }\n    containsPoint(shapePos, shapeRot, point) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n        let result = rawShape.containsPoint(rawPos, rawRot, rawPoint);\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n        return result;\n    }\n    projectPoint(shapePos, shapeRot, point, solid) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawPoint = VectorOps.intoRaw(point);\n        let rawShape = this.intoRaw();\n        let result = PointProjection.fromRaw(rawShape.projectPoint(rawPos, rawRot, rawPoint, solid));\n        rawPos.free();\n        rawRot.free();\n        rawPoint.free();\n        rawShape.free();\n        return result;\n    }\n    intersectsRay(ray, shapePos, shapeRot, maxToi) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = rawShape.intersectsRay(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi);\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n    castRay(ray, shapePos, shapeRot, maxToi, solid) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = rawShape.castRay(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi, solid);\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n    castRayAndGetNormal(ray, shapePos, shapeRot, maxToi, solid) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawRayOrig = VectorOps.intoRaw(ray.origin);\n        let rawRayDir = VectorOps.intoRaw(ray.dir);\n        let rawShape = this.intoRaw();\n        let result = RayIntersection.fromRaw(rawShape.castRayAndGetNormal(rawPos, rawRot, rawRayOrig, rawRayDir, maxToi, solid));\n        rawPos.free();\n        rawRot.free();\n        rawRayOrig.free();\n        rawRayDir.free();\n        rawShape.free();\n        return result;\n    }\n}\n// #if DIM3\n/**\n * An enumeration representing the type of a shape.\n */\nexport var ShapeType;\n(function (ShapeType) {\n    ShapeType[ShapeType[\"Ball\"] = 0] = \"Ball\";\n    ShapeType[ShapeType[\"Cuboid\"] = 1] = \"Cuboid\";\n    ShapeType[ShapeType[\"Capsule\"] = 2] = \"Capsule\";\n    ShapeType[ShapeType[\"Segment\"] = 3] = \"Segment\";\n    ShapeType[ShapeType[\"Polyline\"] = 4] = \"Polyline\";\n    ShapeType[ShapeType[\"Triangle\"] = 5] = \"Triangle\";\n    ShapeType[ShapeType[\"TriMesh\"] = 6] = \"TriMesh\";\n    ShapeType[ShapeType[\"HeightField\"] = 7] = \"HeightField\";\n    // Compound = 8,\n    ShapeType[ShapeType[\"ConvexPolyhedron\"] = 9] = \"ConvexPolyhedron\";\n    ShapeType[ShapeType[\"Cylinder\"] = 10] = \"Cylinder\";\n    ShapeType[ShapeType[\"Cone\"] = 11] = \"Cone\";\n    ShapeType[ShapeType[\"RoundCuboid\"] = 12] = \"RoundCuboid\";\n    ShapeType[ShapeType[\"RoundTriangle\"] = 13] = \"RoundTriangle\";\n    ShapeType[ShapeType[\"RoundCylinder\"] = 14] = \"RoundCylinder\";\n    ShapeType[ShapeType[\"RoundCone\"] = 15] = \"RoundCone\";\n    ShapeType[ShapeType[\"RoundConvexPolyhedron\"] = 16] = \"RoundConvexPolyhedron\";\n    ShapeType[ShapeType[\"HalfSpace\"] = 17] = \"HalfSpace\";\n})(ShapeType || (ShapeType = {}));\n// #endif\n/**\n * A shape that is a sphere in 3D and a circle in 2D.\n */\nexport class Ball extends Shape {\n    /**\n     * Creates a new ball with the given radius.\n     * @param radius - The balls radius.\n     */\n    constructor(radius) {\n        super();\n        this.type = ShapeType.Ball;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.ball(this.radius);\n    }\n}\nexport class HalfSpace extends Shape {\n    /**\n     * Creates a new halfspace delimited by an infinite plane.\n     *\n     * @param normal - The outward normal of the plane.\n     */\n    constructor(normal) {\n        super();\n        this.type = ShapeType.HalfSpace;\n        this.normal = normal;\n    }\n    intoRaw() {\n        let n = VectorOps.intoRaw(this.normal);\n        let result = RawShape.halfspace(n);\n        n.free();\n        return result;\n    }\n}\n/**\n * A shape that is a box in 3D and a rectangle in 2D.\n */\nexport class Cuboid extends Shape {\n    // #if DIM3\n    /**\n     * Creates a new 3D cuboid.\n     * @param hx - The half width of the cuboid.\n     * @param hy - The half height of the cuboid.\n     * @param hz - The half depth of the cuboid.\n     */\n    constructor(hx, hy, hz) {\n        super();\n        this.type = ShapeType.Cuboid;\n        this.halfExtents = VectorOps.new(hx, hy, hz);\n    }\n    // #endif\n    intoRaw() {\n        // #if DIM3\n        return RawShape.cuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z);\n        // #endif\n    }\n}\n/**\n * A shape that is a box in 3D and a rectangle in 2D, with round corners.\n */\nexport class RoundCuboid extends Shape {\n    // #if DIM3\n    /**\n     * Creates a new 3D cuboid.\n     * @param hx - The half width of the cuboid.\n     * @param hy - The half height of the cuboid.\n     * @param hz - The half depth of the cuboid.\n     * @param borderRadius - The radius of the borders of this cuboid. This will\n     *   effectively increase the half-extents of the cuboid by this radius.\n     */\n    constructor(hx, hy, hz, borderRadius) {\n        super();\n        this.type = ShapeType.RoundCuboid;\n        this.halfExtents = VectorOps.new(hx, hy, hz);\n        this.borderRadius = borderRadius;\n    }\n    // #endif\n    intoRaw() {\n        // #if DIM3\n        return RawShape.roundCuboid(this.halfExtents.x, this.halfExtents.y, this.halfExtents.z, this.borderRadius);\n        // #endif\n    }\n}\n/**\n * A shape that is a capsule.\n */\nexport class Capsule extends Shape {\n    /**\n     * Creates a new capsule with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight, radius) {\n        super();\n        this.type = ShapeType.Capsule;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.capsule(this.halfHeight, this.radius);\n    }\n}\n/**\n * A shape that is a segment.\n */\nexport class Segment extends Shape {\n    /**\n     * Creates a new segment shape.\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    constructor(a, b) {\n        super();\n        this.type = ShapeType.Segment;\n        this.a = a;\n        this.b = b;\n    }\n    intoRaw() {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let result = RawShape.segment(ra, rb);\n        ra.free();\n        rb.free();\n        return result;\n    }\n}\n/**\n * A shape that is a segment.\n */\nexport class Triangle extends Shape {\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    constructor(a, b, c) {\n        super();\n        this.type = ShapeType.Triangle;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n    intoRaw() {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.triangle(ra, rb, rc);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n/**\n * A shape that is a triangle with round borders and a non-zero thickness.\n */\nexport class RoundTriangle extends Shape {\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    constructor(a, b, c, borderRadius) {\n        super();\n        this.type = ShapeType.RoundTriangle;\n        this.a = a;\n        this.b = b;\n        this.c = c;\n        this.borderRadius = borderRadius;\n    }\n    intoRaw() {\n        let ra = VectorOps.intoRaw(this.a);\n        let rb = VectorOps.intoRaw(this.b);\n        let rc = VectorOps.intoRaw(this.c);\n        let result = RawShape.roundTriangle(ra, rb, rc, this.borderRadius);\n        ra.free();\n        rb.free();\n        rc.free();\n        return result;\n    }\n}\n/**\n * A shape that is a triangle mesh.\n */\nexport class Polyline extends Shape {\n    /**\n     * Creates a new polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `null` or not provided, then\n     *    the vertices are assumed to form a line strip.\n     */\n    constructor(vertices, indices) {\n        super();\n        this.type = ShapeType.Polyline;\n        this.vertices = vertices;\n        this.indices = indices !== null && indices !== void 0 ? indices : new Uint32Array(0);\n    }\n    intoRaw() {\n        return RawShape.polyline(this.vertices, this.indices);\n    }\n}\n/**\n * A shape that is a triangle mesh.\n */\nexport class TriMesh extends Shape {\n    /**\n     * Creates a new triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    constructor(vertices, indices) {\n        super();\n        this.type = ShapeType.TriMesh;\n        this.vertices = vertices;\n        this.indices = indices;\n    }\n    intoRaw() {\n        return RawShape.trimesh(this.vertices, this.indices);\n    }\n}\n// #if DIM3\n/**\n * A shape that is a convex polygon.\n */\nexport class ConvexPolyhedron extends Shape {\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param indices - The index buffer of this convex mesh. If this is `null`\n     *   or `undefined`, the convex-hull of the input vertices will be computed\n     *   automatically. Otherwise, it will be assumed that the mesh you provide\n     *   is already convex.\n     */\n    constructor(vertices, indices) {\n        super();\n        this.type = ShapeType.ConvexPolyhedron;\n        this.vertices = vertices;\n        this.indices = indices;\n    }\n    intoRaw() {\n        if (!!this.indices) {\n            return RawShape.convexMesh(this.vertices, this.indices);\n        }\n        else {\n            return RawShape.convexHull(this.vertices);\n        }\n    }\n}\n/**\n * A shape that is a convex polygon.\n */\nexport class RoundConvexPolyhedron extends Shape {\n    /**\n     * Creates a new convex polygon shape.\n     *\n     * @param vertices - The coordinates of the convex polygon's vertices.\n     * @param indices - The index buffer of this convex mesh. If this is `null`\n     *   or `undefined`, the convex-hull of the input vertices will be computed\n     *   automatically. Otherwise, it will be assumed that the mesh you provide\n     *   is already convex.\n     * @param borderRadius - The radius of the borders of this convex polyhedron.\n     */\n    constructor(vertices, indices, borderRadius) {\n        super();\n        this.type = ShapeType.RoundConvexPolyhedron;\n        this.vertices = vertices;\n        this.indices = indices;\n        this.borderRadius = borderRadius;\n    }\n    intoRaw() {\n        if (!!this.indices) {\n            return RawShape.roundConvexMesh(this.vertices, this.indices, this.borderRadius);\n        }\n        else {\n            return RawShape.roundConvexHull(this.vertices, this.borderRadius);\n        }\n    }\n}\n/**\n * A shape that is a heightfield.\n */\nexport class Heightfield extends Shape {\n    /**\n     * Creates a new heightfield shape.\n     *\n     * @param nrows  The number of rows in the heights matrix.\n     * @param ncols - The number of columns in the heights matrix.\n     * @param heights - The heights of the heightfield along its local `y` axis,\n     *                  provided as a matrix stored in column-major order.\n     * @param scale - The dimensions of the heightfield's local `x,z` plane.\n     */\n    constructor(nrows, ncols, heights, scale) {\n        super();\n        this.type = ShapeType.HeightField;\n        this.nrows = nrows;\n        this.ncols = ncols;\n        this.heights = heights;\n        this.scale = scale;\n    }\n    intoRaw() {\n        let rawScale = VectorOps.intoRaw(this.scale);\n        let rawShape = RawShape.heightfield(this.nrows, this.ncols, this.heights, rawScale);\n        rawScale.free();\n        return rawShape;\n    }\n}\n/**\n * A shape that is a 3D cylinder.\n */\nexport class Cylinder extends Shape {\n    /**\n     * Creates a new cylinder with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight, radius) {\n        super();\n        this.type = ShapeType.Cylinder;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.cylinder(this.halfHeight, this.radius);\n    }\n}\n/**\n * A shape that is a 3D cylinder with round corners.\n */\nexport class RoundCylinder extends Shape {\n    /**\n     * Creates a new cylinder with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     * @param borderRadius - The radius of the borders of this cylinder.\n     */\n    constructor(halfHeight, radius, borderRadius) {\n        super();\n        this.type = ShapeType.RoundCylinder;\n        this.borderRadius = borderRadius;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.roundCylinder(this.halfHeight, this.radius, this.borderRadius);\n    }\n}\n/**\n * A shape that is a 3D cone.\n */\nexport class Cone extends Shape {\n    /**\n     * Creates a new cone with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     */\n    constructor(halfHeight, radius) {\n        super();\n        this.type = ShapeType.Cone;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n    }\n    intoRaw() {\n        return RawShape.cone(this.halfHeight, this.radius);\n    }\n}\n/**\n * A shape that is a 3D cone with round corners.\n */\nexport class RoundCone extends Shape {\n    /**\n     * Creates a new cone with the given radius and half-height.\n     * @param halfHeight - The balls half-height along the `y` axis.\n     * @param radius - The balls radius.\n     * @param borderRadius - The radius of the borders of this cone.\n     */\n    constructor(halfHeight, radius, borderRadius) {\n        super();\n        this.type = ShapeType.RoundCone;\n        this.halfHeight = halfHeight;\n        this.radius = radius;\n        this.borderRadius = borderRadius;\n    }\n    intoRaw() {\n        return RawShape.roundCone(this.halfHeight, this.radius, this.borderRadius);\n    }\n}\n// #endif\n//# sourceMappingURL=shape.js.map","import { RawQueryPipeline } from \"../raw\";\nimport { PointColliderProjection, RayColliderIntersection, RayColliderToi, ShapeColliderTOI, } from \"../geometry\";\nimport { RotationOps, VectorOps } from \"../math\";\n// NOTE: must match the bits in the QueryFilterFlags on the Rust side.\n/**\n * Flags for excluding whole sets of colliders from a scene query.\n */\nexport var QueryFilterFlags;\n(function (QueryFilterFlags) {\n    /**\n     * Exclude from the query any collider attached to a fixed rigid-body and colliders with no rigid-body attached.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_FIXED\"] = 1] = \"EXCLUDE_FIXED\";\n    /**\n     * Exclude from the query any collider attached to a dynamic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_KINEMATIC\"] = 2] = \"EXCLUDE_KINEMATIC\";\n    /**\n     * Exclude from the query any collider attached to a kinematic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_DYNAMIC\"] = 4] = \"EXCLUDE_DYNAMIC\";\n    /**\n     * Exclude from the query any collider that is a sensor.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_SENSORS\"] = 8] = \"EXCLUDE_SENSORS\";\n    /**\n     * Exclude from the query any collider that is not a sensor.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"EXCLUDE_SOLIDS\"] = 16] = \"EXCLUDE_SOLIDS\";\n    /**\n     * Excludes all colliders not attached to a dynamic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"ONLY_DYNAMIC\"] = 3] = \"ONLY_DYNAMIC\";\n    /**\n     * Excludes all colliders not attached to a kinematic rigid-body.\n     */\n    QueryFilterFlags[QueryFilterFlags[\"ONLY_KINEMATIC\"] = 5] = \"ONLY_KINEMATIC\";\n    /**\n     * Exclude all colliders attached to a non-fixed rigid-body\n     * (this will not exclude colliders not attached to any rigid-body).\n     */\n    QueryFilterFlags[QueryFilterFlags[\"ONLY_FIXED\"] = 6] = \"ONLY_FIXED\";\n})(QueryFilterFlags || (QueryFilterFlags = {}));\n/**\n * A pipeline for performing queries on all the colliders of a scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class QueryPipeline {\n    constructor(raw) {\n        this.raw = raw || new RawQueryPipeline();\n    }\n    /**\n     * Release the WASM memory occupied by this query pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Updates the acceleration structure of the query pipeline.\n     * @param bodies - The set of rigid-bodies taking part in this pipeline.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     */\n    update(bodies, colliders) {\n        this.raw.update(bodies.raw, colliders.raw);\n    }\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    castRay(bodies, colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderToi.fromRaw(colliders, this.raw.castRay(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Find the closest intersection between a ray and a set of collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    castRayAndGetNormal(bodies, colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayColliderIntersection.fromRaw(colliders, this.raw.castRayAndGetNormal(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    intersectionsWithRay(bodies, colliders, ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let rawCallback = (rawInter) => {\n            return callback(RayColliderIntersection.fromRaw(colliders, rawInter));\n        };\n        this.raw.intersectionsWithRay(bodies.raw, colliders.raw, rawOrig, rawDir, maxToi, solid, rawCallback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawOrig.free();\n        rawDir.free();\n    }\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    intersectionWithShape(bodies, colliders, shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        let result = this.raw.intersectionWithShape(bodies.raw, colliders.raw, rawPos, rawRot, rawShape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPoint(bodies, colliders, point, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(colliders, this.raw.projectPoint(bodies.raw, colliders.raw, rawPoint, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPointAndGetFeature(bodies, colliders, point, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointColliderProjection.fromRaw(colliders, this.raw.projectPointAndGetFeature(bodies.raw, colliders.raw, rawPoint, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    intersectionsWithPoint(bodies, colliders, point, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPoint = VectorOps.intoRaw(point);\n        this.raw.intersectionsWithPoint(bodies.raw, colliders.raw, rawPoint, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawPoint.free();\n    }\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    castShape(bodies, colliders, shapePos, shapeRot, shapeVel, shape, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawVel = VectorOps.intoRaw(shapeVel);\n        let rawShape = shape.intoRaw();\n        let result = ShapeColliderTOI.fromRaw(colliders, this.raw.castShape(bodies.raw, colliders.raw, rawPos, rawRot, rawVel, rawShape, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate));\n        rawPos.free();\n        rawRot.free();\n        rawVel.free();\n        rawShape.free();\n        return result;\n    }\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param colliders - The set of colliders taking part in this pipeline.\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    intersectionsWithShape(bodies, colliders, shapePos, shapeRot, shape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let rawPos = VectorOps.intoRaw(shapePos);\n        let rawRot = RotationOps.intoRaw(shapeRot);\n        let rawShape = shape.intoRaw();\n        this.raw.intersectionsWithShape(bodies.raw, colliders.raw, rawPos, rawRot, rawShape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate);\n        rawPos.free();\n        rawRot.free();\n        rawShape.free();\n    }\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        let rawCenter = VectorOps.intoRaw(aabbCenter);\n        let rawHalfExtents = VectorOps.intoRaw(aabbHalfExtents);\n        this.raw.collidersWithAabbIntersectingAabb(rawCenter, rawHalfExtents, callback);\n        rawCenter.free();\n        rawHalfExtents.free();\n    }\n}\n//# sourceMappingURL=query_pipeline.js.map","import { RawEventQueue } from \"../raw\";\nimport { VectorOps } from \"../math\";\n/**\n * Flags indicating what events are enabled for colliders.\n */\nexport var ActiveEvents;\n(function (ActiveEvents) {\n    ActiveEvents[ActiveEvents[\"NONE\"] = 0] = \"NONE\";\n    /**\n     * Enable collision events.\n     */\n    ActiveEvents[ActiveEvents[\"COLLISION_EVENTS\"] = 1] = \"COLLISION_EVENTS\";\n    /**\n     * Enable contact force events.\n     */\n    ActiveEvents[ActiveEvents[\"CONTACT_FORCE_EVENTS\"] = 2] = \"CONTACT_FORCE_EVENTS\";\n})(ActiveEvents || (ActiveEvents = {}));\n/**\n * Event occurring when the sum of the magnitudes of the\n * contact forces between two colliders exceed a threshold.\n *\n * This object should **not** be stored anywhere. Its properties can only be\n * read from within the closure given to `EventHandler.drainContactForceEvents`.\n */\nexport class TempContactForceEvent {\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * The first collider involved in the contact.\n     */\n    collider1() {\n        return this.raw.collider1();\n    }\n    /**\n     * The second collider involved in the contact.\n     */\n    collider2() {\n        return this.raw.collider2();\n    }\n    /**\n     * The sum of all the forces between the two colliders.\n     */\n    totalForce() {\n        return VectorOps.fromRaw(this.raw.total_force());\n    }\n    /**\n     * The sum of the magnitudes of each force between the two colliders.\n     *\n     * Note that this is **not** the same as the magnitude of `self.total_force`.\n     * Here we are summing the magnitude of all the forces, instead of taking\n     * the magnitude of their sum.\n     */\n    totalForceMagnitude() {\n        return this.raw.total_force_magnitude();\n    }\n    /**\n     * The world-space (unit) direction of the force with strongest magnitude.\n     */\n    maxForceDirection() {\n        return VectorOps.fromRaw(this.raw.max_force_direction());\n    }\n    /**\n     * The magnitude of the largest force at a contact point of this contact pair.\n     */\n    maxForceMagnitude() {\n        return this.raw.max_force_magnitude();\n    }\n}\n/**\n * A structure responsible for collecting events generated\n * by the physics engine.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `eventQueue.free()`\n * once you are done using it.\n */\nexport class EventQueue {\n    /**\n     * Creates a new event collector.\n     *\n     * @param autoDrain -setting this to `true` is strongly recommended. If true, the collector will\n     * be automatically drained before each `world.step(collector)`. If false, the collector will\n     * keep all events in memory unless it is manually drained/cleared; this may lead to unbounded use of\n     * RAM if no drain is performed.\n     */\n    constructor(autoDrain, raw) {\n        this.raw = raw || new RawEventQueue(autoDrain);\n    }\n    /**\n     * Release the WASM memory occupied by this event-queue.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Applies the given javascript closure on each collision event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     * closure must take three arguments: two integers representing the handles of the colliders\n     * involved in the collision, and a boolean indicating if the collision started (true) or stopped\n     * (false).\n     */\n    drainCollisionEvents(f) {\n        this.raw.drainCollisionEvents(f);\n    }\n    /**\n     * Applies the given javascript closure on each contact force event of this collector, then clear\n     * the internal collision event buffer.\n     *\n     * @param f - JavaScript closure applied to each collision event. The\n     *            closure must take one `TempContactForceEvent` argument.\n     */\n    drainContactForceEvents(f) {\n        let event = new TempContactForceEvent();\n        this.raw.drainContactForceEvents((raw) => {\n            event.raw = raw;\n            f(event);\n            event.free();\n        });\n    }\n    /**\n     * Removes all events contained by this collector\n     */\n    clear() {\n        this.raw.clear();\n    }\n}\n//# sourceMappingURL=event_queue.js.map","export var ActiveHooks;\n(function (ActiveHooks) {\n    ActiveHooks[ActiveHooks[\"NONE\"] = 0] = \"NONE\";\n    ActiveHooks[ActiveHooks[\"FILTER_CONTACT_PAIRS\"] = 1] = \"FILTER_CONTACT_PAIRS\";\n    ActiveHooks[ActiveHooks[\"FILTER_INTERSECTION_PAIRS\"] = 2] = \"FILTER_INTERSECTION_PAIRS\";\n    // MODIFY_SOLVER_CONTACTS = 0b0100, /* Not supported yet in JS. */\n})(ActiveHooks || (ActiveHooks = {}));\nexport var SolverFlags;\n(function (SolverFlags) {\n    SolverFlags[SolverFlags[\"EMPTY\"] = 0] = \"EMPTY\";\n    SolverFlags[SolverFlags[\"COMPUTE_IMPULSE\"] = 1] = \"COMPUTE_IMPULSE\";\n})(SolverFlags || (SolverFlags = {}));\n//# sourceMappingURL=physics_hooks.js.map","import { RotationOps, VectorOps } from \"../math\";\nimport { CoefficientCombineRule, } from \"../dynamics\";\nimport { ActiveHooks, ActiveEvents } from \"../pipeline\";\nimport { Shape, Cuboid, Ball, Capsule, TriMesh, Polyline, Heightfield, Segment, Triangle, RoundTriangle, RoundCuboid, \n// #if DIM3\nCylinder, RoundCylinder, Cone, RoundCone, ConvexPolyhedron, RoundConvexPolyhedron,\n// #endif\n } from \"./shape\";\nimport { RayIntersection } from \"./ray\";\nimport { PointProjection } from \"./point\";\nimport { ShapeColliderTOI, ShapeTOI } from \"./toi\";\nimport { ShapeContact } from \"./contact\";\n/**\n * Flags affecting whether collision-detection happens between two colliders\n * depending on the type of rigid-bodies they are attached to.\n */\nexport var ActiveCollisionTypes;\n(function (ActiveCollisionTypes) {\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a dynamic body.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_DYNAMIC\"] = 1] = \"DYNAMIC_DYNAMIC\";\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a kinematic body.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_KINEMATIC\"] = 12] = \"DYNAMIC_KINEMATIC\";\n    /**\n     * Enable collision-detection between a collider attached to a dynamic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DYNAMIC_FIXED\"] = 2] = \"DYNAMIC_FIXED\";\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a kinematic body.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"KINEMATIC_KINEMATIC\"] = 52224] = \"KINEMATIC_KINEMATIC\";\n    /**\n     * Enable collision-detection between a collider attached to a kinematic body\n     * and another collider attached to a fixed body (or not attached to any body).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"KINEMATIC_FIXED\"] = 8704] = \"KINEMATIC_FIXED\";\n    /**\n     * Enable collision-detection between a collider attached to a fixed body (or\n     * not attached to any body) and another collider attached to a fixed body (or\n     * not attached to any body).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"FIXED_FIXED\"] = 32] = \"FIXED_FIXED\";\n    /**\n     * The default active collision types, enabling collisions between a dynamic body\n     * and another body of any type, but not enabling collisions between two non-dynamic bodies.\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"DEFAULT\"] = 15] = \"DEFAULT\";\n    /**\n     * Enable collisions between any kind of rigid-bodies (including between two non-dynamic bodies).\n     */\n    ActiveCollisionTypes[ActiveCollisionTypes[\"ALL\"] = 60943] = \"ALL\";\n})(ActiveCollisionTypes || (ActiveCollisionTypes = {}));\n/**\n * A geometric entity that can be attached to a body so it can be affected\n * by contacts and proximity queries.\n */\nexport class Collider {\n    constructor(colliderSet, handle, parent, shape) {\n        this.colliderSet = colliderSet;\n        this.handle = handle;\n        this._parent = parent;\n        this._shape = shape;\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        if (this.handle != null) {\n            this._parent = bodies.get(this.colliderSet.raw.coParent(this.handle));\n        }\n    }\n    ensureShapeIsCached() {\n        if (!this._shape)\n            this._shape = Shape.fromRaw(this.colliderSet.raw, this.handle);\n    }\n    /**\n     * The shape of this collider.\n     */\n    get shape() {\n        this.ensureShapeIsCached();\n        return this._shape;\n    }\n    /**\n     * Checks if this collider is still valid (i.e. that it has\n     * not been deleted from the collider set yet).\n     */\n    isValid() {\n        return this.colliderSet.raw.contains(this.handle);\n    }\n    /**\n     * The world-space translation of this rigid-body.\n     */\n    translation() {\n        return VectorOps.fromRaw(this.colliderSet.raw.coTranslation(this.handle));\n    }\n    /**\n     * The world-space orientation of this rigid-body.\n     */\n    rotation() {\n        return RotationOps.fromRaw(this.colliderSet.raw.coRotation(this.handle));\n    }\n    /**\n     * Is this collider a sensor?\n     */\n    isSensor() {\n        return this.colliderSet.raw.coIsSensor(this.handle);\n    }\n    /**\n     * Sets whether or not this collider is a sensor.\n     * @param isSensor - If `true`, the collider will be a sensor.\n     */\n    setSensor(isSensor) {\n        this.colliderSet.raw.coSetSensor(this.handle, isSensor);\n    }\n    /**\n     * Sets the new shape of the collider.\n     * @param shape - The colliders new shape.\n     */\n    setShape(shape) {\n        let rawShape = shape.intoRaw();\n        this.colliderSet.raw.coSetShape(this.handle, rawShape);\n        rawShape.free();\n        this._shape = shape;\n    }\n    /**\n     * Sets whether this collider is enabled or not.\n     *\n     * @param enabled - Set to `false` to disable this collider (its parent rigid-body wont be disabled automatically by this).\n     */\n    setEnabled(enabled) {\n        this.colliderSet.raw.coSetEnabled(this.handle, enabled);\n    }\n    /**\n     * Is this collider enabled?\n     */\n    isEnabled() {\n        return this.colliderSet.raw.coIsEnabled(this.handle);\n    }\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    setRestitution(restitution) {\n        this.colliderSet.raw.coSetRestitution(this.handle, restitution);\n    }\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    setFriction(friction) {\n        this.colliderSet.raw.coSetFriction(this.handle, friction);\n    }\n    /**\n     * Gets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    frictionCombineRule() {\n        return this.colliderSet.raw.coFrictionCombineRule(this.handle);\n    }\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    setFrictionCombineRule(rule) {\n        this.colliderSet.raw.coSetFrictionCombineRule(this.handle, rule);\n    }\n    /**\n     * Gets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     */\n    restitutionCombineRule() {\n        return this.colliderSet.raw.coRestitutionCombineRule(this.handle);\n    }\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    setRestitutionCombineRule(rule) {\n        this.colliderSet.raw.coSetRestitutionCombineRule(this.handle, rule);\n    }\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    setCollisionGroups(groups) {\n        this.colliderSet.raw.coSetCollisionGroups(this.handle, groups);\n    }\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    setSolverGroups(groups) {\n        this.colliderSet.raw.coSetSolverGroups(this.handle, groups);\n    }\n    /**\n     * Get the physics hooks active for this collider.\n     */\n    activeHooks() {\n        return this.colliderSet.raw.coActiveHooks(this.handle);\n    }\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveHooks(activeHooks) {\n        this.colliderSet.raw.coSetActiveHooks(this.handle, activeHooks);\n    }\n    /**\n     * The events active for this collider.\n     */\n    activeEvents() {\n        return this.colliderSet.raw.coActiveEvents(this.handle);\n    }\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    setActiveEvents(activeEvents) {\n        this.colliderSet.raw.coSetActiveEvents(this.handle, activeEvents);\n    }\n    /**\n     * Gets the collision types active for this collider.\n     */\n    activeCollisionTypes() {\n        return this.colliderSet.raw.coActiveCollisionTypes(this.handle);\n    }\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The new force threshold.\n     */\n    setContactForceEventThreshold(threshold) {\n        return this.colliderSet.raw.coSetContactForceEventThreshold(this.handle, threshold);\n    }\n    /**\n     * The total force magnitude beyond which a contact force event can be emitted.\n     */\n    contactForceEventThreshold() {\n        return this.colliderSet.raw.coContactForceEventThreshold(this.handle);\n    }\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveCollisionTypes(activeCollisionTypes) {\n        this.colliderSet.raw.coSetActiveCollisionTypes(this.handle, activeCollisionTypes);\n    }\n    /**\n     * Sets the uniform density of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The mass and angular inertia of this collider will be computed automatically based on its\n     * shape.\n     */\n    setDensity(density) {\n        this.colliderSet.raw.coSetDensity(this.handle, density);\n    }\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     *\n     * The angular inertia of this collider will be computed automatically based on its shape\n     * and this mass value.\n     */\n    setMass(mass) {\n        this.colliderSet.raw.coSetMass(this.handle, mass);\n    }\n    // #if DIM3\n    /**\n     * Sets the mass of this collider.\n     *\n     * This will override any previous mass-properties set by `this.setDensity`,\n     * `this.setMass`, `this.setMassProperties`, `ColliderDesc.density`,\n     * `ColliderDesc.mass`, or `ColliderDesc.massProperties` for this collider.\n     */\n    setMassProperties(mass, centerOfMass, principalAngularInertia, angularInertiaLocalFrame) {\n        let rawCom = VectorOps.intoRaw(centerOfMass);\n        let rawPrincipalInertia = VectorOps.intoRaw(principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(angularInertiaLocalFrame);\n        this.colliderSet.raw.coSetMassProperties(this.handle, mass, rawCom, rawPrincipalInertia, rawInertiaFrame);\n        rawCom.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n    }\n    // #endif\n    /**\n     * Sets the translation of this collider.\n     *\n     * @param tra - The world-space position of the collider.\n     */\n    setTranslation(tra) {\n        // #if DIM3\n        this.colliderSet.raw.coSetTranslation(this.handle, tra.x, tra.y, tra.z);\n        // #endif\n    }\n    /**\n     * Sets the translation of this collider relative to its parent rigid-body.\n     *\n     * Does nothing if this collider isn't attached to a rigid-body.\n     *\n     * @param tra - The new translation of the collider relative to its parent.\n     */\n    setTranslationWrtParent(tra) {\n        // #if DIM3\n        this.colliderSet.raw.coSetTranslationWrtParent(this.handle, tra.x, tra.y, tra.z);\n        // #endif\n    }\n    // #if DIM3\n    /**\n     * Sets the rotation quaternion of this collider.\n     *\n     * This does nothing if a zero quaternion is provided.\n     *\n     * @param rotation - The rotation to set.\n     */\n    setRotation(rot) {\n        this.colliderSet.raw.coSetRotation(this.handle, rot.x, rot.y, rot.z, rot.w);\n    }\n    /**\n     * Sets the rotation quaternion of this collider relative to its parent rigid-body.\n     *\n     * This does nothing if a zero quaternion is provided or if this collider isn't\n     * attached to a rigid-body.\n     *\n     * @param rotation - The rotation to set.\n     */\n    setRotationWrtParent(rot) {\n        this.colliderSet.raw.coSetRotationWrtParent(this.handle, rot.x, rot.y, rot.z, rot.w);\n    }\n    // #endif\n    /**\n     * The type of the shape of this collider.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    shapeType() {\n        return this.colliderSet.raw.coShapeType(this.handle);\n    }\n    /**\n     * The half-extents of this collider if it is a cuboid shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    halfExtents() {\n        return VectorOps.fromRaw(this.colliderSet.raw.coHalfExtents(this.handle));\n    }\n    /**\n     * Sets the half-extents of this collider if it is a cuboid shape.\n     *\n     * @param newHalfExtents - desired half extents.\n     */\n    setHalfExtents(newHalfExtents) {\n        const rawPoint = VectorOps.intoRaw(newHalfExtents);\n        this.colliderSet.raw.coSetHalfExtents(this.handle, rawPoint);\n    }\n    /**\n     * The radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    radius() {\n        return this.colliderSet.raw.coRadius(this.handle);\n    }\n    /**\n     * Sets the radius of this collider if it is a ball, cylinder, capsule, or cone shape.\n     *\n     * @param newRadius - desired radius.\n     */\n    setRadius(newRadius) {\n        this.colliderSet.raw.coSetRadius(this.handle, newRadius);\n    }\n    /**\n     * The radius of the round edges of this collider if it is a round cylinder.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    roundRadius() {\n        return this.colliderSet.raw.coRoundRadius(this.handle);\n    }\n    /**\n     * Sets the radius of the round edges of this collider if it has round edges.\n     *\n     * @param newBorderRadius - desired round edge radius.\n     */\n    setRoundRadius(newBorderRadius) {\n        this.colliderSet.raw.coSetRoundRadius(this.handle, newBorderRadius);\n    }\n    /**\n     * The half height of this collider if it is a cylinder, capsule, or cone shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    halfHeight() {\n        return this.colliderSet.raw.coHalfHeight(this.handle);\n    }\n    /**\n     * Sets the half height of this collider if it is a cylinder, capsule, or cone shape.\n     *\n     * @param newHalfheight - desired half height.\n     */\n    setHalfHeight(newHalfheight) {\n        this.colliderSet.raw.coSetHalfHeight(this.handle, newHalfheight);\n    }\n    /**\n     * If this collider has a triangle mesh, polyline, convex polygon, or convex polyhedron shape,\n     * this returns the vertex buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    vertices() {\n        return this.colliderSet.raw.coVertices(this.handle);\n    }\n    /**\n     * If this collider has a triangle mesh, polyline, or convex polyhedron shape,\n     * this returns the index buffer of said shape.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    indices() {\n        return this.colliderSet.raw.coIndices(this.handle);\n    }\n    /**\n     * If this collider has a heightfield shape, this returns the heights buffer of\n     * the heightfield.\n     * In 3D, the returned height matrix is provided in column-major order.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldHeights() {\n        return this.colliderSet.raw.coHeightfieldHeights(this.handle);\n    }\n    /**\n     * If this collider has a heightfield shape, this returns the scale\n     * applied to it.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldScale() {\n        let scale = this.colliderSet.raw.coHeightfieldScale(this.handle);\n        return VectorOps.fromRaw(scale);\n    }\n    // #if DIM3\n    /**\n     * If this collider has a heightfield shape, this returns the number of\n     * rows of its height matrix.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldNRows() {\n        return this.colliderSet.raw.coHeightfieldNRows(this.handle);\n    }\n    /**\n     * If this collider has a heightfield shape, this returns the number of\n     * columns of its height matrix.\n     * @deprecated this field will be removed in the future, please access this field on `shape` member instead.\n     */\n    heightfieldNCols() {\n        return this.colliderSet.raw.coHeightfieldNCols(this.handle);\n    }\n    // #endif\n    /**\n     * The rigid-body this collider is attached to.\n     */\n    parent() {\n        return this._parent;\n    }\n    /**\n     * The friction coefficient of this collider.\n     */\n    friction() {\n        return this.colliderSet.raw.coFriction(this.handle);\n    }\n    /**\n     * The restitution coefficient of this collider.\n     */\n    restitution() {\n        return this.colliderSet.raw.coRestitution(this.handle);\n    }\n    /**\n     * The density of this collider.\n     */\n    density() {\n        return this.colliderSet.raw.coDensity(this.handle);\n    }\n    /**\n     * The mass of this collider.\n     */\n    mass() {\n        return this.colliderSet.raw.coMass(this.handle);\n    }\n    /**\n     * The volume of this collider.\n     */\n    volume() {\n        return this.colliderSet.raw.coVolume(this.handle);\n    }\n    /**\n     * The collision groups of this collider.\n     */\n    collisionGroups() {\n        return this.colliderSet.raw.coCollisionGroups(this.handle);\n    }\n    /**\n     * The solver groups of this collider.\n     */\n    solverGroups() {\n        return this.colliderSet.raw.coSolverGroups(this.handle);\n    }\n    /**\n     * Tests if this collider contains a point.\n     *\n     * @param point - The point to test.\n     */\n    containsPoint(point) {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = this.colliderSet.raw.coContainsPoint(this.handle, rawPoint);\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Find the projection of a point on this collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     */\n    projectPoint(point, solid) {\n        let rawPoint = VectorOps.intoRaw(point);\n        let result = PointProjection.fromRaw(this.colliderSet.raw.coProjectPoint(this.handle, rawPoint, solid));\n        rawPoint.free();\n        return result;\n    }\n    /**\n     * Tests if this collider intersects the given ray.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     */\n    intersectsRay(ray, maxToi) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coIntersectsRay(this.handle, rawOrig, rawDir, maxToi);\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /*\n     * Computes the smallest time between this and the given shape under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current shape to cast (i.e. the cast direction).\n     * @param shape2 - The shape to cast against.\n     * @param shape2Pos - The position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param shape2Vel - The constant velocity of the second shape.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `collider1Vel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     */\n    castShape(collider1Vel, shape2, shape2Pos, shape2Rot, shape2Vel, maxToi, stopAtPenetration) {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawShape2Pos = VectorOps.intoRaw(shape2Pos);\n        let rawShape2Rot = RotationOps.intoRaw(shape2Rot);\n        let rawShape2Vel = VectorOps.intoRaw(shape2Vel);\n        let rawShape2 = shape2.intoRaw();\n        let result = ShapeTOI.fromRaw(this.colliderSet, this.colliderSet.raw.coCastShape(this.handle, rawCollider1Vel, rawShape2, rawShape2Pos, rawShape2Rot, rawShape2Vel, maxToi, stopAtPenetration));\n        rawCollider1Vel.free();\n        rawShape2Pos.free();\n        rawShape2Rot.free();\n        rawShape2Vel.free();\n        rawShape2.free();\n        return result;\n    }\n    /*\n     * Computes the smallest time between this and the given collider under translational movement are separated by a distance smaller or equal to distance.\n     *\n     * @param collider1Vel - The constant velocity of the current collider to cast (i.e. the cast direction).\n     * @param collider2 - The collider to cast against.\n     * @param collider2Vel - The constant velocity of the second collider.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     */\n    castCollider(collider1Vel, collider2, collider2Vel, maxToi, stopAtPenetration) {\n        let rawCollider1Vel = VectorOps.intoRaw(collider1Vel);\n        let rawCollider2Vel = VectorOps.intoRaw(collider2Vel);\n        let result = ShapeColliderTOI.fromRaw(this.colliderSet, this.colliderSet.raw.coCastCollider(this.handle, rawCollider1Vel, collider2.handle, rawCollider2Vel, maxToi, stopAtPenetration));\n        rawCollider1Vel.free();\n        rawCollider2Vel.free();\n        return result;\n    }\n    intersectsShape(shape2, shapePos2, shapeRot2) {\n        let rawPos2 = VectorOps.intoRaw(shapePos2);\n        let rawRot2 = RotationOps.intoRaw(shapeRot2);\n        let rawShape2 = shape2.intoRaw();\n        let result = this.colliderSet.raw.coIntersectsShape(this.handle, rawShape2, rawPos2, rawRot2);\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between the shape owned by this collider and the given shape.\n     *\n     * @param shape2 - The second shape.\n     * @param shape2Pos - The initial position of the second shape.\n     * @param shape2Rot - The rotation of the second shape.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactShape(shape2, shape2Pos, shape2Rot, prediction) {\n        let rawPos2 = VectorOps.intoRaw(shape2Pos);\n        let rawRot2 = RotationOps.intoRaw(shape2Rot);\n        let rawShape2 = shape2.intoRaw();\n        let result = ShapeContact.fromRaw(this.colliderSet.raw.coContactShape(this.handle, rawShape2, rawPos2, rawRot2, prediction));\n        rawPos2.free();\n        rawRot2.free();\n        rawShape2.free();\n        return result;\n    }\n    /**\n     * Computes one pair of contact points between the collider and the given collider.\n     *\n     * @param collider2 - The second collider.\n     * @param prediction - The prediction value, if the shapes are separated by a distance greater than this value, test will fail.\n     * @returns `null` if the shapes are separated by a distance greater than prediction, otherwise contact details. The result is given in world-space.\n     */\n    contactCollider(collider2, prediction) {\n        let result = ShapeContact.fromRaw(this.colliderSet.raw.coContactCollider(this.handle, collider2.handle, prediction));\n        return result;\n    }\n    /*\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @returns The time-of-impact between this collider and the ray, or `-1` if there is no intersection.\n     */\n    castRay(ray, maxToi, solid) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = this.colliderSet.raw.coCastRay(this.handle, rawOrig, rawDir, maxToi, solid);\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n    /**\n     * Find the closest intersection between a ray and this collider.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     */\n    castRayAndGetNormal(ray, maxToi, solid) {\n        let rawOrig = VectorOps.intoRaw(ray.origin);\n        let rawDir = VectorOps.intoRaw(ray.dir);\n        let result = RayIntersection.fromRaw(this.colliderSet.raw.coCastRayAndGetNormal(this.handle, rawOrig, rawDir, maxToi, solid));\n        rawOrig.free();\n        rawDir.free();\n        return result;\n    }\n}\nexport var MassPropsMode;\n(function (MassPropsMode) {\n    MassPropsMode[MassPropsMode[\"Density\"] = 0] = \"Density\";\n    MassPropsMode[MassPropsMode[\"Mass\"] = 1] = \"Mass\";\n    MassPropsMode[MassPropsMode[\"MassProps\"] = 2] = \"MassProps\";\n})(MassPropsMode || (MassPropsMode = {}));\nexport class ColliderDesc {\n    /**\n     * Initializes a collider descriptor from the collision shape.\n     *\n     * @param shape - The shape of the collider being built.\n     */\n    constructor(shape) {\n        this.enabled = true;\n        this.shape = shape;\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = 1.0;\n        this.friction = 0.5;\n        this.restitution = 0.0;\n        this.rotation = RotationOps.identity();\n        this.translation = VectorOps.zeros();\n        this.isSensor = false;\n        this.collisionGroups = 4294967295;\n        this.solverGroups = 4294967295;\n        this.frictionCombineRule = CoefficientCombineRule.Average;\n        this.restitutionCombineRule = CoefficientCombineRule.Average;\n        this.activeCollisionTypes = ActiveCollisionTypes.DEFAULT;\n        this.activeEvents = ActiveEvents.NONE;\n        this.activeHooks = ActiveHooks.NONE;\n        this.mass = 0.0;\n        this.centerOfMass = VectorOps.zeros();\n        this.contactForceEventThreshold = 0.0;\n        // #if DIM3\n        this.principalAngularInertia = VectorOps.zeros();\n        this.angularInertiaLocalFrame = RotationOps.identity();\n        // #endif\n    }\n    /**\n     * Create a new collider descriptor with a ball shape.\n     *\n     * @param radius - The radius of the ball.\n     */\n    static ball(radius) {\n        const shape = new Ball(radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a capsule shape.\n     *\n     * @param halfHeight - The half-height of the capsule, along the `y` axis.\n     * @param radius - The radius of the capsule basis.\n     */\n    static capsule(halfHeight, radius) {\n        const shape = new Capsule(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new segment shape.\n     *\n     * @param a - The first point of the segment.\n     * @param b - The second point of the segment.\n     */\n    static segment(a, b) {\n        const shape = new Segment(a, b);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new triangle shape.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     */\n    static triangle(a, b, c) {\n        const shape = new Triangle(a, b, c);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new triangle shape with round corners.\n     *\n     * @param a - The first point of the triangle.\n     * @param b - The second point of the triangle.\n     * @param c - The third point of the triangle.\n     * @param borderRadius - The radius of the borders of this triangle. In 3D,\n     *   this is also equal to half the thickness of the triangle.\n     */\n    static roundTriangle(a, b, c, borderRadius) {\n        const shape = new RoundTriangle(a, b, c, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a polyline shape.\n     *\n     * @param vertices - The coordinates of the polyline's vertices.\n     * @param indices - The indices of the polyline's segments. If this is `undefined` or `null`,\n     *    the vertices are assumed to describe a line strip.\n     */\n    static polyline(vertices, indices) {\n        const shape = new Polyline(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a triangle mesh shape.\n     *\n     * @param vertices - The coordinates of the triangle mesh's vertices.\n     * @param indices - The indices of the triangle mesh's triangles.\n     */\n    static trimesh(vertices, indices) {\n        const shape = new TriMesh(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n    // #if DIM3\n    /**\n     * Creates a new collider descriptor with a cuboid shape.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param hz - The half-width of the rectangle along its local `z` axis.\n     */\n    static cuboid(hx, hy, hz) {\n        const shape = new Cuboid(hx, hy, hz);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a rectangular shape with round borders.\n     *\n     * @param hx - The half-width of the rectangle along its local `x` axis.\n     * @param hy - The half-width of the rectangle along its local `y` axis.\n     * @param hz - The half-width of the rectangle along its local `z` axis.\n     * @param borderRadius - The radius of the cuboid's borders.\n     */\n    static roundCuboid(hx, hy, hz, borderRadius) {\n        const shape = new RoundCuboid(hx, hy, hz, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor with a heightfield shape.\n     *\n     * @param nrows  The number of rows in the heights matrix.\n     * @param ncols - The number of columns in the heights matrix.\n     * @param heights - The heights of the heightfield along its local `y` axis,\n     *                  provided as a matrix stored in column-major order.\n     * @param scale - The scale factor applied to the heightfield.\n     */\n    static heightfield(nrows, ncols, heights, scale) {\n        const shape = new Heightfield(nrows, ncols, heights, scale);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a cylinder shape.\n     *\n     * @param halfHeight - The half-height of the cylinder, along the `y` axis.\n     * @param radius - The radius of the cylinder basis.\n     */\n    static cylinder(halfHeight, radius) {\n        const shape = new Cylinder(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a cylinder shape with rounded corners.\n     *\n     * @param halfHeight - The half-height of the cylinder, along the `y` axis.\n     * @param radius - The radius of the cylinder basis.\n     * @param borderRadius - The radius of the cylinder's rounded edges and vertices.\n     */\n    static roundCylinder(halfHeight, radius, borderRadius) {\n        const shape = new RoundCylinder(halfHeight, radius, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a cone shape.\n     *\n     * @param halfHeight - The half-height of the cone, along the `y` axis.\n     * @param radius - The radius of the cone basis.\n     */\n    static cone(halfHeight, radius) {\n        const shape = new Cone(halfHeight, radius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Create a new collider descriptor with a cone shape with rounded corners.\n     *\n     * @param halfHeight - The half-height of the cone, along the `y` axis.\n     * @param radius - The radius of the cone basis.\n     * @param borderRadius - The radius of the cone's rounded edges and vertices.\n     */\n    static roundCone(halfHeight, radius, borderRadius) {\n        const shape = new RoundCone(halfHeight, radius, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polyhedron as the shape for this new collider descriptor.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     */\n    static convexHull(points) {\n        const shape = new ConvexPolyhedron(points, null);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     */\n    static convexMesh(vertices, indices) {\n        const shape = new ConvexPolyhedron(vertices, indices);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Computes the convex-hull of the given points and use the resulting\n     * convex polyhedron as the shape for this new collider descriptor. A\n     * border is added to that convex polyhedron to give it round corners.\n     *\n     * @param points - The point that will be used to compute the convex-hull.\n     * @param borderRadius - The radius of the round border added to the convex polyhedron.\n     */\n    static roundConvexHull(points, borderRadius) {\n        const shape = new RoundConvexPolyhedron(points, null, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    /**\n     * Creates a new collider descriptor that uses the given set of points assumed\n     * to form a round convex polyline (no convex-hull computation will be done).\n     *\n     * @param vertices - The vertices of the convex polyline.\n     * @param borderRadius - The radius of the round border added to the convex polyline.\n     */\n    static roundConvexMesh(vertices, indices, borderRadius) {\n        const shape = new RoundConvexPolyhedron(vertices, indices, borderRadius);\n        return new ColliderDesc(shape);\n    }\n    // #endif\n    // #if DIM3\n    /**\n     * Sets the position of the collider to be created relative to the rigid-body it is attached to.\n     */\n    setTranslation(x, y, z) {\n        if (typeof x != \"number\" ||\n            typeof y != \"number\" ||\n            typeof z != \"number\")\n            throw TypeError(\"The translation components must be numbers.\");\n        this.translation = { x: x, y: y, z: z };\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the rotation of the collider to be created relative to the rigid-body it is attached to.\n     *\n     * @param rot - The rotation of the collider to be created relative to the rigid-body it is attached to.\n     */\n    setRotation(rot) {\n        // #if DIM3\n        RotationOps.copy(this.rotation, rot);\n        // #endif\n        return this;\n    }\n    /**\n     * Sets whether or not the collider being created is a sensor.\n     *\n     * A sensor collider does not take part of the physics simulation, but generates\n     * proximity events.\n     *\n     * @param sensor - Set to `true` of the collider built is to be a sensor.\n     */\n    setSensor(sensor) {\n        this.isSensor = sensor;\n        return this;\n    }\n    /**\n     * Sets whether the created collider will be enabled or disabled.\n     * @param enabled  If set to `false` the collider will be disabled at creation.\n     */\n    setEnabled(enabled) {\n        this.enabled = enabled;\n        return this;\n    }\n    /**\n     * Sets the density of the collider being built.\n     *\n     * The mass and angular inertia tensor will be computed automatically based on this density and the colliders shape.\n     *\n     * @param density - The density to set, must be greater or equal to 0. A density of 0 means that this collider\n     *                  will not affect the mass or angular inertia of the rigid-body it is attached to.\n     */\n    setDensity(density) {\n        this.massPropsMode = MassPropsMode.Density;\n        this.density = density;\n        return this;\n    }\n    /**\n     * Sets the mass of the collider being built.\n     *\n     * The angular inertia tensor will be computed automatically based on this mass and the colliders shape.\n     *\n     * @param mass - The mass to set, must be greater or equal to 0.\n     */\n    setMass(mass) {\n        this.massPropsMode = MassPropsMode.Mass;\n        this.mass = mass;\n        return this;\n    }\n    // #if DIM3\n    /**\n     * Sets the mass properties of the collider being built.\n     *\n     * This replaces the mass-properties automatically computed from the collider's density and shape.\n     * These mass-properties will be added to the mass-properties of the rigid-body this collider will be attached to.\n     *\n     * @param mass  The mass of the collider to create.\n     * @param centerOfMass  The center-of-mass of the collider to create.\n     * @param principalAngularInertia  The initial principal angular inertia of the collider to create.\n     *                                  These are the eigenvalues of the angular inertia matrix.\n     * @param angularInertiaLocalFrame  The initial local angular inertia frame of the collider to create.\n     *                                   These are the eigenvectors of the angular inertia matrix.\n     */\n    setMassProperties(mass, centerOfMass, principalAngularInertia, angularInertiaLocalFrame) {\n        this.massPropsMode = MassPropsMode.MassProps;\n        this.mass = mass;\n        VectorOps.copy(this.centerOfMass, centerOfMass);\n        VectorOps.copy(this.principalAngularInertia, principalAngularInertia);\n        RotationOps.copy(this.angularInertiaLocalFrame, angularInertiaLocalFrame);\n        return this;\n    }\n    // #endif\n    /**\n     * Sets the restitution coefficient of the collider to be created.\n     *\n     * @param restitution - The restitution coefficient in `[0, 1]`. A value of 0 (the default) means no bouncing behavior\n     *                   while 1 means perfect bouncing (though energy may still be lost due to numerical errors of the\n     *                   constraints solver).\n     */\n    setRestitution(restitution) {\n        this.restitution = restitution;\n        return this;\n    }\n    /**\n     * Sets the friction coefficient of the collider to be created.\n     *\n     * @param friction - The friction coefficient. Must be greater or equal to 0. This is generally smaller than 1. The\n     *                   higher the coefficient, the stronger friction forces will be for contacts with the collider\n     *                   being built.\n     */\n    setFriction(friction) {\n        this.friction = friction;\n        return this;\n    }\n    /**\n     * Sets the rule used to combine the friction coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    setFrictionCombineRule(rule) {\n        this.frictionCombineRule = rule;\n        return this;\n    }\n    /**\n     * Sets the rule used to combine the restitution coefficients of two colliders\n     * colliders involved in a contact.\n     *\n     * @param rule  The combine rule to apply.\n     */\n    setRestitutionCombineRule(rule) {\n        this.restitutionCombineRule = rule;\n        return this;\n    }\n    /**\n     * Sets the collision groups used by this collider.\n     *\n     * Two colliders will interact iff. their collision groups are compatible.\n     * See the documentation of `InteractionGroups` for details on teh used bit pattern.\n     *\n     * @param groups - The collision groups used for the collider being built.\n     */\n    setCollisionGroups(groups) {\n        this.collisionGroups = groups;\n        return this;\n    }\n    /**\n     * Sets the solver groups used by this collider.\n     *\n     * Forces between two colliders in contact will be computed iff their solver\n     * groups are compatible.\n     * See the documentation of `InteractionGroups` for details on the used bit pattern.\n     *\n     * @param groups - The solver groups used for the collider being built.\n     */\n    setSolverGroups(groups) {\n        this.solverGroups = groups;\n        return this;\n    }\n    /**\n     * Set the physics hooks active for this collider.\n     *\n     * Use this to enable custom filtering rules for contact/intersecstion pairs involving this collider.\n     *\n     * @param activeHooks - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveHooks(activeHooks) {\n        this.activeHooks = activeHooks;\n        return this;\n    }\n    /**\n     * Set the events active for this collider.\n     *\n     * Use this to enable contact and/or intersection event reporting for this collider.\n     *\n     * @param activeEvents - The events active for contact/intersection pairs involving this collider.\n     */\n    setActiveEvents(activeEvents) {\n        this.activeEvents = activeEvents;\n        return this;\n    }\n    /**\n     * Set the collision types active for this collider.\n     *\n     * @param activeCollisionTypes - The hooks active for contact/intersection pairs involving this collider.\n     */\n    setActiveCollisionTypes(activeCollisionTypes) {\n        this.activeCollisionTypes = activeCollisionTypes;\n        return this;\n    }\n    /**\n     * Sets the total force magnitude beyond which a contact force event can be emitted.\n     *\n     * @param threshold - The force threshold to set.\n     */\n    setContactForceEventThreshold(threshold) {\n        this.contactForceEventThreshold = threshold;\n        return this;\n    }\n}\n//# sourceMappingURL=collider.js.map","export class Coarena {\n    constructor() {\n        this.fconv = new Float64Array(1);\n        this.uconv = new Uint32Array(this.fconv.buffer);\n        this.data = new Array();\n        this.size = 0;\n    }\n    set(handle, data) {\n        let i = this.index(handle);\n        while (this.data.length <= i) {\n            this.data.push(null);\n        }\n        if (this.data[i] == null)\n            this.size += 1;\n        this.data[i] = data;\n    }\n    len() {\n        return this.size;\n    }\n    delete(handle) {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            if (this.data[i] != null)\n                this.size -= 1;\n            this.data[i] = null;\n        }\n    }\n    clear() {\n        this.data = new Array();\n    }\n    get(handle) {\n        let i = this.index(handle);\n        if (i < this.data.length) {\n            return this.data[i];\n        }\n        else {\n            return null;\n        }\n    }\n    forEach(f) {\n        for (const elt of this.data) {\n            if (elt != null)\n                f(elt);\n        }\n    }\n    getAll() {\n        return this.data.filter((elt) => elt != null);\n    }\n    index(handle) {\n        /// Extracts the index part of a handle (the lower 32 bits).\n        /// This is done by first injecting the handle into an Float64Array\n        /// which is itself injected into an Uint32Array (at construction time).\n        /// The 0-th value of the Uint32Array will become the `number` integer\n        /// representation of the lower 32 bits.\n        /// Also `this.uconv[1]` then contains the generation number as a `number`,\n        /// which we dont really need.\n        this.fconv[0] = handle;\n        return this.uconv[0];\n    }\n}\n//# sourceMappingURL=coarena.js.map","import { RawRigidBodySet } from \"../raw\";\nimport { Coarena } from \"../coarena\";\nimport { VectorOps, RotationOps } from \"../math\";\nimport { RigidBody, } from \"./rigid_body\";\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `rigidBodySet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class RigidBodySet {\n    constructor(raw) {\n        this.raw = raw || new RawRigidBodySet();\n        this.map = new Coarena();\n        // deserialize\n        if (raw) {\n            raw.forEachRigidBodyHandle((handle) => {\n                this.map.set(handle, new RigidBody(raw, null, handle));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this rigid-body set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    /**\n     * Internal method, do not call this explicitly.\n     */\n    finalizeDeserialization(colliderSet) {\n        this.map.forEach((rb) => rb.finalizeDeserialization(colliderSet));\n    }\n    /**\n     * Creates a new rigid-body and return its integer handle.\n     *\n     * @param desc - The description of the rigid-body to create.\n     */\n    createRigidBody(colliderSet, desc) {\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawLv = VectorOps.intoRaw(desc.linvel);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n        // #if DIM3\n        let rawAv = VectorOps.intoRaw(desc.angvel);\n        let rawPrincipalInertia = VectorOps.intoRaw(desc.principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(desc.angularInertiaLocalFrame);\n        // #endif\n        let handle = this.raw.createRigidBody(desc.enabled, rawTra, rawRot, desc.gravityScale, desc.mass, desc.massOnly, rawCom, rawLv, \n        // #if DIM3\n        rawAv, rawPrincipalInertia, rawInertiaFrame, desc.translationsEnabledX, desc.translationsEnabledY, desc.translationsEnabledZ, desc.rotationsEnabledX, desc.rotationsEnabledY, desc.rotationsEnabledZ, \n        // #endif\n        desc.linearDamping, desc.angularDamping, desc.status, desc.canSleep, desc.sleeping, desc.ccdEnabled, desc.dominanceGroup, desc.additionalSolverIterations);\n        rawTra.free();\n        rawRot.free();\n        rawLv.free();\n        rawCom.free();\n        // #if DIM3\n        rawAv.free();\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n        // #endif\n        const body = new RigidBody(this.raw, colliderSet, handle);\n        body.userData = desc.userData;\n        this.map.set(handle, body);\n        return body;\n    }\n    /**\n     * Removes a rigid-body from this set.\n     *\n     * This will also remove all the colliders and joints attached to the rigid-body.\n     *\n     * @param handle - The integer handle of the rigid-body to remove.\n     * @param colliders - The set of colliders that may contain colliders attached to the removed rigid-body.\n     * @param impulseJoints - The set of impulse joints that may contain joints attached to the removed rigid-body.\n     * @param multibodyJoints - The set of multibody joints that may contain joints attached to the removed rigid-body.\n     */\n    remove(handle, islands, colliders, impulseJoints, multibodyJoints) {\n        // Unmap the entities that will be removed automatically because of the rigid-body removals.\n        for (let i = 0; i < this.raw.rbNumColliders(handle); i += 1) {\n            colliders.unmap(this.raw.rbCollider(handle, i));\n        }\n        impulseJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) => impulseJoints.unmap(handle));\n        multibodyJoints.forEachJointHandleAttachedToRigidBody(handle, (handle) => multibodyJoints.unmap(handle));\n        // Remove the rigid-body.\n        this.raw.remove(handle, islands.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw);\n        this.map.delete(handle);\n    }\n    /**\n     * The number of rigid-bodies on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a rigid-body with the given handle?\n     *\n     * @param handle - The rigid-body handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each rigid-body contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Applies the given closure to each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    forEachActiveRigidBody(islands, f) {\n        islands.forEachActiveRigidBodyHandle((handle) => {\n            f(this.get(handle));\n        });\n    }\n    /**\n     * Gets all rigid-bodies in the list.\n     *\n     * @returns rigid-bodies list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=rigid_body_set.js.map","import { RawIntegrationParameters } from \"../raw\";\nexport class IntegrationParameters {\n    constructor(raw) {\n        this.raw = raw || new RawIntegrationParameters();\n    }\n    /**\n     * Free the WASM memory used by these integration parameters.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * The timestep length (default: `1.0 / 60.0`)\n     */\n    get dt() {\n        return this.raw.dt;\n    }\n    /**\n     * The Error Reduction Parameter in `[0, 1]` is the proportion of\n     * the positional error to be corrected at each time step (default: `0.2`).\n     */\n    get erp() {\n        return this.raw.erp;\n    }\n    /**\n     * Amount of penetration the engine wont attempt to correct (default: `0.001m`).\n     */\n    get allowedLinearError() {\n        return this.raw.allowedLinearError;\n    }\n    /**\n     * The maximal distance separating two objects that will generate predictive contacts (default: `0.002`).\n     */\n    get predictionDistance() {\n        return this.raw.predictionDistance;\n    }\n    /**\n     * The number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    get numSolverIterations() {\n        return this.raw.numSolverIterations;\n    }\n    /**\n     * Number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    get numAdditionalFrictionIterations() {\n        return this.raw.numAdditionalFrictionIterations;\n    }\n    /**\n     * Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    get numInternalPgsIterations() {\n        return this.raw.numInternalPgsIterations;\n    }\n    /**\n     * Minimum number of dynamic bodies in each active island (default: `128`).\n     */\n    get minIslandSize() {\n        return this.raw.minIslandSize;\n    }\n    /**\n     * Maximum number of substeps performed by the  solver (default: `1`).\n     */\n    get maxCcdSubsteps() {\n        return this.raw.maxCcdSubsteps;\n    }\n    set dt(value) {\n        this.raw.dt = value;\n    }\n    set erp(value) {\n        this.raw.erp = value;\n    }\n    set allowedLinearError(value) {\n        this.raw.allowedLinearError = value;\n    }\n    set predictionDistance(value) {\n        this.raw.predictionDistance = value;\n    }\n    /**\n     * Sets the number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    set numSolverIterations(value) {\n        this.raw.numSolverIterations = value;\n    }\n    /**\n     * Sets the number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    set numAdditionalFrictionIterations(value) {\n        this.raw.numAdditionalFrictionIterations = value;\n    }\n    /**\n     * Sets the number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    set numInternalPgsIterations(value) {\n        this.raw.numInternalPgsIterations = value;\n    }\n    set minIslandSize(value) {\n        this.raw.minIslandSize = value;\n    }\n    set maxCcdSubsteps(value) {\n        this.raw.maxCcdSubsteps = value;\n    }\n    switchToStandardPgsSolver() {\n        this.raw.switchToStandardPgsSolver();\n    }\n    switchToSmallStepsPgsSolver() {\n        this.raw.switchToSmallStepsPgsSolver();\n    }\n}\n//# sourceMappingURL=integration_parameters.js.map","import { RawImpulseJointSet } from \"../raw\";\nimport { Coarena } from \"../coarena\";\nimport { ImpulseJoint,\n// #endif\n } from \"./impulse_joint\";\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class ImpulseJointSet {\n    constructor(raw) {\n        this.raw = raw || new RawImpulseJointSet();\n        this.map = new Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle) => {\n                this.map.set(handle, ImpulseJoint.newTyped(raw, null, handle));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        this.map.forEach((joint) => joint.finalizeDeserialization(bodies));\n    }\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param bodies - The set of rigid-bodies containing the bodies the joint is attached to.\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createJoint(bodies, desc, parent1, parent2, wakeUp) {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(rawParams, parent1, parent2, wakeUp);\n        rawParams.free();\n        let joint = ImpulseJoint.newTyped(this.raw, bodies, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wakeUp - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    remove(handle, wakeUp) {\n        this.raw.remove(handle, wakeUp);\n        this.unmap(handle);\n    }\n    /**\n     * Calls the given closure with the integer handle of each impulse joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each impulse joint attached to the rigid-body.\n     */\n    forEachJointHandleAttachedToRigidBody(handle, f) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * The number of joints on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=impulse_joint_set.js.map","import { RawJointAxis, RawJointType, } from \"../raw\";\nexport class MultibodyJoint {\n    constructor(rawSet, handle) {\n        this.rawSet = rawSet;\n        this.handle = handle;\n    }\n    static newTyped(rawSet, handle) {\n        switch (rawSet.jointType(handle)) {\n            case RawJointType.Revolute:\n                return new RevoluteMultibodyJoint(rawSet, handle);\n            case RawJointType.Prismatic:\n                return new PrismaticMultibodyJoint(rawSet, handle);\n            case RawJointType.Fixed:\n                return new FixedMultibodyJoint(rawSet, handle);\n            // #if DIM3\n            case RawJointType.Spherical:\n                return new SphericalMultibodyJoint(rawSet, handle);\n            // #endif\n            default:\n                return new MultibodyJoint(rawSet, handle);\n        }\n    }\n    /**\n     * Checks if this joint is still valid (i.e. that it has\n     * not been deleted from the joint set yet).\n     */\n    isValid() {\n        return this.rawSet.contains(this.handle);\n    }\n    // /**\n    //  * The unique integer identifier of the first rigid-body this joint it attached to.\n    //  */\n    // public bodyHandle1(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle1(this.handle);\n    // }\n    //\n    // /**\n    //  * The unique integer identifier of the second rigid-body this joint is attached to.\n    //  */\n    // public bodyHandle2(): RigidBodyHandle {\n    //     return this.rawSet.jointBodyHandle2(this.handle);\n    // }\n    //\n    // /**\n    //  * The type of this joint given as a string.\n    //  */\n    // public type(): JointType {\n    //     return this.rawSet.jointType(this.handle);\n    // }\n    //\n    // // #if DIM3\n    // /**\n    //  * The rotation quaternion that aligns this joint's first local axis to the `x` axis.\n    //  */\n    // public frameX1(): Rotation {\n    //     return RotationOps.fromRaw(this.rawSet.jointFrameX1(this.handle));\n    // }\n    //\n    // // #endif\n    //\n    // // #if DIM3\n    // /**\n    //  * The rotation matrix that aligns this joint's second local axis to the `x` axis.\n    //  */\n    // public frameX2(): Rotation {\n    //     return RotationOps.fromRaw(this.rawSet.jointFrameX2(this.handle));\n    // }\n    //\n    // // #endif\n    //\n    // /**\n    //  * The position of the first anchor of this joint.\n    //  *\n    //  * The first anchor gives the position of the points application point on the\n    //  * local frame of the first rigid-body it is attached to.\n    //  */\n    // public anchor1(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor1(this.handle));\n    // }\n    //\n    // /**\n    //  * The position of the second anchor of this joint.\n    //  *\n    //  * The second anchor gives the position of the points application point on the\n    //  * local frame of the second rigid-body it is attached to.\n    //  */\n    // public anchor2(): Vector {\n    //     return VectorOps.fromRaw(this.rawSet.jointAnchor2(this.handle));\n    // }\n    /**\n     * Controls whether contacts are computed between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    setContactsEnabled(enabled) {\n        this.rawSet.jointSetContactsEnabled(this.handle, enabled);\n    }\n    /**\n     * Indicates if contacts are enabled between colliders attached\n     * to the rigid-bodies linked by this joint.\n     */\n    contactsEnabled() {\n        return this.rawSet.jointContactsEnabled(this.handle);\n    }\n}\nexport class UnitMultibodyJoint extends MultibodyJoint {\n}\nexport class FixedMultibodyJoint extends MultibodyJoint {\n}\nexport class PrismaticMultibodyJoint extends UnitMultibodyJoint {\n    rawAxis() {\n        return RawJointAxis.X;\n    }\n}\nexport class RevoluteMultibodyJoint extends UnitMultibodyJoint {\n    rawAxis() {\n        return RawJointAxis.AngX;\n    }\n}\n// #if DIM3\nexport class SphericalMultibodyJoint extends MultibodyJoint {\n}\n// #endif\n//# sourceMappingURL=multibody_joint.js.map","import { RawMultibodyJointSet } from \"../raw\";\nimport { Coarena } from \"../coarena\";\nimport { MultibodyJoint,\n// #endif\n } from \"./multibody_joint\";\n/**\n * A set of joints.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `jointSet.free()`\n * once you are done using it (and all the joints it created).\n */\nexport class MultibodyJointSet {\n    constructor(raw) {\n        this.raw = raw || new RawMultibodyJointSet();\n        this.map = new Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachJointHandle((handle) => {\n                this.map.set(handle, MultibodyJoint.newTyped(this.raw, handle));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this joint set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    /**\n     * Creates a new joint and return its integer handle.\n     *\n     * @param desc - The joint's parameters.\n     * @param parent1 - The handle of the first rigid-body this joint is attached to.\n     * @param parent2 - The handle of the second rigid-body this joint is attached to.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createJoint(desc, parent1, parent2, wakeUp) {\n        const rawParams = desc.intoRaw();\n        const handle = this.raw.createJoint(rawParams, parent1, parent2, wakeUp);\n        rawParams.free();\n        let joint = MultibodyJoint.newTyped(this.raw, handle);\n        this.map.set(handle, joint);\n        return joint;\n    }\n    /**\n     * Remove a joint from this set.\n     *\n     * @param handle - The integer handle of the joint.\n     * @param wake_up - If `true`, the rigid-bodies attached by the removed joint will be woken-up automatically.\n     */\n    remove(handle, wake_up) {\n        this.raw.remove(handle, wake_up);\n        this.map.delete(handle);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * The number of joints on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a joint with the given handle?\n     *\n     * @param handle - The joint handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Gets the joint with the given handle.\n     *\n     * Returns `null` if no joint with the specified handle exists.\n     *\n     * @param handle - The integer handle of the joint to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * Applies the given closure to each joint contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Calls the given closure with the integer handle of each multibody joint attached to this rigid-body.\n     *\n     * @param f - The closure called with the integer handle of each multibody joint attached to the rigid-body.\n     */\n    forEachJointHandleAttachedToRigidBody(handle, f) {\n        this.raw.forEachJointAttachedToRigidBody(handle, f);\n    }\n    /**\n     * Gets all joints in the list.\n     *\n     * @returns joint list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=multibody_joint_set.js.map","import { RawCCDSolver } from \"../raw\";\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class CCDSolver {\n    constructor(raw) {\n        this.raw = raw || new RawCCDSolver();\n    }\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n}\n//# sourceMappingURL=ccd_solver.js.map","import { RawIslandManager } from \"../raw\";\n/**\n * The CCD solver responsible for resolving Continuous Collision Detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `ccdSolver.free()`\n * once you are done using it.\n */\nexport class IslandManager {\n    constructor(raw) {\n        this.raw = raw || new RawIslandManager();\n    }\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Applies the given closure to the handle of each active rigid-bodies contained by this set.\n     *\n     * A rigid-body is active if it is not sleeping, i.e., if it moved recently.\n     *\n     * @param f - The closure to apply.\n     */\n    forEachActiveRigidBodyHandle(f) {\n        this.raw.forEachActiveRigidBodyHandle(f);\n    }\n}\n//# sourceMappingURL=island_manager.js.map","import { RawBroadPhase } from \"../raw\";\n/**\n * The broad-phase used for coarse collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `broadPhase.free()`\n * once you are done using it.\n */\nexport class BroadPhase {\n    constructor(raw) {\n        this.raw = raw || new RawBroadPhase();\n    }\n    /**\n     * Release the WASM memory occupied by this broad-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n}\n//# sourceMappingURL=broad_phase.js.map","import { RawNarrowPhase } from \"../raw\";\nimport { VectorOps } from \"../math\";\n/**\n * The narrow-phase used for precise collision-detection.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `narrowPhase.free()`\n * once you are done using it.\n */\nexport class NarrowPhase {\n    constructor(raw) {\n        this.raw = raw || new RawNarrowPhase();\n        this.tempManifold = new TempContactManifold(null);\n    }\n    /**\n     * Release the WASM memory occupied by this narrow-phase.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    contactPairsWith(collider1, f) {\n        this.raw.contact_pairs_with(collider1, f);\n    }\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    intersectionPairsWith(collider1, f) {\n        this.raw.intersection_pairs_with(collider1, f);\n    }\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    contactPair(collider1, collider2, f) {\n        const rawPair = this.raw.contact_pair(collider1, collider2);\n        if (!!rawPair) {\n            const flipped = rawPair.collider1() != collider1;\n            let i;\n            for (i = 0; i < rawPair.numContactManifolds(); ++i) {\n                this.tempManifold.raw = rawPair.contactManifold(i);\n                if (!!this.tempManifold.raw) {\n                    f(this.tempManifold, flipped);\n                }\n                // SAFETY: The RawContactManifold stores a raw pointer that will be invalidated\n                //         at the next timestep. So we must be sure to free the pair here\n                //         to avoid unsoundness in the Rust code.\n                this.tempManifold.free();\n            }\n            rawPair.free();\n        }\n    }\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1  The first collider involved in the intersection.\n     * @param collider2  The second collider involved in the intersection.\n     */\n    intersectionPair(collider1, collider2) {\n        return this.raw.intersection_pair(collider1, collider2);\n    }\n}\nexport class TempContactManifold {\n    constructor(raw) {\n        this.raw = raw;\n    }\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    normal() {\n        return VectorOps.fromRaw(this.raw.normal());\n    }\n    localNormal1() {\n        return VectorOps.fromRaw(this.raw.local_n1());\n    }\n    localNormal2() {\n        return VectorOps.fromRaw(this.raw.local_n2());\n    }\n    subshape1() {\n        return this.raw.subshape1();\n    }\n    subshape2() {\n        return this.raw.subshape2();\n    }\n    numContacts() {\n        return this.raw.num_contacts();\n    }\n    localContactPoint1(i) {\n        return VectorOps.fromRaw(this.raw.contact_local_p1(i));\n    }\n    localContactPoint2(i) {\n        return VectorOps.fromRaw(this.raw.contact_local_p2(i));\n    }\n    contactDist(i) {\n        return this.raw.contact_dist(i);\n    }\n    contactFid1(i) {\n        return this.raw.contact_fid1(i);\n    }\n    contactFid2(i) {\n        return this.raw.contact_fid2(i);\n    }\n    contactImpulse(i) {\n        return this.raw.contact_impulse(i);\n    }\n    // #if DIM3\n    contactTangentImpulseX(i) {\n        return this.raw.contact_tangent_impulse_x(i);\n    }\n    contactTangentImpulseY(i) {\n        return this.raw.contact_tangent_impulse_y(i);\n    }\n    // #endif\n    numSolverContacts() {\n        return this.raw.num_solver_contacts();\n    }\n    solverContactPoint(i) {\n        return VectorOps.fromRaw(this.raw.solver_contact_point(i));\n    }\n    solverContactDist(i) {\n        return this.raw.solver_contact_dist(i);\n    }\n    solverContactFriction(i) {\n        return this.raw.solver_contact_friction(i);\n    }\n    solverContactRestitution(i) {\n        return this.raw.solver_contact_restitution(i);\n    }\n    solverContactTangentVelocity(i) {\n        return VectorOps.fromRaw(this.raw.solver_contact_tangent_velocity(i));\n    }\n}\n//# sourceMappingURL=narrow_phase.js.map","import { VectorOps } from \"../math\";\n/**\n * The contact info between two shapes.\n */\nexport class ShapeContact {\n    constructor(dist, point1, point2, normal1, normal2) {\n        this.distance = dist;\n        this.point1 = point1;\n        this.point2 = point2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new ShapeContact(raw.distance(), VectorOps.fromRaw(raw.point1()), VectorOps.fromRaw(raw.point2()), VectorOps.fromRaw(raw.normal1()), VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=contact.js.map","import { VectorOps } from \"../math\";\nimport { FeatureType } from \"./feature\";\n/**\n * The projection of a point on a collider.\n */\nexport class PointProjection {\n    constructor(point, isInside) {\n        this.point = point;\n        this.isInside = isInside;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new PointProjection(VectorOps.fromRaw(raw.point()), raw.isInside());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The projection of a point on a collider (includes the collider handle).\n */\nexport class PointColliderProjection {\n    constructor(collider, point, isInside, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.collider = collider;\n        this.point = point;\n        this.isInside = isInside;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new PointColliderProjection(colliderSet.get(raw.colliderHandle()), VectorOps.fromRaw(raw.point()), raw.isInside(), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=point.js.map","import { VectorOps } from \"../math\";\nimport { FeatureType } from \"./feature\";\n/**\n * A ray. This is a directed half-line.\n */\nexport class Ray {\n    /**\n     * Builds a ray from its origin and direction.\n     *\n     * @param origin - The ray's starting point.\n     * @param dir - The ray's direction of propagation.\n     */\n    constructor(origin, dir) {\n        this.origin = origin;\n        this.dir = dir;\n    }\n    pointAt(t) {\n        return {\n            x: this.origin.x + this.dir.x * t,\n            y: this.origin.y + this.dir.y * t,\n            // #if DIM3\n            z: this.origin.z + this.dir.z * t,\n            // #endif\n        };\n    }\n}\n/**\n * The intersection between a ray and a collider.\n */\nexport class RayIntersection {\n    constructor(toi, normal, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.toi = toi;\n        this.normal = normal;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        const result = new RayIntersection(raw.toi(), VectorOps.fromRaw(raw.normal()), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The intersection between a ray and a collider (includes the collider handle).\n */\nexport class RayColliderIntersection {\n    constructor(collider, toi, normal, featureType, featureId) {\n        /**\n         * The type of the geometric feature the point was projected on.\n         */\n        this.featureType = FeatureType.Unknown;\n        /**\n         * The id of the geometric feature the point was projected on.\n         */\n        this.featureId = undefined;\n        this.collider = collider;\n        this.toi = toi;\n        this.normal = normal;\n        if (featureId !== undefined)\n            this.featureId = featureId;\n        if (featureType !== undefined)\n            this.featureType = featureType;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new RayColliderIntersection(colliderSet.get(raw.colliderHandle()), raw.toi(), VectorOps.fromRaw(raw.normal()), raw.featureType(), raw.featureId());\n        raw.free();\n        return result;\n    }\n}\n/**\n * The time of impact between a ray and a collider.\n */\nexport class RayColliderToi {\n    constructor(collider, toi) {\n        this.collider = collider;\n        this.toi = toi;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new RayColliderToi(colliderSet.get(raw.colliderHandle()), raw.toi());\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=ray.js.map","import { VectorOps } from \"../math\";\n/**\n * The intersection between a ray and a collider.\n */\nexport class ShapeTOI {\n    constructor(toi, witness1, witness2, normal1, normal2) {\n        this.toi = toi;\n        this.witness1 = witness1;\n        this.witness2 = witness2;\n        this.normal1 = normal1;\n        this.normal2 = normal2;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new ShapeTOI(raw.toi(), VectorOps.fromRaw(raw.witness1()), VectorOps.fromRaw(raw.witness2()), VectorOps.fromRaw(raw.normal1()), VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n/**\n * The intersection between a ray and a collider.\n */\nexport class ShapeColliderTOI extends ShapeTOI {\n    constructor(collider, toi, witness1, witness2, normal1, normal2) {\n        super(toi, witness1, witness2, normal1, normal2);\n        this.collider = collider;\n    }\n    static fromRaw(colliderSet, raw) {\n        if (!raw)\n            return null;\n        const result = new ShapeColliderTOI(colliderSet.get(raw.colliderHandle()), raw.toi(), VectorOps.fromRaw(raw.witness1()), VectorOps.fromRaw(raw.witness2()), VectorOps.fromRaw(raw.normal1()), VectorOps.fromRaw(raw.normal2()));\n        raw.free();\n        return result;\n    }\n}\n//# sourceMappingURL=toi.js.map","import { RawPhysicsPipeline } from \"../raw\";\nimport { VectorOps } from \"../math\";\nexport class PhysicsPipeline {\n    constructor(raw) {\n        this.raw = raw || new RawPhysicsPipeline();\n    }\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    step(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulseJoints, multibodyJoints, ccdSolver, eventQueue, hooks) {\n        let rawG = VectorOps.intoRaw(gravity);\n        if (!!eventQueue) {\n            this.raw.stepWithEvents(rawG, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw, ccdSolver.raw, eventQueue.raw, hooks, !!hooks ? hooks.filterContactPair : null, !!hooks ? hooks.filterIntersectionPair : null);\n        }\n        else {\n            this.raw.step(rawG, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw, ccdSolver.raw);\n        }\n        rawG.free();\n    }\n}\n//# sourceMappingURL=physics_pipeline.js.map","import { RawSerializationPipeline } from \"../raw\";\nimport { VectorOps } from \"../math\";\nimport { World } from \"./world\";\n/**\n * A pipeline for serializing the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `queryPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class SerializationPipeline {\n    constructor(raw) {\n        this.raw = raw || new RawSerializationPipeline();\n    }\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Serialize a complete physics state into a single byte array.\n     * @param gravity - The current gravity affecting the simulation.\n     * @param integrationParameters - The integration parameters of the simulation.\n     * @param broadPhase - The broad-phase of the simulation.\n     * @param narrowPhase - The narrow-phase of the simulation.\n     * @param bodies - The rigid-bodies taking part into the simulation.\n     * @param colliders - The colliders taking part into the simulation.\n     * @param impulseJoints - The impulse joints taking part into the simulation.\n     * @param multibodyJoints - The multibody joints taking part into the simulation.\n     */\n    serializeAll(gravity, integrationParameters, islands, broadPhase, narrowPhase, bodies, colliders, impulseJoints, multibodyJoints) {\n        let rawGra = VectorOps.intoRaw(gravity);\n        const res = this.raw.serializeAll(rawGra, integrationParameters.raw, islands.raw, broadPhase.raw, narrowPhase.raw, bodies.raw, colliders.raw, impulseJoints.raw, multibodyJoints.raw);\n        rawGra.free();\n        return res;\n    }\n    /**\n     * Deserialize the complete physics state from a single byte array.\n     *\n     * @param data - The byte array to deserialize.\n     */\n    deserializeAll(data) {\n        return World.fromRaw(this.raw.deserializeAll(data));\n    }\n}\n//# sourceMappingURL=serialization_pipeline.js.map","import { RawDebugRenderPipeline } from \"../raw\";\n/**\n * The vertex and color buffers for debug-redering the physics scene.\n */\nexport class DebugRenderBuffers {\n    constructor(vertices, colors) {\n        this.vertices = vertices;\n        this.colors = colors;\n    }\n}\n/**\n * A pipeline for rendering the physics scene.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `debugRenderPipeline.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class DebugRenderPipeline {\n    constructor(raw) {\n        this.raw = raw || new RawDebugRenderPipeline();\n    }\n    /**\n     * Release the WASM memory occupied by this serialization pipeline.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        this.vertices = undefined;\n        this.colors = undefined;\n    }\n    render(bodies, colliders, impulse_joints, multibody_joints, narrow_phase) {\n        this.raw.render(bodies.raw, colliders.raw, impulse_joints.raw, multibody_joints.raw, narrow_phase.raw);\n        this.vertices = this.raw.vertices();\n        this.colors = this.raw.colors();\n    }\n}\n//# sourceMappingURL=debug_render_pipeline.js.map","import { RawKinematicCharacterController, RawCharacterCollision } from \"../raw\";\nimport { VectorOps } from \"../math\";\n/**\n * A collision between the character and an obstacle hit on its path.\n */\nexport class CharacterCollision {\n}\n/**\n * A character controller for controlling kinematic bodies and parentless colliders by hitting\n * and sliding against obstacles.\n */\nexport class KinematicCharacterController {\n    constructor(offset, params, bodies, colliders, queries) {\n        this.params = params;\n        this.bodies = bodies;\n        this.colliders = colliders;\n        this.queries = queries;\n        this.raw = new RawKinematicCharacterController(offset);\n        this.rawCharacterCollision = new RawCharacterCollision();\n        this._applyImpulsesToDynamicBodies = false;\n        this._characterMass = null;\n    }\n    /** @internal */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n            this.rawCharacterCollision.free();\n        }\n        this.raw = undefined;\n        this.rawCharacterCollision = undefined;\n    }\n    /**\n     * The direction that goes \"up\". Used to determine where the floor is, and the floors angle.\n     */\n    up() {\n        return this.raw.up();\n    }\n    /**\n     * Sets the direction that goes \"up\". Used to determine where the floor is, and the floors angle.\n     */\n    setUp(vector) {\n        let rawVect = VectorOps.intoRaw(vector);\n        return this.raw.setUp(rawVect);\n        rawVect.free();\n    }\n    applyImpulsesToDynamicBodies() {\n        return this._applyImpulsesToDynamicBodies;\n    }\n    setApplyImpulsesToDynamicBodies(enabled) {\n        this._applyImpulsesToDynamicBodies = enabled;\n    }\n    /**\n     * Returns the custom value of the character mass, if it was set by `this.setCharacterMass`.\n     */\n    characterMass() {\n        return this._characterMass;\n    }\n    /**\n     * Set the mass of the character to be used for impulse resolution if `self.applyImpulsesToDynamicBodies`\n     * is set to `true`.\n     *\n     * If no character mass is set explicitly (or if it is set to `null`) it is automatically assumed to be equal\n     * to the mass of the rigid-body the character collider is attached to; or equal to 0 if the character collider\n     * isnt attached to any rigid-body.\n     *\n     * @param mass - The mass to set.\n     */\n    setCharacterMass(mass) {\n        this._characterMass = mass;\n    }\n    /**\n     * A small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldnt be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    offset() {\n        return this.raw.offset();\n    }\n    /**\n     * Sets a small gap to preserve between the character and its surroundings.\n     *\n     * This value should not be too large to avoid visual artifacts, but shouldnt be too small\n     * (must not be zero) to improve numerical stability of the character controller.\n     */\n    setOffset(value) {\n        this.raw.setOffset(value);\n    }\n    /**\n     * Is sliding against obstacles enabled?\n     */\n    slideEnabled() {\n        return this.raw.slideEnabled();\n    }\n    /**\n     * Enable or disable sliding against obstacles.\n     */\n    setSlideEnabled(enabled) {\n        this.raw.setSlideEnabled(enabled);\n    }\n    /**\n     * The maximum step height a character can automatically step over.\n     */\n    autostepMaxHeight() {\n        return this.raw.autostepMaxHeight();\n    }\n    /**\n     * The minimum width of free space that must be available after stepping on a stair.\n     */\n    autostepMinWidth() {\n        return this.raw.autostepMinWidth();\n    }\n    /**\n     * Can the character automatically step over dynamic bodies too?\n     */\n    autostepIncludesDynamicBodies() {\n        return this.raw.autostepIncludesDynamicBodies();\n    }\n    /**\n     * Is automatically stepping over small objects enabled?\n     */\n    autostepEnabled() {\n        return this.raw.autostepEnabled();\n    }\n    /**\n     * Enabled automatically stepping over small objects.\n     *\n     * @param maxHeight - The maximum step height a character can automatically step over.\n     * @param minWidth - The minimum width of free space that must be available after stepping on a stair.\n     * @param includeDynamicBodies - Can the character automatically step over dynamic bodies too?\n     */\n    enableAutostep(maxHeight, minWidth, includeDynamicBodies) {\n        this.raw.enableAutostep(maxHeight, minWidth, includeDynamicBodies);\n    }\n    /**\n     * Disable automatically stepping over small objects.\n     */\n    disableAutostep() {\n        return this.raw.disableAutostep();\n    }\n    /**\n     * The maximum angle (radians) between the floors normal and the `up` vector that the\n     * character is able to climb.\n     */\n    maxSlopeClimbAngle() {\n        return this.raw.maxSlopeClimbAngle();\n    }\n    /**\n     * Sets the maximum angle (radians) between the floors normal and the `up` vector that the\n     * character is able to climb.\n     */\n    setMaxSlopeClimbAngle(angle) {\n        this.raw.setMaxSlopeClimbAngle(angle);\n    }\n    /**\n     * The minimum angle (radians) between the floors normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    minSlopeSlideAngle() {\n        return this.raw.minSlopeSlideAngle();\n    }\n    /**\n     * Sets the minimum angle (radians) between the floors normal and the `up` vector before the\n     * character starts to slide down automatically.\n     */\n    setMinSlopeSlideAngle(angle) {\n        this.raw.setMinSlopeSlideAngle(angle);\n    }\n    /**\n     * If snap-to-ground is enabled, should the character be automatically snapped to the ground if\n     * the distance between the ground and its feet are smaller than the specified threshold?\n     */\n    snapToGroundDistance() {\n        return this.raw.snapToGroundDistance();\n    }\n    /**\n     * Enables automatically snapping the character to the ground if the distance between\n     * the ground and its feet are smaller than the specified threshold.\n     */\n    enableSnapToGround(distance) {\n        this.raw.enableSnapToGround(distance);\n    }\n    /**\n     * Disables automatically snapping the character to the ground.\n     */\n    disableSnapToGround() {\n        this.raw.disableSnapToGround();\n    }\n    /**\n     * Is automatically snapping the character to the ground enabled?\n     */\n    snapToGroundEnabled() {\n        return this.raw.snapToGroundEnabled();\n    }\n    /**\n     * Computes the movement the given collider is able to execute after hitting and sliding on obstacles.\n     *\n     * @param collider - The collider to move.\n     * @param desiredTranslationDelta - The desired collider movement.\n     * @param filterFlags - Flags for excluding whole subsets of colliders from the obstacles taken into account.\n     * @param filterGroups - Groups for excluding colliders with incompatible collision groups from the obstacles\n     *                       taken into account.\n     * @param filterPredicate - Any collider for which this closure returns `false` will be excluded from the\n     *                          obstacles taken into account.\n     */\n    computeColliderMovement(collider, desiredTranslationDelta, filterFlags, filterGroups, filterPredicate) {\n        let rawTranslationDelta = VectorOps.intoRaw(desiredTranslationDelta);\n        this.raw.computeColliderMovement(this.params.dt, this.bodies.raw, this.colliders.raw, this.queries.raw, collider.handle, rawTranslationDelta, this._applyImpulsesToDynamicBodies, this._characterMass, filterFlags, filterGroups, this.colliders.castClosure(filterPredicate));\n        rawTranslationDelta.free();\n    }\n    /**\n     * The movement computed by the last call to `this.computeColliderMovement`.\n     */\n    computedMovement() {\n        return VectorOps.fromRaw(this.raw.computedMovement());\n    }\n    /**\n     * The result of ground detection computed by the last call to `this.computeColliderMovement`.\n     */\n    computedGrounded() {\n        return this.raw.computedGrounded();\n    }\n    /**\n     * The number of collisions against obstacles detected along the path of the last call\n     * to `this.computeColliderMovement`.\n     */\n    numComputedCollisions() {\n        return this.raw.numComputedCollisions();\n    }\n    /**\n     * Returns the collision against one of the obstacles detected along the path of the last\n     * call to `this.computeColliderMovement`.\n     *\n     * @param i - The i-th collision will be returned.\n     * @param out - If this argument is set, it will be filled with the collision information.\n     */\n    computedCollision(i, out) {\n        if (!this.raw.computedCollision(i, this.rawCharacterCollision)) {\n            return null;\n        }\n        else {\n            let c = this.rawCharacterCollision;\n            out = out !== null && out !== void 0 ? out : new CharacterCollision();\n            out.translationDeltaApplied = VectorOps.fromRaw(c.translationDeltaApplied());\n            out.translationDeltaRemaining = VectorOps.fromRaw(c.translationDeltaRemaining());\n            out.toi = c.toi();\n            out.witness1 = VectorOps.fromRaw(c.worldWitness1());\n            out.witness2 = VectorOps.fromRaw(c.worldWitness2());\n            out.normal1 = VectorOps.fromRaw(c.worldNormal1());\n            out.normal2 = VectorOps.fromRaw(c.worldNormal2());\n            out.collider = this.colliders.get(c.handle());\n            return out;\n        }\n    }\n}\n//# sourceMappingURL=character_controller.js.map","import { RawDynamicRayCastVehicleController } from \"../raw\";\nimport { VectorOps } from \"../math\";\n/**\n * A character controller to simulate vehicles using ray-casting for the wheels.\n */\nexport class DynamicRayCastVehicleController {\n    constructor(chassis, bodies, colliders, queries) {\n        this.raw = new RawDynamicRayCastVehicleController(chassis.handle);\n        this.bodies = bodies;\n        this.colliders = colliders;\n        this.queries = queries;\n        this._chassis = chassis;\n    }\n    /** @internal */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n    }\n    /**\n     * Updates the vehicles velocity based on its suspension, engine force, and brake.\n     *\n     * This directly updates the velocity of its chassis rigid-body.\n     *\n     * @param dt - Time increment used to integrate forces.\n     * @param filterFlags - Flag to exclude categories of objects from the wheels ray-cast.\n     * @param filterGroups - Only colliders compatible with these groups will be hit by the wheels ray-casts.\n     * @param filterPredicate - Callback to filter out which collider will be hit by the wheels ray-casts.\n     */\n    updateVehicle(dt, filterFlags, filterGroups, filterPredicate) {\n        this.raw.update_vehicle(dt, this.bodies.raw, this.colliders.raw, this.queries.raw, filterFlags, filterGroups, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * The current forward speed of the vehicle.\n     */\n    currentVehicleSpeed() {\n        return this.raw.current_vehicle_speed();\n    }\n    /**\n     * The rigid-body used as the chassis.\n     */\n    chassis() {\n        return this._chassis;\n    }\n    /**\n     * The chassis local _up_ direction (`0 = x, 1 = y, 2 = z`).\n     */\n    get indexUpAxis() {\n        return this.raw.index_up_axis();\n    }\n    /**\n     * Sets the chassis local _up_ direction (`0 = x, 1 = y, 2 = z`).\n     */\n    set indexUpAxis(axis) {\n        this.raw.set_index_up_axis(axis);\n    }\n    /**\n     * The chassis local _forward_ direction (`0 = x, 1 = y, 2 = z`).\n     */\n    get indexForwardAxis() {\n        return this.raw.index_forward_axis();\n    }\n    /**\n     * Sets the chassis local _forward_ direction (`0 = x, 1 = y, 2 = z`).\n     */\n    set setIndexForwardAxis(axis) {\n        this.raw.set_index_forward_axis(axis);\n    }\n    /**\n     * Adds a new wheel attached to this vehicle.\n     * @param chassisConnectionCs  - The position of the wheel relative to the chassis.\n     * @param directionCs - The direction of the wheels suspension, relative to the chassis. The ray-casting will\n     *                      happen following this direction to detect the ground.\n     * @param axleCs - The wheels axle axis, relative to the chassis.\n     * @param suspensionRestLength - The rest length of the wheels suspension spring.\n     * @param radius - The wheels radius.\n     */\n    addWheel(chassisConnectionCs, directionCs, axleCs, suspensionRestLength, radius) {\n        let rawChassisConnectionCs = VectorOps.intoRaw(chassisConnectionCs);\n        let rawDirectionCs = VectorOps.intoRaw(directionCs);\n        let rawAxleCs = VectorOps.intoRaw(axleCs);\n        this.raw.add_wheel(rawChassisConnectionCs, rawDirectionCs, rawAxleCs, suspensionRestLength, radius);\n        rawChassisConnectionCs.free();\n        rawDirectionCs.free();\n        rawAxleCs.free();\n    }\n    /**\n     * The number of wheels attached to this vehicle.\n     */\n    numWheels() {\n        return this.raw.num_wheels();\n    }\n    /*\n     *\n     * Access to wheel properties.\n     *\n     */\n    /*\n     * Getters + setters\n     */\n    /**\n     * The position of the i-th wheel, relative to the chassis.\n     */\n    wheelChassisConnectionPointCs(i) {\n        return VectorOps.fromRaw(this.raw.wheel_chassis_connection_point_cs(i));\n    }\n    /**\n     * Sets the position of the i-th wheel, relative to the chassis.\n     */\n    setWheelChassisConnectionPointCs(i, value) {\n        let rawValue = VectorOps.intoRaw(value);\n        this.raw.set_wheel_chassis_connection_point_cs(i, rawValue);\n        rawValue.free();\n    }\n    /**\n     * The rest length of the i-th wheels suspension spring.\n     */\n    wheelSuspensionRestLength(i) {\n        return this.raw.wheel_suspension_rest_length(i);\n    }\n    /**\n     * Sets the rest length of the i-th wheels suspension spring.\n     */\n    setWheelSuspensionRestLength(i, value) {\n        this.raw.set_wheel_suspension_rest_length(i, value);\n    }\n    /**\n     * The maximum distance the i-th wheel suspension can travel before and after its resting length.\n     */\n    wheelMaxSuspensionTravel(i) {\n        return this.raw.wheel_max_suspension_travel(i);\n    }\n    /**\n     * Sets the maximum distance the i-th wheel suspension can travel before and after its resting length.\n     */\n    setWheelMaxSuspensionTravel(i, value) {\n        this.raw.set_wheel_max_suspension_travel(i, value);\n    }\n    /**\n     * The i-th wheels radius.\n     */\n    wheelRadius(i) {\n        return this.raw.wheel_radius(i);\n    }\n    /**\n     * Sets the i-th wheels radius.\n     */\n    setWheelRadius(i, value) {\n        this.raw.set_wheel_radius(i, value);\n    }\n    /**\n     * The i-th wheels suspension stiffness.\n     *\n     * Increase this value if the suspension appears to not push the vehicle strong enough.\n     */\n    wheelSuspensionStiffness(i) {\n        return this.raw.wheel_suspension_stiffness(i);\n    }\n    /**\n     * Sets the i-th wheels suspension stiffness.\n     *\n     * Increase this value if the suspension appears to not push the vehicle strong enough.\n     */\n    setWheelSuspensionStiffness(i, value) {\n        this.raw.set_wheel_suspension_stiffness(i, value);\n    }\n    /**\n     * The i-th wheels suspensions damping when it is being compressed.\n     */\n    wheelSuspensionCompression(i) {\n        return this.raw.wheel_suspension_compression(i);\n    }\n    /**\n     * The i-th wheels suspensions damping when it is being compressed.\n     */\n    setWheelSuspensionCompression(i, value) {\n        this.raw.set_wheel_suspension_compression(i, value);\n    }\n    /**\n     * The i-th wheels suspensions damping when it is being released.\n     *\n     * Increase this value if the suspension appears to overshoot.\n     */\n    wheelSuspensionRelaxation(i) {\n        return this.raw.wheel_suspension_relaxation(i);\n    }\n    /**\n     * Sets the i-th wheels suspensions damping when it is being released.\n     *\n     * Increase this value if the suspension appears to overshoot.\n     */\n    setWheelSuspensionRelaxation(i, value) {\n        this.raw.set_wheel_suspension_relaxation(i, value);\n    }\n    /**\n     * The maximum force applied by the i-th wheels suspension.\n     */\n    wheelMaxSuspensionForce(i) {\n        return this.raw.wheel_max_suspension_force(i);\n    }\n    /**\n     * Sets the maximum force applied by the i-th wheels suspension.\n     */\n    setWheelMaxSuspensionForce(i, value) {\n        this.raw.set_wheel_max_suspension_force(i, value);\n    }\n    /**\n     * The maximum amount of braking impulse applied on the i-th wheel to slow down the vehicle.\n     */\n    wheelBrake(i) {\n        return this.raw.wheel_brake(i);\n    }\n    /**\n     * Set the maximum amount of braking impulse applied on the i-th wheel to slow down the vehicle.\n     */\n    setWheelBrake(i, value) {\n        this.raw.set_wheel_brake(i, value);\n    }\n    /**\n     * The steering angle (radians) for the i-th wheel.\n     */\n    wheelSteering(i) {\n        return this.raw.wheel_steering(i);\n    }\n    /**\n     * Sets the steering angle (radians) for the i-th wheel.\n     */\n    setWheelSteering(i, value) {\n        this.raw.set_wheel_steering(i, value);\n    }\n    /**\n     * The forward force applied by the i-th wheel on the chassis.\n     */\n    wheelEngineForce(i) {\n        return this.raw.wheel_engine_force(i);\n    }\n    /**\n     * Sets the forward force applied by the i-th wheel on the chassis.\n     */\n    setWheelEngineForce(i, value) {\n        this.raw.set_wheel_engine_force(i, value);\n    }\n    /**\n     * The direction of the i-th wheels suspension, relative to the chassis.\n     *\n     * The ray-casting will happen following this direction to detect the ground.\n     */\n    wheelDirectionCs(i) {\n        return VectorOps.fromRaw(this.raw.wheel_direction_cs(i));\n    }\n    /**\n     * Sets the direction of the i-th wheels suspension, relative to the chassis.\n     *\n     * The ray-casting will happen following this direction to detect the ground.\n     */\n    setWheelDirectionCs(i, value) {\n        let rawValue = VectorOps.intoRaw(value);\n        this.raw.set_wheel_direction_cs(i, rawValue);\n        rawValue.free();\n    }\n    /**\n     * The i-th wheels axle axis, relative to the chassis.\n     *\n     * The axis index defined as 0 = X, 1 = Y, 2 = Z.\n     */\n    wheelAxleCs(i) {\n        return VectorOps.fromRaw(this.raw.wheel_axle_cs(i));\n    }\n    /**\n     * Sets the i-th wheels axle axis, relative to the chassis.\n     *\n     * The axis index defined as 0 = X, 1 = Y, 2 = Z.\n     */\n    setWheelAxleCs(i, value) {\n        let rawValue = VectorOps.intoRaw(value);\n        this.raw.set_wheel_axle_cs(i, rawValue);\n        rawValue.free();\n    }\n    /**\n     * Parameter controlling how much traction the tire has.\n     *\n     * The larger the value, the more instantaneous braking will happen (with the risk of\n     * causing the vehicle to flip if its too strong).\n     */\n    wheelFrictionSlip(i) {\n        return this.raw.wheel_friction_slip(i);\n    }\n    /**\n     * Sets the parameter controlling how much traction the tire has.\n     *\n     * The larger the value, the more instantaneous braking will happen (with the risk of\n     * causing the vehicle to flip if its too strong).\n     */\n    setWheelFrictionSlip(i, value) {\n        this.raw.set_wheel_friction_slip(i, value);\n    }\n    /**\n     * The multiplier of friction between a tire and the collider its on top of.\n     *\n     * The larger the value, the stronger side friction will be.\n     */\n    wheelSideFrictionStiffness(i) {\n        return this.raw.wheel_side_friction_stiffness(i);\n    }\n    /**\n     * The multiplier of friction between a tire and the collider its on top of.\n     *\n     * The larger the value, the stronger side friction will be.\n     */\n    setWheelSideFrictionStiffness(i, value) {\n        this.raw.set_wheel_side_friction_stiffness(i, value);\n    }\n    /*\n     * Getters only.\n     */\n    /**\n     *  The i-th wheels current rotation angle (radians) on its axle.\n     */\n    wheelRotation(i) {\n        return this.raw.wheel_rotation(i);\n    }\n    /**\n     *  The forward impulses applied by the i-th wheel on the chassis.\n     */\n    wheelForwardImpulse(i) {\n        return this.raw.wheel_forward_impulse(i);\n    }\n    /**\n     *  The side impulses applied by the i-th wheel on the chassis.\n     */\n    wheelSideImpulse(i) {\n        return this.raw.wheel_side_impulse(i);\n    }\n    /**\n     *  The force applied by the i-th wheel suspension.\n     */\n    wheelSuspensionForce(i) {\n        return this.raw.wheel_suspension_force(i);\n    }\n    /**\n     *  The (world-space) contact normal between the i-th wheel and the floor.\n     */\n    wheelContactNormal(i) {\n        return VectorOps.fromRaw(this.raw.wheel_contact_normal_ws(i));\n    }\n    /**\n     *  The (world-space) point hit by the wheels ray-cast for the i-th wheel.\n     */\n    wheelContactPoint(i) {\n        return VectorOps.fromRaw(this.raw.wheel_contact_point_ws(i));\n    }\n    /**\n     *  The suspension length for the i-th wheel.\n     */\n    wheelSuspensionLength(i) {\n        return this.raw.wheel_suspension_length(i);\n    }\n    /**\n     *  The (world-space) starting point of the ray-cast for the i-th wheel.\n     */\n    wheelHardPoint(i) {\n        return VectorOps.fromRaw(this.raw.wheel_hard_point_ws(i));\n    }\n    /**\n     *  Is the i-th wheel in contact with the ground?\n     */\n    wheelIsInContact(i) {\n        return this.raw.wheel_is_in_contact(i);\n    }\n    /**\n     *  The collider hit by the ray-cast for the i-th wheel.\n     */\n    wheelGroundObject(i) {\n        return this.colliders.get(this.raw.wheel_ground_object(i));\n    }\n}\n//# sourceMappingURL=ray_cast_vehicle_controller.js.map","import { BroadPhase, ColliderSet, NarrowPhase, } from \"../geometry\";\nimport { CCDSolver, IntegrationParameters, IslandManager, ImpulseJointSet, MultibodyJointSet, RigidBodySet, } from \"../dynamics\";\nimport { VectorOps } from \"../math\";\nimport { PhysicsPipeline } from \"./physics_pipeline\";\nimport { QueryPipeline } from \"./query_pipeline\";\nimport { SerializationPipeline } from \"./serialization_pipeline\";\nimport { DebugRenderBuffers, DebugRenderPipeline } from \"./debug_render_pipeline\";\nimport { KinematicCharacterController } from \"../control\";\n// #if DIM3\nimport { DynamicRayCastVehicleController } from \"../control\";\n// #endif\n/**\n * The physics world.\n *\n * This contains all the data-structures necessary for creating and simulating\n * bodies with contacts, joints, and external forces.\n */\nexport class World {\n    constructor(gravity, rawIntegrationParameters, rawIslands, rawBroadPhase, rawNarrowPhase, rawBodies, rawColliders, rawImpulseJoints, rawMultibodyJoints, rawCCDSolver, rawQueryPipeline, rawPhysicsPipeline, rawSerializationPipeline, rawDebugRenderPipeline) {\n        this.gravity = gravity;\n        this.integrationParameters = new IntegrationParameters(rawIntegrationParameters);\n        this.islands = new IslandManager(rawIslands);\n        this.broadPhase = new BroadPhase(rawBroadPhase);\n        this.narrowPhase = new NarrowPhase(rawNarrowPhase);\n        this.bodies = new RigidBodySet(rawBodies);\n        this.colliders = new ColliderSet(rawColliders);\n        this.impulseJoints = new ImpulseJointSet(rawImpulseJoints);\n        this.multibodyJoints = new MultibodyJointSet(rawMultibodyJoints);\n        this.ccdSolver = new CCDSolver(rawCCDSolver);\n        this.queryPipeline = new QueryPipeline(rawQueryPipeline);\n        this.physicsPipeline = new PhysicsPipeline(rawPhysicsPipeline);\n        this.serializationPipeline = new SerializationPipeline(rawSerializationPipeline);\n        this.debugRenderPipeline = new DebugRenderPipeline(rawDebugRenderPipeline);\n        this.characterControllers = new Set();\n        // #if DIM3\n        this.vehicleControllers = new Set();\n        // #endif\n        this.impulseJoints.finalizeDeserialization(this.bodies);\n        this.bodies.finalizeDeserialization(this.colliders);\n        this.colliders.finalizeDeserialization(this.bodies);\n    }\n    // #endif\n    /**\n     * Release the WASM memory occupied by this physics world.\n     *\n     * All the fields of this physics world will be freed as well,\n     * so there is no need to call their `.free()` methods individually.\n     */\n    free() {\n        this.integrationParameters.free();\n        this.islands.free();\n        this.broadPhase.free();\n        this.narrowPhase.free();\n        this.bodies.free();\n        this.colliders.free();\n        this.impulseJoints.free();\n        this.multibodyJoints.free();\n        this.ccdSolver.free();\n        this.queryPipeline.free();\n        this.physicsPipeline.free();\n        this.serializationPipeline.free();\n        this.debugRenderPipeline.free();\n        this.characterControllers.forEach((controller) => controller.free());\n        // #if DIM3\n        this.vehicleControllers.forEach((controller) => controller.free());\n        // #endif\n        this.integrationParameters = undefined;\n        this.islands = undefined;\n        this.broadPhase = undefined;\n        this.narrowPhase = undefined;\n        this.bodies = undefined;\n        this.colliders = undefined;\n        this.ccdSolver = undefined;\n        this.impulseJoints = undefined;\n        this.multibodyJoints = undefined;\n        this.queryPipeline = undefined;\n        this.physicsPipeline = undefined;\n        this.serializationPipeline = undefined;\n        this.debugRenderPipeline = undefined;\n        this.characterControllers = undefined;\n        // #if DIM3\n        this.vehicleControllers = undefined;\n        // #endif\n    }\n    static fromRaw(raw) {\n        if (!raw)\n            return null;\n        return new World(VectorOps.fromRaw(raw.takeGravity()), raw.takeIntegrationParameters(), raw.takeIslandManager(), raw.takeBroadPhase(), raw.takeNarrowPhase(), raw.takeBodies(), raw.takeColliders(), raw.takeImpulseJoints(), raw.takeMultibodyJoints());\n    }\n    /**\n     * Takes a snapshot of this world.\n     *\n     * Use `World.restoreSnapshot` to create a new physics world with a state identical to\n     * the state when `.takeSnapshot()` is called.\n     */\n    takeSnapshot() {\n        return this.serializationPipeline.serializeAll(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints);\n    }\n    /**\n     * Creates a new physics world from a snapshot.\n     *\n     * This new physics world will be an identical copy of the snapshoted physics world.\n     */\n    static restoreSnapshot(data) {\n        let deser = new SerializationPipeline();\n        return deser.deserializeAll(data);\n    }\n    /**\n     * Computes all the lines (and their colors) needed to render the scene.\n     */\n    debugRender() {\n        this.debugRenderPipeline.render(this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.narrowPhase);\n        return new DebugRenderBuffers(this.debugRenderPipeline.vertices, this.debugRenderPipeline.colors);\n    }\n    /**\n     * Advance the simulation by one time step.\n     *\n     * All events generated by the physics engine are ignored.\n     *\n     * @param EventQueue - (optional) structure responsible for collecting\n     *   events generated by the physics engine.\n     */\n    step(eventQueue, hooks) {\n        this.physicsPipeline.step(this.gravity, this.integrationParameters, this.islands, this.broadPhase, this.narrowPhase, this.bodies, this.colliders, this.impulseJoints, this.multibodyJoints, this.ccdSolver, eventQueue, hooks);\n        this.queryPipeline.update(this.bodies, this.colliders);\n    }\n    /**\n     * Update colliders positions after rigid-bodies moved.\n     *\n     * When a rigid-body moves, the positions of the colliders attached to it need to be updated. This update is\n     * generally automatically done at the beginning and the end of each simulation step with World.step.\n     * If the positions need to be updated without running a simulation step this method can be called manually.\n     */\n    propagateModifiedBodyPositionsToColliders() {\n        this.bodies.raw.propagateModifiedBodyPositionsToColliders(this.colliders.raw);\n    }\n    /**\n     * Ensure subsequent scene queries take into account the collider positions set before this method is called.\n     *\n     * This does not step the physics simulation forward.\n     */\n    updateSceneQueries() {\n        this.propagateModifiedBodyPositionsToColliders();\n        this.queryPipeline.update(this.bodies, this.colliders);\n    }\n    /**\n     * The current simulation timestep.\n     */\n    get timestep() {\n        return this.integrationParameters.dt;\n    }\n    /**\n     * Sets the new simulation timestep.\n     *\n     * The simulation timestep governs by how much the physics state of the world will\n     * be integrated. A simulation timestep should:\n     * - be as small as possible. Typical values evolve around 0.016 (assuming the chosen unit is milliseconds,\n     * corresponds to the time between two frames of a game running at 60FPS).\n     * - not vary too much during the course of the simulation. A timestep with large variations may\n     * cause instabilities in the simulation.\n     *\n     * @param dt - The timestep length, in seconds.\n     */\n    set timestep(dt) {\n        this.integrationParameters.dt = dt;\n    }\n    /**\n     * The number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     */\n    get numSolverIterations() {\n        return this.integrationParameters.numSolverIterations;\n    }\n    /**\n     * Sets the number of solver iterations run by the constraints solver for calculating forces (default: `4`).\n     *\n     * The greater this value is, the most rigid and realistic the physics simulation will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new number of solver iterations.\n     */\n    set numSolverIterations(niter) {\n        this.integrationParameters.numSolverIterations = niter;\n    }\n    /**\n     * Number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     */\n    get numAdditionalFrictionIterations() {\n        return this.integrationParameters.numAdditionalFrictionIterations;\n    }\n    /**\n     * Sets the number of addition friction resolution iteration run during the last solver sub-step (default: `4`).\n     *\n     * The greater this value is, the most realistic friction will be.\n     * However a greater number of iterations is more computationally intensive.\n     *\n     * @param niter - The new number of additional friction iterations.\n     */\n    set numAdditionalFrictionIterations(niter) {\n        this.integrationParameters.numAdditionalFrictionIterations = niter;\n    }\n    /**\n     * Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     */\n    get numInternalPgsIterations() {\n        return this.integrationParameters.numInternalPgsIterations;\n    }\n    /**\n     * Sets the Number of internal Project Gauss Seidel (PGS) iterations run at each solver iteration (default: `1`).\n     *\n     * Increasing this parameter will improve stability of the simulation. It will have a lesser effect than\n     * increasing `numSolverIterations` but is also less computationally expensive.\n     *\n     * @param niter - The new number of internal PGS iterations.\n     */\n    set numInternalPgsIterations(niter) {\n        this.integrationParameters.numInternalPgsIterations = niter;\n    }\n    /// Configures the integration parameters to match the old PGS solver\n    /// from Rapier JS version <= 0.11.\n    ///\n    /// This solver was slightly faster than the new one but resulted\n    /// in less stable joints and worse convergence rates.\n    ///\n    /// This should only be used for comparison purpose or if you are\n    /// experiencing problems with the new solver.\n    ///\n    /// NOTE: this does not affect any `RigidBody.additional_solver_iterations` that will\n    ///       still create solver iterations based on the new \"small-steps\" PGS solver.\n    switchToStandardPgsSolver() {\n        this.integrationParameters.switchToStandardPgsSolver();\n    }\n    /// Configures the integration parameters to match the new \"small-steps\" PGS solver\n    /// from Rapier version >= 0.12.\n    ///\n    /// The \"small-steps\" PGS solver is the default one when creating the physics world. So\n    /// calling this function is generally not needed unless `World.switch_to_standard_pgs_solver`\n    /// was called.\n    ///\n    /// This solver results in more stable joints and significantly better convergence\n    /// rates but is slightly slower in its default settings.\n    switchToSmallStepsPgsSolver() {\n        this.integrationParameters.switchToSmallStepsPgsSolver();\n    }\n    /**\n     * Creates a new rigid-body from the given rigid-body descriptor.\n     *\n     * @param body - The description of the rigid-body to create.\n     */\n    createRigidBody(body) {\n        return this.bodies.createRigidBody(this.colliders, body);\n    }\n    /**\n     * Creates a new character controller.\n     *\n     * @param offset - The artificial gap added between the characters chape and its environment.\n     */\n    createCharacterController(offset) {\n        let controller = new KinematicCharacterController(offset, this.integrationParameters, this.bodies, this.colliders, this.queryPipeline);\n        this.characterControllers.add(controller);\n        return controller;\n    }\n    /**\n     * Removes a character controller from this world.\n     *\n     * @param controller - The character controller to remove.\n     */\n    removeCharacterController(controller) {\n        this.characterControllers.delete(controller);\n        controller.free();\n    }\n    // #if DIM3\n    /**\n     * Creates a new vehicle controller.\n     *\n     * @param chassis - The rigid-body used as the chassis of the vehicle controller. When the vehicle\n     *                  controller is updated, it will change directly the rigid-bodys velocity. This\n     *                  rigid-body must be a dynamic or kinematic-velocity-based rigid-body.\n     */\n    createVehicleController(chassis) {\n        let controller = new DynamicRayCastVehicleController(chassis, this.bodies, this.colliders, this.queryPipeline);\n        this.vehicleControllers.add(controller);\n        return controller;\n    }\n    /**\n     * Removes a vehicle controller from this world.\n     *\n     * @param controller - The vehicle controller to remove.\n     */\n    removeVehicleController(controller) {\n        this.vehicleControllers.delete(controller);\n        controller.free();\n    }\n    // #endif\n    /**\n     * Creates a new collider.\n     *\n     * @param desc - The description of the collider.\n     * @param parent - The rigid-body this collider is attached to.\n     */\n    createCollider(desc, parent) {\n        let parentHandle = parent ? parent.handle : undefined;\n        return this.colliders.createCollider(this.bodies, desc, parentHandle);\n    }\n    /**\n     * Creates a new impulse joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createImpulseJoint(params, parent1, parent2, wakeUp) {\n        return this.impulseJoints.createJoint(this.bodies, params, parent1.handle, parent2.handle, wakeUp);\n    }\n    /**\n     * Creates a new multibody joint from the given joint descriptor.\n     *\n     * @param params - The description of the joint to create.\n     * @param parent1 - The first rigid-body attached to this joint.\n     * @param parent2 - The second rigid-body attached to this joint.\n     * @param wakeUp - Should the attached rigid-bodies be awakened?\n     */\n    createMultibodyJoint(params, parent1, parent2, wakeUp) {\n        return this.multibodyJoints.createJoint(params, parent1.handle, parent2.handle, wakeUp);\n    }\n    /**\n     * Retrieves a rigid-body from its handle.\n     *\n     * @param handle - The integer handle of the rigid-body to retrieve.\n     */\n    getRigidBody(handle) {\n        return this.bodies.get(handle);\n    }\n    /**\n     * Retrieves a collider from its handle.\n     *\n     * @param handle - The integer handle of the collider to retrieve.\n     */\n    getCollider(handle) {\n        return this.colliders.get(handle);\n    }\n    /**\n     * Retrieves an impulse joint from its handle.\n     *\n     * @param handle - The integer handle of the impulse joint to retrieve.\n     */\n    getImpulseJoint(handle) {\n        return this.impulseJoints.get(handle);\n    }\n    /**\n     * Retrieves an multibody joint from its handle.\n     *\n     * @param handle - The integer handle of the multibody joint to retrieve.\n     */\n    getMultibodyJoint(handle) {\n        return this.multibodyJoints.get(handle);\n    }\n    /**\n     * Removes the given rigid-body from this physics world.\n     *\n     * This will remove this rigid-body as well as all its attached colliders and joints.\n     * Every other bodies touching or attached by joints to this rigid-body will be woken-up.\n     *\n     * @param body - The rigid-body to remove.\n     */\n    removeRigidBody(body) {\n        if (this.bodies) {\n            this.bodies.remove(body.handle, this.islands, this.colliders, this.impulseJoints, this.multibodyJoints);\n        }\n    }\n    /**\n     * Removes the given collider from this physics world.\n     *\n     * @param collider - The collider to remove.\n     * @param wakeUp - If set to `true`, the rigid-body this collider is attached to will be awaken.\n     */\n    removeCollider(collider, wakeUp) {\n        if (this.colliders) {\n            this.colliders.remove(collider.handle, this.islands, this.bodies, wakeUp);\n        }\n    }\n    /**\n     * Removes the given impulse joint from this physics world.\n     *\n     * @param joint - The impulse joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    removeImpulseJoint(joint, wakeUp) {\n        if (this.impulseJoints) {\n            this.impulseJoints.remove(joint.handle, wakeUp);\n        }\n    }\n    /**\n     * Removes the given multibody joint from this physics world.\n     *\n     * @param joint - The multibody joint to remove.\n     * @param wakeUp - If set to `true`, the rigid-bodies attached by this joint will be awaken.\n     */\n    removeMultibodyJoint(joint, wakeUp) {\n        if (this.impulseJoints) {\n            this.multibodyJoints.remove(joint.handle, wakeUp);\n        }\n    }\n    /**\n     * Applies the given closure to each collider managed by this physics world.\n     *\n     * @param f(collider) - The function to apply to each collider managed by this physics world. Called as `f(collider)`.\n     */\n    forEachCollider(f) {\n        this.colliders.forEach(f);\n    }\n    /**\n     * Applies the given closure to each rigid-body managed by this physics world.\n     *\n     * @param f(body) - The function to apply to each rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    forEachRigidBody(f) {\n        this.bodies.forEach(f);\n    }\n    /**\n     * Applies the given closure to each active rigid-body managed by this physics world.\n     *\n     * After a short time of inactivity, a rigid-body is automatically deactivated (\"asleep\") by\n     * the physics engine in order to save computational power. A sleeping rigid-body never moves\n     * unless it is moved manually by the user.\n     *\n     * @param f - The function to apply to each active rigid-body managed by this physics world. Called as `f(collider)`.\n     */\n    forEachActiveRigidBody(f) {\n        this.bodies.forEachActiveRigidBody(this.islands, f);\n    }\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param filter - The callback to filter out which collider will be hit.\n     */\n    castRay(ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.castRay(this.bodies, this.colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find the closest intersection between a ray and the physics world.\n     *\n     * This also computes the normal at the hit point.\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     */\n    castRayAndGetNormal(ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.castRayAndGetNormal(this.bodies, this.colliders, ray, maxToi, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Cast a ray and collects all the intersections between a ray and the scene.\n     *\n     * @param ray - The ray to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the length of the ray to `ray.dir.norm() * maxToi`.\n     * @param solid - If `false` then the ray will attempt to hit the boundary of a shape, even if its\n     *   origin already lies inside of a shape. In other terms, `true` implies that all shapes are plain,\n     *   whereas `false` implies that all shapes are hollow for this ray-cast.\n     * @param groups - Used to filter the colliders that can or cannot be hit by the ray.\n     * @param callback - The callback called once per hit (in no particular order) between a ray and a collider.\n     *   If this callback returns `false`, then the cast will stop and no further hits will be detected/reported.\n     */\n    intersectionsWithRay(ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        this.queryPipeline.intersectionsWithRay(this.bodies, this.colliders, ray, maxToi, solid, callback, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Gets the handle of up to one collider intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape used for the intersection test.\n     * @param shapeRot - The orientation of the shape used for the intersection test.\n     * @param shape - The shape used for the intersection test.\n     * @param groups - The bit groups and filter associated to the ray, in order to only\n     *   hit the colliders with collision groups compatible with the ray's group.\n     */\n    intersectionWithShape(shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        let handle = this.queryPipeline.intersectionWithShape(this.bodies, this.colliders, shapePos, shapeRot, shape, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n        return handle != null ? this.colliders.get(handle) : null;\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param solid - If this is set to `true` then the collider shapes are considered to\n     *   be plain (if the point is located inside of a plain shape, its projection is the point\n     *   itself). If it is set to `false` the collider shapes are considered to be hollow\n     *   (if the point is located inside of an hollow shape, it is projected on the shape's\n     *   boundary).\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPoint(point, solid, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.projectPoint(this.bodies, this.colliders, point, solid, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find the projection of a point on the closest collider.\n     *\n     * @param point - The point to project.\n     * @param groups - The bit groups and filter associated to the point to project, in order to only\n     *   project on colliders with collision groups compatible with the ray's group.\n     */\n    projectPointAndGetFeature(point, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.projectPointAndGetFeature(this.bodies, this.colliders, point, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Find all the colliders containing the given point.\n     *\n     * @param point - The point used for the containment test.\n     * @param groups - The bit groups and filter associated to the point to test, in order to only\n     *   test on colliders with collision groups compatible with the ray's group.\n     * @param callback - A function called with the handles of each collider with a shape\n     *   containing the `point`.\n     */\n    intersectionsWithPoint(point, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        this.queryPipeline.intersectionsWithPoint(this.bodies, this.colliders, point, this.colliders.castClosure(callback), filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Casts a shape at a constant linear velocity and retrieve the first collider it hits.\n     * This is similar to ray-casting except that we are casting a whole shape instead of\n     * just a point (the ray origin).\n     *\n     * @param shapePos - The initial position of the shape to cast.\n     * @param shapeRot - The initial rotation of the shape to cast.\n     * @param shapeVel - The constant velocity of the shape to cast (i.e. the cast direction).\n     * @param shape - The shape to cast.\n     * @param maxToi - The maximum time-of-impact that can be reported by this cast. This effectively\n     *   limits the distance traveled by the shape to `shapeVel.norm() * maxToi`.\n     * @param stopAtPenetration - If set to `false`, the linear shape-cast wont immediately stop if\n     *   the shape is penetrating another shape at its starting point **and** its trajectory is such\n     *   that its on a path to exist that penetration state.\n     * @param groups - The bit groups and filter associated to the shape to cast, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     */\n    castShape(shapePos, shapeRot, shapeVel, shape, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        return this.queryPipeline.castShape(this.bodies, this.colliders, shapePos, shapeRot, shapeVel, shape, maxToi, stopAtPenetration, filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Retrieve all the colliders intersecting the given shape.\n     *\n     * @param shapePos - The position of the shape to test.\n     * @param shapeRot - The orientation of the shape to test.\n     * @param shape - The shape to test.\n     * @param groups - The bit groups and filter associated to the shape to test, in order to only\n     *   test on colliders with collision groups compatible with this group.\n     * @param callback - A function called with the handles of each collider intersecting the `shape`.\n     */\n    intersectionsWithShape(shapePos, shapeRot, shape, callback, filterFlags, filterGroups, filterExcludeCollider, filterExcludeRigidBody, filterPredicate) {\n        this.queryPipeline.intersectionsWithShape(this.bodies, this.colliders, shapePos, shapeRot, shape, this.colliders.castClosure(callback), filterFlags, filterGroups, filterExcludeCollider ? filterExcludeCollider.handle : null, filterExcludeRigidBody ? filterExcludeRigidBody.handle : null, this.colliders.castClosure(filterPredicate));\n    }\n    /**\n     * Finds the handles of all the colliders with an AABB intersecting the given AABB.\n     *\n     * @param aabbCenter - The center of the AABB to test.\n     * @param aabbHalfExtents - The half-extents of the AABB to test.\n     * @param callback - The callback that will be called with the handles of all the colliders\n     *                   currently intersecting the given AABB.\n     */\n    collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, callback) {\n        this.queryPipeline.collidersWithAabbIntersectingAabb(aabbCenter, aabbHalfExtents, this.colliders.castClosure(callback));\n    }\n    /**\n     * Enumerates all the colliders potentially in contact with the given collider.\n     *\n     * @param collider1 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each collider that is in contact with `collider1`.\n     */\n    contactPairsWith(collider1, f) {\n        this.narrowPhase.contactPairsWith(collider1.handle, this.colliders.castClosure(f));\n    }\n    /**\n     * Enumerates all the colliders intersecting the given colliders, assuming one of them\n     * is a sensor.\n     */\n    intersectionPairsWith(collider1, f) {\n        this.narrowPhase.intersectionPairsWith(collider1.handle, this.colliders.castClosure(f));\n    }\n    /**\n     * Iterates through all the contact manifolds between the given pair of colliders.\n     *\n     * @param collider1 - The first collider involved in the contact.\n     * @param collider2 - The second collider involved in the contact.\n     * @param f - Closure that will be called on each contact manifold between the two colliders. If the second argument\n     *            passed to this closure is `true`, then the contact manifold data is flipped, i.e., methods like `localNormal1`\n     *            actually apply to the `collider2` and fields like `localNormal2` apply to the `collider1`.\n     */\n    contactPair(collider1, collider2, f) {\n        this.narrowPhase.contactPair(collider1.handle, collider2.handle, f);\n    }\n    /**\n     * Returns `true` if `collider1` and `collider2` intersect and at least one of them is a sensor.\n     * @param collider1  The first collider involved in the intersection.\n     * @param collider2  The second collider involved in the intersection.\n     */\n    intersectionPair(collider1, collider2) {\n        return this.narrowPhase.intersectionPair(collider1.handle, collider2.handle);\n    }\n}\n//# sourceMappingURL=world.js.map","import { RawColliderSet } from \"../raw\";\nimport { Coarena } from \"../coarena\";\nimport { RotationOps, VectorOps } from \"../math\";\nimport { Collider } from \"./collider\";\n/**\n * A set of rigid bodies that can be handled by a physics pipeline.\n *\n * To avoid leaking WASM resources, this MUST be freed manually with `colliderSet.free()`\n * once you are done using it (and all the rigid-bodies it created).\n */\nexport class ColliderSet {\n    constructor(raw) {\n        this.raw = raw || new RawColliderSet();\n        this.map = new Coarena();\n        // Initialize the map with the existing elements, if any.\n        if (raw) {\n            raw.forEachColliderHandle((handle) => {\n                this.map.set(handle, new Collider(this, handle, null));\n            });\n        }\n    }\n    /**\n     * Release the WASM memory occupied by this collider set.\n     */\n    free() {\n        if (!!this.raw) {\n            this.raw.free();\n        }\n        this.raw = undefined;\n        if (!!this.map) {\n            this.map.clear();\n        }\n        this.map = undefined;\n    }\n    /** @internal */\n    castClosure(f) {\n        return (handle) => {\n            if (!!f) {\n                return f(this.get(handle));\n            }\n            else {\n                return undefined;\n            }\n        };\n    }\n    /** @internal */\n    finalizeDeserialization(bodies) {\n        this.map.forEach((collider) => collider.finalizeDeserialization(bodies));\n    }\n    /**\n     * Creates a new collider and return its integer handle.\n     *\n     * @param bodies - The set of bodies where the collider's parent can be found.\n     * @param desc - The collider's description.\n     * @param parentHandle - The integer handle of the rigid-body this collider is attached to.\n     */\n    createCollider(bodies, desc, parentHandle) {\n        let hasParent = parentHandle != undefined && parentHandle != null;\n        if (hasParent && isNaN(parentHandle))\n            throw Error(\"Cannot create a collider with a parent rigid-body handle that is not a number.\");\n        let rawShape = desc.shape.intoRaw();\n        let rawTra = VectorOps.intoRaw(desc.translation);\n        let rawRot = RotationOps.intoRaw(desc.rotation);\n        let rawCom = VectorOps.intoRaw(desc.centerOfMass);\n        // #if DIM3\n        let rawPrincipalInertia = VectorOps.intoRaw(desc.principalAngularInertia);\n        let rawInertiaFrame = RotationOps.intoRaw(desc.angularInertiaLocalFrame);\n        // #endif\n        let handle = this.raw.createCollider(desc.enabled, rawShape, rawTra, rawRot, desc.massPropsMode, desc.mass, rawCom, \n        // #if DIM3\n        rawPrincipalInertia, rawInertiaFrame, \n        // #endif\n        desc.density, desc.friction, desc.restitution, desc.frictionCombineRule, desc.restitutionCombineRule, desc.isSensor, desc.collisionGroups, desc.solverGroups, desc.activeCollisionTypes, desc.activeHooks, desc.activeEvents, desc.contactForceEventThreshold, hasParent, hasParent ? parentHandle : 0, bodies.raw);\n        rawShape.free();\n        rawTra.free();\n        rawRot.free();\n        rawCom.free();\n        // #if DIM3\n        rawPrincipalInertia.free();\n        rawInertiaFrame.free();\n        // #endif\n        let parent = hasParent ? bodies.get(parentHandle) : null;\n        let collider = new Collider(this, handle, parent, desc.shape);\n        this.map.set(handle, collider);\n        return collider;\n    }\n    /**\n     * Remove a collider from this set.\n     *\n     * @param handle - The integer handle of the collider to remove.\n     * @param bodies - The set of rigid-body containing the rigid-body the collider is attached to.\n     * @param wakeUp - If `true`, the rigid-body the removed collider is attached to will be woken-up automatically.\n     */\n    remove(handle, islands, bodies, wakeUp) {\n        this.raw.remove(handle, islands.raw, bodies.raw, wakeUp);\n        this.unmap(handle);\n    }\n    /**\n     * Internal function, do not call directly.\n     * @param handle\n     */\n    unmap(handle) {\n        this.map.delete(handle);\n    }\n    /**\n     * Gets the rigid-body with the given handle.\n     *\n     * @param handle - The handle of the rigid-body to retrieve.\n     */\n    get(handle) {\n        return this.map.get(handle);\n    }\n    /**\n     * The number of colliders on this set.\n     */\n    len() {\n        return this.map.len();\n    }\n    /**\n     * Does this set contain a collider with the given handle?\n     *\n     * @param handle - The collider handle to check.\n     */\n    contains(handle) {\n        return this.get(handle) != null;\n    }\n    /**\n     * Applies the given closure to each collider contained by this set.\n     *\n     * @param f - The closure to apply.\n     */\n    forEach(f) {\n        this.map.forEach(f);\n    }\n    /**\n     * Gets all colliders in the list.\n     *\n     * @returns collider list.\n     */\n    getAll() {\n        return this.map.getAll();\n    }\n}\n//# sourceMappingURL=collider_set.js.map","import { version as vers } from \"./raw\";\nexport function version() {\n    return vers();\n}\nexport * from \"./math\";\nexport * from \"./dynamics\";\nexport * from \"./geometry\";\nexport * from \"./pipeline\";\nexport * from \"./init\";\nexport * from \"./control\";\n//# sourceMappingURL=exports.js.map"],"names":["wasm","heap","Array","fill","undefined","push","heap_next","length","addHeapObject","obj","idx","takeObject","ret","getObject","dropObject","isLikeNone","x","cachedFloat64Memory0","getFloat64Memory0","byteLength","Float64Array","memory","buffer","cachedInt32Memory0","getInt32Memory0","Int32Array","cachedTextDecoder","TextDecoder","module","require","ignoreBOM","fatal","decode","cachedUint8Memory0","getStringFromWasm0","ptr","len","Uint8Array","subarray","_assertClass","instance","klass","Error","name","cachedFloat32Memory0","getFloat32Memory0","Float32Array","stack_pointer","addBorrowedObject","getArrayF32FromWasm0","cachedUint32Memory0","getUint32Memory0","Uint32Array","WASM_VECTOR_LEN","passArrayF32ToWasm0","arg","malloc","set","passArray32ToWasm0","RawJointType","Object","freeze","Revolute","Fixed","Prismatic","Rope","Spring","Spherical","Generic","RawShapeType","Ball","Cuboid","Capsule","Segment","Polyline","Triangle","TriMesh","HeightField","Compound","ConvexPolyhedron","Cylinder","Cone","RoundCuboid","RoundTriangle","RoundCylinder","RoundCone","RoundConvexPolyhedron","HalfSpace","RawJointAxis","X","Y","Z","AngX","AngY","AngZ","RawBroadPhase","__wrap","create","prototype","__wbg_ptr","__destroy_into_raw","this","free","__wbg_rawbroadphase_free","constructor","rawbroadphase_new","RawCCDSolver","__wbg_rawccdsolver_free","rawccdsolver_new","RawCharacterCollision","__wbg_rawcharactercollision_free","rawcharactercollision_new","handle","rawcharactercollision_handle","translationDeltaApplied","rawcharactercollision_translationDeltaApplied","RawVector","translationDeltaRemaining","rawcharactercollision_translationDeltaRemaining","toi","rawcharactercollision_toi","worldWitness1","rawcharactercollision_worldWitness1","worldWitness2","rawcharactercollision_worldWitness2","worldNormal1","rawcharactercollision_worldNormal1","worldNormal2","rawcharactercollision_worldNormal2","RawColliderSet","__wbg_rawcolliderset_free","coTranslation","rawcolliderset_coTranslation","coRotation","rawcolliderset_coRotation","RawRotation","coSetTranslation","y","z","rawcolliderset_coSetTranslation","coSetTranslationWrtParent","rawcolliderset_coSetTranslationWrtParent","coSetRotation","w","rawcolliderset_coSetRotation","coSetRotationWrtParent","rawcolliderset_coSetRotationWrtParent","coIsSensor","rawcolliderset_coIsSensor","coShapeType","rawcolliderset_coShapeType","coHalfspaceNormal","rawcolliderset_coHalfspaceNormal","coHalfExtents","rawcolliderset_coHalfExtents","coSetHalfExtents","newHalfExtents","rawcolliderset_coSetHalfExtents","coRadius","retptr","__wbindgen_add_to_stack_pointer","rawcolliderset_coRadius","r0","r1","coSetRadius","newRadius","rawcolliderset_coSetRadius","coHalfHeight","rawcolliderset_coHalfHeight","coSetHalfHeight","newHalfheight","rawcolliderset_coSetHalfHeight","coRoundRadius","rawcolliderset_coRoundRadius","coSetRoundRadius","newBorderRadius","rawcolliderset_coSetRoundRadius","coVertices","rawcolliderset_coVertices","v1","slice","__wbindgen_free","coIndices","rawcolliderset_coIndices","coHeightfieldHeights","rawcolliderset_coHeightfieldHeights","coHeightfieldScale","rawcolliderset_coHeightfieldScale","coHeightfieldNRows","rawcolliderset_coHeightfieldNRows","coHeightfieldNCols","rawcolliderset_coHeightfieldNCols","coParent","rawcolliderset_coParent","r2","coSetEnabled","enabled","rawcolliderset_coSetEnabled","coIsEnabled","rawcolliderset_coIsEnabled","coFriction","rawcolliderset_coFriction","coRestitution","rawcolliderset_coRestitution","coDensity","rawcolliderset_coDensity","coMass","rawcolliderset_coMass","coVolume","rawcolliderset_coVolume","coCollisionGroups","rawcolliderset_coCollisionGroups","coSolverGroups","rawcolliderset_coSolverGroups","coActiveHooks","rawcolliderset_coActiveHooks","coActiveCollisionTypes","rawcolliderset_coActiveCollisionTypes","coActiveEvents","rawcolliderset_coActiveEvents","coContactForceEventThreshold","rawcolliderset_coContactForceEventThreshold","coContainsPoint","point","rawcolliderset_coContainsPoint","coCastShape","colliderVel","shape2","shape2Pos","shape2Rot","shape2Vel","maxToi","stop_at_penetration","RawShape","rawcolliderset_coCastShape","RawShapeTOI","coCastCollider","collider1Vel","collider2handle","collider2Vel","max_toi","rawcolliderset_coCastCollider","RawShapeColliderTOI","coIntersectsShape","shapePos2","shapeRot2","rawcolliderset_coIntersectsShape","coContactShape","prediction","rawcolliderset_coContactShape","RawShapeContact","coContactCollider","rawcolliderset_coContactCollider","coProjectPoint","solid","rawcolliderset_coProjectPoint","RawPointProjection","coIntersectsRay","rayOrig","rayDir","rawcolliderset_coIntersectsRay","coCastRay","rawcolliderset_coCastRay","coCastRayAndGetNormal","rawcolliderset_coCastRayAndGetNormal","RawRayIntersection","coSetSensor","is_sensor","rawcolliderset_coSetSensor","coSetRestitution","restitution","rawcolliderset_coSetRestitution","coSetFriction","friction","rawcolliderset_coSetFriction","coFrictionCombineRule","rawcolliderset_coFrictionCombineRule","coSetFrictionCombineRule","rule","rawcolliderset_coSetFrictionCombineRule","coRestitutionCombineRule","rawcolliderset_coRestitutionCombineRule","coSetRestitutionCombineRule","rawcolliderset_coSetRestitutionCombineRule","coSetCollisionGroups","groups","rawcolliderset_coSetCollisionGroups","coSetSolverGroups","rawcolliderset_coSetSolverGroups","coSetActiveHooks","hooks","rawcolliderset_coSetActiveHooks","coSetActiveEvents","events","rawcolliderset_coSetActiveEvents","coSetActiveCollisionTypes","types","rawcolliderset_coSetActiveCollisionTypes","coSetShape","shape","rawcolliderset_coSetShape","coSetContactForceEventThreshold","threshold","rawcolliderset_coSetContactForceEventThreshold","coSetDensity","density","rawcolliderset_coSetDensity","coSetMass","mass","rawcolliderset_coSetMass","coSetMassProperties","centerOfMass","principalAngularInertia","angularInertiaFrame","rawcolliderset_coSetMassProperties","rawcolliderset_new","rawcolliderset_len","contains","rawcolliderset_contains","createCollider","translation","rotation","massPropsMode","frictionCombineRule","restitutionCombineRule","isSensor","collisionGroups","solverGroups","activeCollisionTypes","activeHooks","activeEvents","contactForceEventThreshold","hasParent","parent","bodies","RawRigidBodySet","rawcolliderset_createCollider","remove","islands","wakeUp","RawIslandManager","rawcolliderset_remove","isHandleValid","forEachColliderHandle","f","rawcolliderset_forEachColliderHandle","RawContactManifold","__wbg_rawcontactmanifold_free","normal","rawcontactmanifold_normal","local_n1","rawcontactmanifold_local_n1","local_n2","rawcontactmanifold_local_n2","subshape1","rawcontactmanifold_subshape1","subshape2","rawcontactmanifold_subshape2","num_contacts","rawcontactmanifold_num_contacts","contact_local_p1","i","rawcontactmanifold_contact_local_p1","contact_local_p2","rawcontactmanifold_contact_local_p2","contact_dist","rawcontactmanifold_contact_dist","contact_fid1","rawcontactmanifold_contact_fid1","contact_fid2","rawcontactmanifold_contact_fid2","contact_impulse","rawcontactmanifold_contact_impulse","contact_tangent_impulse_x","rawcontactmanifold_contact_tangent_impulse_x","contact_tangent_impulse_y","rawcontactmanifold_contact_tangent_impulse_y","num_solver_contacts","rawcontactmanifold_num_solver_contacts","solver_contact_point","rawcontactmanifold_solver_contact_point","solver_contact_dist","rawcontactmanifold_solver_contact_dist","solver_contact_friction","rawcontactmanifold_solver_contact_friction","solver_contact_restitution","rawcontactmanifold_solver_contact_restitution","solver_contact_tangent_velocity","rawcontactmanifold_solver_contact_tangent_velocity","RawContactPair","__wbg_rawcontactpair_free","collider1","rawcontactpair_collider1","collider2","rawcontactpair_collider2","numContactManifolds","rawcontactpair_numContactManifolds","contactManifold","rawcontactpair_contactManifold","RawDebugRenderPipeline","__wbg_rawdebugrenderpipeline_free","rawdebugrenderpipeline_new","vertices","rawdebugrenderpipeline_vertices","colors","rawdebugrenderpipeline_colors","render","colliders","impulse_joints","multibody_joints","narrow_phase","RawImpulseJointSet","RawMultibodyJointSet","RawNarrowPhase","rawdebugrenderpipeline_render","RawDeserializedWorld","__wbg_rawdeserializedworld_free","takeGravity","rawdeserializedworld_takeGravity","takeIntegrationParameters","rawdeserializedworld_takeIntegrationParameters","RawIntegrationParameters","takeIslandManager","rawdeserializedworld_takeIslandManager","takeBroadPhase","rawdeserializedworld_takeBroadPhase","takeNarrowPhase","rawdeserializedworld_takeNarrowPhase","takeBodies","rawdeserializedworld_takeBodies","takeColliders","rawdeserializedworld_takeColliders","takeImpulseJoints","rawdeserializedworld_takeImpulseJoints","takeMultibodyJoints","rawdeserializedworld_takeMultibodyJoints","RawDynamicRayCastVehicleController","__wbg_rawdynamicraycastvehiclecontroller_free","chassis","rawdynamicraycastvehiclecontroller_new","current_vehicle_speed","rawdynamicraycastvehiclecontroller_current_vehicle_speed","rawdynamicraycastvehiclecontroller_chassis","index_up_axis","rawdynamicraycastvehiclecontroller_index_up_axis","set_index_up_axis","axis","rawdynamicraycastvehiclecontroller_set_index_up_axis","index_forward_axis","rawdynamicraycastvehiclecontroller_index_forward_axis","set_index_forward_axis","rawdynamicraycastvehiclecontroller_set_index_forward_axis","add_wheel","chassis_connection_cs","direction_cs","axle_cs","suspension_rest_length","radius","rawdynamicraycastvehiclecontroller_add_wheel","num_wheels","rawdynamicraycastvehiclecontroller_num_wheels","update_vehicle","dt","queries","filter_flags","filter_groups","filter_predicate","RawQueryPipeline","rawdynamicraycastvehiclecontroller_update_vehicle","wheel_chassis_connection_point_cs","rawdynamicraycastvehiclecontroller_wheel_chassis_connection_point_cs","set_wheel_chassis_connection_point_cs","value","rawdynamicraycastvehiclecontroller_set_wheel_chassis_connection_point_cs","wheel_suspension_rest_length","rawdynamicraycastvehiclecontroller_wheel_suspension_rest_length","set_wheel_suspension_rest_length","rawdynamicraycastvehiclecontroller_set_wheel_suspension_rest_length","wheel_max_suspension_travel","rawdynamicraycastvehiclecontroller_wheel_max_suspension_travel","set_wheel_max_suspension_travel","rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_travel","wheel_radius","rawdynamicraycastvehiclecontroller_wheel_radius","set_wheel_radius","rawdynamicraycastvehiclecontroller_set_wheel_radius","wheel_suspension_stiffness","rawdynamicraycastvehiclecontroller_wheel_suspension_stiffness","set_wheel_suspension_stiffness","rawdynamicraycastvehiclecontroller_set_wheel_suspension_stiffness","wheel_suspension_compression","rawdynamicraycastvehiclecontroller_wheel_suspension_compression","set_wheel_suspension_compression","rawdynamicraycastvehiclecontroller_set_wheel_suspension_compression","wheel_suspension_relaxation","rawdynamicraycastvehiclecontroller_wheel_suspension_relaxation","set_wheel_suspension_relaxation","rawdynamicraycastvehiclecontroller_set_wheel_suspension_relaxation","wheel_max_suspension_force","rawdynamicraycastvehiclecontroller_wheel_max_suspension_force","set_wheel_max_suspension_force","rawdynamicraycastvehiclecontroller_set_wheel_max_suspension_force","wheel_brake","rawdynamicraycastvehiclecontroller_wheel_brake","set_wheel_brake","rawdynamicraycastvehiclecontroller_set_wheel_brake","wheel_steering","rawdynamicraycastvehiclecontroller_wheel_steering","set_wheel_steering","rawdynamicraycastvehiclecontroller_set_wheel_steering","wheel_engine_force","rawdynamicraycastvehiclecontroller_wheel_engine_force","set_wheel_engine_force","rawdynamicraycastvehiclecontroller_set_wheel_engine_force","wheel_direction_cs","rawdynamicraycastvehiclecontroller_wheel_direction_cs","set_wheel_direction_cs","rawdynamicraycastvehiclecontroller_set_wheel_direction_cs","wheel_axle_cs","rawdynamicraycastvehiclecontroller_wheel_axle_cs","set_wheel_axle_cs","rawdynamicraycastvehiclecontroller_set_wheel_axle_cs","wheel_friction_slip","rawdynamicraycastvehiclecontroller_wheel_friction_slip","set_wheel_friction_slip","rawdynamicraycastvehiclecontroller_set_wheel_friction_slip","wheel_side_friction_stiffness","rawdynamicraycastvehiclecontroller_wheel_side_friction_stiffness","set_wheel_side_friction_stiffness","stiffness","rawdynamicraycastvehiclecontroller_set_wheel_side_friction_stiffness","wheel_rotation","rawdynamicraycastvehiclecontroller_wheel_rotation","wheel_forward_impulse","rawdynamicraycastvehiclecontroller_wheel_forward_impulse","wheel_side_impulse","rawdynamicraycastvehiclecontroller_wheel_side_impulse","wheel_suspension_force","rawdynamicraycastvehiclecontroller_wheel_suspension_force","wheel_contact_normal_ws","rawdynamicraycastvehiclecontroller_wheel_contact_normal_ws","wheel_contact_point_ws","rawdynamicraycastvehiclecontroller_wheel_contact_point_ws","wheel_suspension_length","rawdynamicraycastvehiclecontroller_wheel_suspension_length","wheel_hard_point_ws","rawdynamicraycastvehiclecontroller_wheel_hard_point_ws","wheel_is_in_contact","rawdynamicraycastvehiclecontroller_wheel_is_in_contact","wheel_ground_object","rawdynamicraycastvehiclecontroller_wheel_ground_object","RawEventQueue","__wbg_raweventqueue_free","autoDrain","raweventqueue_new","drainCollisionEvents","raweventqueue_drainCollisionEvents","drainContactForceEvents","raweventqueue_drainContactForceEvents","clear","raweventqueue_clear","RawGenericJoint","__wbg_rawgenericjoint_free","generic","anchor1","anchor2","lockedAxes","rawgenericjoint_generic","spring","rest_length","damping","rawgenericjoint_spring","rope","rawgenericjoint_rope","spherical","rawgenericjoint_spherical","prismatic","limitsEnabled","limitsMin","limitsMax","rawgenericjoint_prismatic","fixed","axes1","axes2","rawgenericjoint_fixed","revolute","rawgenericjoint_revolute","__wbg_rawimpulsejointset_free","jointType","rawimpulsejointset_jointType","jointBodyHandle1","rawimpulsejointset_jointBodyHandle1","jointBodyHandle2","rawimpulsejointset_jointBodyHandle2","jointFrameX1","rawimpulsejointset_jointFrameX1","jointFrameX2","rawimpulsejointset_jointFrameX2","jointAnchor1","rawimpulsejointset_jointAnchor1","jointAnchor2","rawimpulsejointset_jointAnchor2","jointSetAnchor1","newPos","rawimpulsejointset_jointSetAnchor1","jointSetAnchor2","rawimpulsejointset_jointSetAnchor2","jointContactsEnabled","rawimpulsejointset_jointContactsEnabled","jointSetContactsEnabled","rawimpulsejointset_jointSetContactsEnabled","jointLimitsEnabled","rawimpulsejointset_jointLimitsEnabled","jointLimitsMin","rawimpulsejointset_jointLimitsMin","jointLimitsMax","rawimpulsejointset_jointLimitsMax","jointSetLimits","min","max","rawimpulsejointset_jointSetLimits","jointConfigureMotorModel","model","rawimpulsejointset_jointConfigureMotorModel","jointConfigureMotorVelocity","targetVel","factor","rawimpulsejointset_jointConfigureMotorVelocity","jointConfigureMotorPosition","targetPos","rawimpulsejointset_jointConfigureMotorPosition","jointConfigureMotor","rawimpulsejointset_jointConfigureMotor","rawimpulsejointset_new","createJoint","params","parent1","parent2","wake_up","rawimpulsejointset_createJoint","rawimpulsejointset_remove","rawimpulsejointset_len","rawimpulsejointset_contains","forEachJointHandle","rawimpulsejointset_forEachJointHandle","forEachJointAttachedToRigidBody","body","rawimpulsejointset_forEachJointAttachedToRigidBody","__wbg_rawintegrationparameters_free","rawintegrationparameters_new","rawintegrationparameters_dt","erp","rawintegrationparameters_erp","allowedLinearError","rawcontactforceevent_total_force_magnitude","predictionDistance","numSolverIterations","rawintegrationparameters_numSolverIterations","numAdditionalFrictionIterations","rawintegrationparameters_numAdditionalFrictionIterations","numInternalPgsIterations","rawintegrationparameters_numInternalPgsIterations","minIslandSize","maxCcdSubsteps","rawintegrationparameters_set_dt","rawintegrationparameters_set_erp","rawintegrationparameters_set_allowedLinearError","rawintegrationparameters_set_predictionDistance","rawintegrationparameters_set_numSolverIterations","rawintegrationparameters_set_numAdditionalFrictionIterations","rawintegrationparameters_set_numInternalPgsIterations","switchToStandardPgsSolver","rawintegrationparameters_switchToStandardPgsSolver","switchToSmallStepsPgsSolver","rawintegrationparameters_switchToSmallStepsPgsSolver","__wbg_rawislandmanager_free","rawislandmanager_new","forEachActiveRigidBodyHandle","rawislandmanager_forEachActiveRigidBodyHandle","RawKinematicCharacterController","__wbg_rawkinematiccharactercontroller_free","offset","rawkinematiccharactercontroller_new","up","setUp","vector","rawkinematiccharactercontroller_setUp","setOffset","rawkinematiccharactercontroller_setOffset","slideEnabled","rawkinematiccharactercontroller_slideEnabled","setSlideEnabled","rawkinematiccharactercontroller_setSlideEnabled","autostepMaxHeight","rawkinematiccharactercontroller_autostepMaxHeight","autostepMinWidth","rawkinematiccharactercontroller_autostepMinWidth","autostepIncludesDynamicBodies","rawkinematiccharactercontroller_autostepIncludesDynamicBodies","autostepEnabled","rawkinematiccharactercontroller_autostepEnabled","enableAutostep","maxHeight","minWidth","includeDynamicBodies","rawkinematiccharactercontroller_enableAutostep","disableAutostep","rawkinematiccharactercontroller_disableAutostep","maxSlopeClimbAngle","rawkinematiccharactercontroller_maxSlopeClimbAngle","setMaxSlopeClimbAngle","angle","rawkinematiccharactercontroller_setMaxSlopeClimbAngle","minSlopeSlideAngle","rawkinematiccharactercontroller_minSlopeSlideAngle","setMinSlopeSlideAngle","rawkinematiccharactercontroller_setMinSlopeSlideAngle","snapToGroundDistance","rawkinematiccharactercontroller_snapToGroundDistance","enableSnapToGround","distance","rawkinematiccharactercontroller_enableSnapToGround","disableSnapToGround","rawkinematiccharactercontroller_disableSnapToGround","snapToGroundEnabled","rawkinematiccharactercontroller_snapToGroundEnabled","computeColliderMovement","collider_handle","desired_translation_delta","apply_impulses_to_dynamic_bodies","character_mass","rawkinematiccharactercontroller_computeColliderMovement","computedMovement","rawkinematiccharactercontroller_computedMovement","computedGrounded","rawkinematiccharactercontroller_computedGrounded","numComputedCollisions","rawkinematiccharactercontroller_numComputedCollisions","computedCollision","collision","rawkinematiccharactercontroller_computedCollision","__wbg_rawmultibodyjointset_free","rawmultibodyjointset_jointType","rawmultibodyjointset_jointFrameX1","rawmultibodyjointset_jointFrameX2","rawmultibodyjointset_jointAnchor1","rawmultibodyjointset_jointAnchor2","rawmultibodyjointset_jointContactsEnabled","rawmultibodyjointset_jointSetContactsEnabled","rawmultibodyjointset_jointLimitsEnabled","rawmultibodyjointset_jointLimitsMin","rawmultibodyjointset_jointLimitsMax","rawmultibodyjointset_new","rawmultibodyjointset_createJoint","rawmultibodyjointset_remove","rawmultibodyjointset_contains","rawmultibodyjointset_forEachJointHandle","rawmultibodyjointset_forEachJointAttachedToRigidBody","__wbg_rawnarrowphase_free","rawnarrowphase_new","contact_pairs_with","handle1","rawnarrowphase_contact_pairs_with","contact_pair","handle2","rawnarrowphase_contact_pair","intersection_pairs_with","rawnarrowphase_intersection_pairs_with","intersection_pair","rawnarrowphase_intersection_pair","RawPhysicsPipeline","__wbg_rawphysicspipeline_free","rawphysicspipeline_new","step","gravity","integrationParameters","broadPhase","narrowPhase","joints","articulations","ccd_solver","rawphysicspipeline_step","stepWithEvents","eventQueue","hookObject","hookFilterContactPair","hookFilterIntersectionPair","rawphysicspipeline_stepWithEvents","RawPointColliderProjection","__wbg_rawpointcolliderprojection_free","colliderHandle","rawpointcolliderprojection_colliderHandle","rawpointcolliderprojection_point","isInside","rawpointcolliderprojection_isInside","featureType","rawpointcolliderprojection_featureType","featureId","rawpointcolliderprojection_featureId","__wbg_rawpointprojection_free","rawpointprojection_point","rawpointprojection_isInside","__wbg_rawquerypipeline_free","rawquerypipeline_new","update","rawquerypipeline_update","castRay","filter_exclude_collider","filter_exclude_rigid_body","rawquerypipeline_castRay","RawRayColliderToi","castRayAndGetNormal","rawquerypipeline_castRayAndGetNormal","RawRayColliderIntersection","intersectionsWithRay","callback","rawquerypipeline_intersectionsWithRay","intersectionWithShape","shapePos","shapeRot","rawquerypipeline_intersectionWithShape","projectPoint","rawquerypipeline_projectPoint","projectPointAndGetFeature","rawquerypipeline_projectPointAndGetFeature","intersectionsWithPoint","rawquerypipeline_intersectionsWithPoint","castShape","shapeVel","rawquerypipeline_castShape","intersectionsWithShape","rawquerypipeline_intersectionsWithShape","collidersWithAabbIntersectingAabb","aabbCenter","aabbHalfExtents","rawquerypipeline_collidersWithAabbIntersectingAabb","__wbg_rawraycolliderintersection_free","rawraycolliderintersection_normal","rawraycolliderintersection_toi","__wbg_rawraycollidertoi_free","__wbg_rawrayintersection_free","__wbg_rawrigidbodyset_free","rbTranslation","rawrigidbodyset_rbTranslation","rbRotation","rawrigidbodyset_rbRotation","rbSleep","rawrigidbodyset_rbSleep","rbIsSleeping","rawrigidbodyset_rbIsSleeping","rbIsMoving","rawrigidbodyset_rbIsMoving","rbNextTranslation","rawrigidbodyset_rbNextTranslation","rbNextRotation","rawrigidbodyset_rbNextRotation","rbSetTranslation","rawrigidbodyset_rbSetTranslation","rbSetRotation","rawrigidbodyset_rbSetRotation","rbSetLinvel","linvel","rawrigidbodyset_rbSetLinvel","rbSetAngvel","angvel","rawrigidbodyset_rbSetAngvel","rbSetNextKinematicTranslation","rawrigidbodyset_rbSetNextKinematicTranslation","rbSetNextKinematicRotation","rawrigidbodyset_rbSetNextKinematicRotation","rbRecomputeMassPropertiesFromColliders","rawrigidbodyset_rbRecomputeMassPropertiesFromColliders","rbSetAdditionalMass","rawrigidbodyset_rbSetAdditionalMass","rbSetAdditionalMassProperties","rawrigidbodyset_rbSetAdditionalMassProperties","rbLinvel","rawrigidbodyset_rbLinvel","rbAngvel","rawrigidbodyset_rbAngvel","rbLockTranslations","locked","rawrigidbodyset_rbLockTranslations","rbSetEnabledTranslations","allow_x","allow_y","allow_z","rawrigidbodyset_rbSetEnabledTranslations","rbLockRotations","rawrigidbodyset_rbLockRotations","rbSetEnabledRotations","rawrigidbodyset_rbSetEnabledRotations","rbDominanceGroup","rawrigidbodyset_rbDominanceGroup","rbSetDominanceGroup","group","rawrigidbodyset_rbSetDominanceGroup","rbEnableCcd","rawrigidbodyset_rbEnableCcd","rbMass","rawrigidbodyset_rbMass","rbInvMass","rawrigidbodyset_rbInvMass","rbEffectiveInvMass","rawrigidbodyset_rbEffectiveInvMass","rbLocalCom","rawrigidbodyset_rbLocalCom","rbWorldCom","rawrigidbodyset_rbWorldCom","rbInvPrincipalInertiaSqrt","rawrigidbodyset_rbInvPrincipalInertiaSqrt","rbPrincipalInertiaLocalFrame","rawrigidbodyset_rbPrincipalInertiaLocalFrame","rbPrincipalInertia","rawrigidbodyset_rbPrincipalInertia","rbEffectiveWorldInvInertiaSqrt","rawrigidbodyset_rbEffectiveWorldInvInertiaSqrt","RawSdpMatrix3","rbEffectiveAngularInertia","rawrigidbodyset_rbEffectiveAngularInertia","rbWakeUp","rawrigidbodyset_rbWakeUp","rbIsCcdEnabled","rawrigidbodyset_rbIsCcdEnabled","rbNumColliders","rawrigidbodyset_rbNumColliders","rbCollider","at","rawrigidbodyset_rbCollider","rbBodyType","rawrigidbodyset_rbBodyType","rbSetBodyType","status","rawrigidbodyset_rbSetBodyType","rbIsFixed","rawrigidbodyset_rbIsFixed","rbIsKinematic","rawrigidbodyset_rbIsKinematic","rbIsDynamic","rawrigidbodyset_rbIsDynamic","rbLinearDamping","rawrigidbodyset_rbLinearDamping","rbAngularDamping","rawrigidbodyset_rbAngularDamping","rbSetLinearDamping","rawrigidbodyset_rbSetLinearDamping","rbSetAngularDamping","rawrigidbodyset_rbSetAngularDamping","rbSetEnabled","rawrigidbodyset_rbSetEnabled","rbIsEnabled","rawrigidbodyset_rbIsEnabled","rbGravityScale","rawrigidbodyset_rbGravityScale","rbSetGravityScale","rawrigidbodyset_rbSetGravityScale","rbResetForces","rawrigidbodyset_rbResetForces","rbResetTorques","rawrigidbodyset_rbResetTorques","rbAddForce","force","rawrigidbodyset_rbAddForce","rbApplyImpulse","impulse","rawrigidbodyset_rbApplyImpulse","rbAddTorque","torque","rawrigidbodyset_rbAddTorque","rbApplyTorqueImpulse","torque_impulse","rawrigidbodyset_rbApplyTorqueImpulse","rbAddForceAtPoint","rawrigidbodyset_rbAddForceAtPoint","rbApplyImpulseAtPoint","rawrigidbodyset_rbApplyImpulseAtPoint","rbAdditionalSolverIterations","rawrigidbodyset_rbAdditionalSolverIterations","rbSetAdditionalSolverIterations","iters","rawrigidbodyset_rbSetAdditionalSolverIterations","rbUserData","rawrigidbodyset_rbUserData","rbSetUserData","data","rawrigidbodyset_rbSetUserData","rawrigidbodyset_new","createRigidBody","gravityScale","massOnly","translationEnabledX","translationEnabledY","translationEnabledZ","rotationEnabledX","rotationEnabledY","rotationEnabledZ","linearDamping","angularDamping","rb_type","canSleep","sleeping","ccdEnabled","dominanceGroup","additional_solver_iterations","rawrigidbodyset_createRigidBody","rawrigidbodyset_remove","rawrigidbodyset_contains","forEachRigidBodyHandle","rawrigidbodyset_forEachRigidBodyHandle","propagateModifiedBodyPositionsToColliders","rawrigidbodyset_propagateModifiedBodyPositionsToColliders","__wbg_rawrotation_free","rawrotation_new","identity","rawrotation_identity","rawrotation_x","__wbg_rawsdpmatrix3_free","elements","rawsdpmatrix3_elements","RawSerializationPipeline","__wbg_rawserializationpipeline_free","rawserializationpipeline_new","serializeAll","rawserializationpipeline_serializeAll","deserializeAll","rawserializationpipeline_deserializeAll","__wbg_rawshape_free","cuboid","hx","hy","hz","rawshape_cuboid","roundCuboid","borderRadius","rawshape_roundCuboid","ball","rawshape_ball","halfspace","rawshape_halfspace","capsule","halfHeight","rawshape_capsule","cylinder","rawshape_cylinder","roundCylinder","rawshape_roundCylinder","cone","rawshape_cone","roundCone","rawshape_roundCone","polyline","indices","ptr0","__wbindgen_malloc","len0","ptr1","len1","rawshape_polyline","trimesh","rawshape_trimesh","heightfield","nrows","ncols","heights","scale","rawshape_heightfield","segment","p1","p2","rawshape_segment","triangle","p3","rawshape_triangle","roundTriangle","rawshape_roundTriangle","convexHull","points","rawshape_convexHull","roundConvexHull","rawshape_roundConvexHull","convexMesh","rawshape_convexMesh","roundConvexMesh","rawshape_roundConvexMesh","shapePos1","shapeRot1","shapeVel1","shapeVel2","rawshape_castShape","intersectsShape","rawshape_intersectsShape","contactShape","rawshape_contactShape","containsPoint","rawshape_containsPoint","rawshape_projectPoint","intersectsRay","rawshape_intersectsRay","rawshape_castRay","rawshape_castRayAndGetNormal","__wbg_rawshapecollidertoi_free","witness1","witness2","rawshapecollidertoi_witness2","normal1","normal2","__wbg_rawshapecontact_free","point1","point2","__wbg_rawshapetoi_free","rawshapetoi_witness1","rawcontactforceevent_total_force","rawshapetoi_normal1","rawshapetoi_normal2","__wbg_rawvector_free","zero","rawvector_zero","rawvector_new","rawvector_set_x","rawvector_set_z","xyz","rawvector_xyz","yxz","rawvector_yxz","zxy","rawvector_zxy","xzy","rawvector_xzy","yzx","rawvector_yzx","zyx","rawvector_zyx","Vector3","VectorOps","intoRaw","v","zeros","new","fromRaw","raw","res","copy","out","input","Quaternion","RotationOps","rot","SdpMatrix3","m11","m12","m21","m13","m31","m22","m23","m32","m33","SdpMatrix3Ops","sdpMatrix3","RigidBodyType","JointType","MotorModel","JointAxesMask","CoefficientCombineRule","FeatureType","ShapeType","QueryFilterFlags","ActiveEvents","ActiveHooks","SolverFlags","ActiveCollisionTypes","MassPropsMode","RigidBody","rawSet","colliderSet","finalizeDeserialization","isValid","lockTranslations","lockRotations","setEnabledTranslations","enableX","enableY","enableZ","restrictTranslations","setEnabledRotations","restrictRotations","setDominanceGroup","additionalSolverIterations","setAdditionalSolverIterations","enableCcd","nextTranslation","nextRotation","setTranslation","tra","setLinvel","vel","rawVel","setGravityScale","setRotation","setAngvel","setNextKinematicTranslation","t","setNextKinematicRotation","effectiveInvMass","invMass","localCom","worldCom","invPrincipalInertiaSqrt","principalInertia","principalInertiaLocalFrame","effectiveWorldInvInertiaSqrt","effectiveAngularInertia","sleep","isCcdEnabled","numColliders","collider","get","setEnabled","isEnabled","bodyType","setBodyType","type","isSleeping","isMoving","isFixed","isKinematic","isDynamic","setLinearDamping","recomputeMassPropertiesFromColliders","setAdditionalMass","setAdditionalMassProperties","angularInertiaLocalFrame","rawCom","rawPrincipalInertia","rawInertiaFrame","setAngularDamping","resetForces","resetTorques","addForce","rawForce","applyImpulse","rawImpulse","addTorque","rawTorque","applyTorqueImpulse","torqueImpulse","rawTorqueImpulse","addForceAtPoint","rawPoint","applyImpulseAtPoint","RigidBodyDesc","translationsEnabledX","translationsEnabledY","translationsEnabledZ","rotationsEnabledX","rotationsEnabledY","rotationsEnabledZ","dynamic","Dynamic","kinematicPositionBased","KinematicPositionBased","kinematicVelocityBased","KinematicVelocityBased","newDynamic","newKinematicPositionBased","newKinematicVelocityBased","newStatic","TypeError","enabledTranslations","enabledRotations","setCanSleep","can","setSleeping","setCcdEnabled","setUserData","userData","Coarena","fconv","uconv","size","index","forEach","elt","getAll","filter","RigidBodySet","map","rb","desc","rawTra","rawRot","rawLv","rawAv","impulseJoints","multibodyJoints","unmap","forEachJointHandleAttachedToRigidBody","delete","forEachActiveRigidBody","IntegrationParameters","ImpulseJoint","bodySet","newTyped","RevoluteImpulseJoint","PrismaticImpulseJoint","FixedImpulseJoint","SpringImpulseJoint","RopeImpulseJoint","SphericalImpulseJoint","GenericImpulseJoint","body1","body2","frameX1","frameX2","setAnchor1","setAnchor2","setContactsEnabled","contactsEnabled","UnitImpulseJoint","rawAxis","setLimits","configureMotorModel","configureMotorVelocity","configureMotorPosition","configureMotor","JointData","frame1","frame2","axesMask","rawAx","result","rawA1","rawA2","rawFra1","rawFra2","limits","rawAxesMask","ImpulseJointSet","joint","rawParams","MultibodyJoint","RevoluteMultibodyJoint","PrismaticMultibodyJoint","FixedMultibodyJoint","SphericalMultibodyJoint","UnitMultibodyJoint","MultibodyJointSet","CCDSolver","IslandManager","BroadPhase","NarrowPhase","tempManifold","TempContactManifold","contactPairsWith","intersectionPairsWith","contactPair","rawPair","flipped","intersectionPair","localNormal1","localNormal2","numContacts","localContactPoint1","localContactPoint2","contactDist","contactFid1","contactFid2","contactImpulse","contactTangentImpulseX","contactTangentImpulseY","numSolverContacts","solverContactPoint","solverContactDist","solverContactFriction","solverContactRestitution","solverContactTangentVelocity","ShapeContact","dist","PointProjection","PointColliderProjection","Unknown","RayIntersection","RayColliderIntersection","RayColliderToi","ShapeTOI","ShapeColliderTOI","super","Shape","rawType","extents","vs","Heightfield","stopAtPenetration","rawPos1","rawRot1","rawVel1","rawPos2","rawRot2","rawVel2","rawShape1","rawShape2","rawPos","rawShape","ray","rawRayOrig","origin","rawRayDir","dir","n","halfExtents","a","b","ra","c","rc","rawScale","PhysicsPipeline","ccdSolver","rawG","filterContactPair","filterIntersectionPair","QueryPipeline","filterFlags","filterGroups","filterExcludeCollider","filterExcludeRigidBody","filterPredicate","rawOrig","rawDir","rawInter","rawCenter","rawHalfExtents","SerializationPipeline","rawGra","World","DebugRenderBuffers","DebugRenderPipeline","CharacterCollision","KinematicCharacterController","rawCharacterCollision","_applyImpulsesToDynamicBodies","_characterMass","rawVect","applyImpulsesToDynamicBodies","setApplyImpulsesToDynamicBodies","characterMass","setCharacterMass","desiredTranslationDelta","rawTranslationDelta","castClosure","DynamicRayCastVehicleController","_chassis","updateVehicle","currentVehicleSpeed","indexUpAxis","indexForwardAxis","setIndexForwardAxis","addWheel","chassisConnectionCs","directionCs","axleCs","suspensionRestLength","rawChassisConnectionCs","rawDirectionCs","rawAxleCs","numWheels","wheelChassisConnectionPointCs","setWheelChassisConnectionPointCs","rawValue","wheelSuspensionRestLength","setWheelSuspensionRestLength","wheelMaxSuspensionTravel","setWheelMaxSuspensionTravel","wheelRadius","setWheelRadius","wheelSuspensionStiffness","setWheelSuspensionStiffness","wheelSuspensionCompression","setWheelSuspensionCompression","wheelSuspensionRelaxation","setWheelSuspensionRelaxation","wheelMaxSuspensionForce","setWheelMaxSuspensionForce","wheelBrake","setWheelBrake","wheelSteering","setWheelSteering","wheelEngineForce","setWheelEngineForce","wheelDirectionCs","setWheelDirectionCs","wheelAxleCs","setWheelAxleCs","wheelFrictionSlip","setWheelFrictionSlip","wheelSideFrictionStiffness","setWheelSideFrictionStiffness","wheelRotation","wheelForwardImpulse","wheelSideImpulse","wheelSuspensionForce","wheelContactNormal","wheelContactPoint","wheelSuspensionLength","wheelHardPoint","wheelIsInContact","wheelGroundObject","rawIntegrationParameters","rawIslands","rawBroadPhase","rawNarrowPhase","rawBodies","rawColliders","rawImpulseJoints","rawMultibodyJoints","rawCCDSolver","rawQueryPipeline","rawPhysicsPipeline","rawSerializationPipeline","rawDebugRenderPipeline","ColliderSet","queryPipeline","physicsPipeline","serializationPipeline","debugRenderPipeline","characterControllers","Set","vehicleControllers","controller","takeSnapshot","restoreSnapshot","debugRender","updateSceneQueries","timestep","niter","createCharacterController","add","removeCharacterController","createVehicleController","removeVehicleController","parentHandle","createImpulseJoint","createMultibodyJoint","getRigidBody","getCollider","getImpulseJoint","getMultibodyJoint","removeRigidBody","removeCollider","removeImpulseJoint","removeMultibodyJoint","forEachCollider","forEachRigidBody","TempContactForceEvent","totalForce","total_force","totalForceMagnitude","total_force_magnitude","maxForceDirection","max_force_direction","maxForceMagnitude","max_force_magnitude","Collider","_parent","_shape","ensureShapeIsCached","setSensor","setShape","setRestitution","setFriction","setFrictionCombineRule","setRestitutionCombineRule","setCollisionGroups","setSolverGroups","setActiveHooks","setActiveEvents","setContactForceEventThreshold","setActiveCollisionTypes","setDensity","setMass","setMassProperties","setTranslationWrtParent","setRotationWrtParent","shapeType","setHalfExtents","setRadius","roundRadius","setRoundRadius","setHalfHeight","heightfieldHeights","heightfieldScale","heightfieldNRows","heightfieldNCols","volume","rawCollider1Vel","rawShape2Pos","rawShape2Rot","rawShape2Vel","castCollider","rawCollider2Vel","contactCollider","ColliderDesc","Density","Average","DEFAULT","NONE","sensor","Mass","MassProps","isNaN","event","pointAt","deferred1_0","deferred1_1","version","vers"],"mappings":"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","x_google_ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32]}